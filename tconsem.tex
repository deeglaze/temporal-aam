%% FIXME
We present and analyze a slightly different formulation than \dfm's temporal contracts that allows for more precise specification of value-use.
%
But first, we must discuss why we do not import \dfm's semantics directly.
%
\subsection{\dfm's semantics}
\newcommand{\denotedfm}[2]{\denote{#1}_{#2}}
\begin{figure}
\setlength{\abovedisplayskip}{0pt}
\setlength{\belowdisplayskip}{4pt}
\setlength{\abovedisplayshortskip}{0pt}
\setlength{\belowdisplayshortskip}{8pt}
  \begin{align*}
    \denotedfm{\bullet}{\bullet} &: \TContract^\circ \times \MEnv \to \wp(\mathit{Trace})
    \\
    \mmenv \in \MEnv &::= \epsilon \alt \mmenv, \mvar : \msendrec \mscon
    \\
    \msendrec &\in \setof{{\tt send}, {\tt recv}} \text{, and }\sim \text{ a notion of ``matches.''}
  \end{align*}
  \begin{align*}
    \denotedfm{\scevdfm{\mtoplevelname}{\mvpat}}{\mmenv} &=
      \setbuild{\msendrec.\scevdfm{y}{d}}{\mmenv(y) \equiv \msendrec'\sarr{\mtoplevelname}{\_}{\_}, \mvpat \sim d}
    \\
    \denotedfm{\snonevent{\mevent}}{\mmenv} &= \Action \setminus \denotedfm{\mevent}{\mmenv}
    \\
    \denotedfm{\stseq{\motcon_0}{\motcon_1}}{\mmenv} &= \denotedfm{\motcon_0}{\mmenv} \mathrel{\cdot} \denotedfm{\motcon_1}{\mmenv}
    \\
    \denotedfm{\stmany{\motcon{}}}{\mmenv} &= \stmany{\denotedfm{\motcon}{\mmenv}}
    \\
    \denotedfm{\stnot{\motcon}}{\mmenv} &= \mathit{Trace} \setminus \denotedfm{\motcon}{\mmenv}
    \\
    \denotedfm{\stOr{\isset{\motcon}}}{\mmenv} &= \bigcup\denotedfm{\motcon}{\mmenv}\ldots
    \\
    \denotedfm{\sddd}{\mmenv} &= \mathit{Trace}
    \\
    \denotedfm{\stbind{\scevdfm{\mtoplevelname}{? \mvar}}{\motcon}}{\mmenv} &= \setbuild{\msendrec.\scevdfm{y}{c}\mtrace}{\mmenv(y) \equiv \msendrec'\sarr{\mtoplevelname}{\_}{\_}, \mtrace \in \denotedfm{\motcon[\mvar := c]}{\mmenv}}
  \end{align*}
  \caption{\dfm's semantics of temporal contracts}
  \label{fig:dfm-semantics}
\end{figure}
%
The semantics presented in \autoref{fig:dfm-semantics} is a recollection of the denotational semantics that \dfm{} gives to temporal contracts.
%
They use a module semantics based on an $\mathit{EF}$ machine that tracks the bindings shared across module boundaries, $\mmenv$ (originally $E$ but renamed to distinguish from evaluation contexts), and a stack of module boundaries to return to, $F$.
%
Regardless of how this machine works, the denotation of a temporal contract attached to a structural contract, $\denote{\mscon\ {\tt where}\ \motcon}$, is generated by traces of $\mathit{EF}$ that are driven by sent or received calls and return actions (roughly):
\begin{align*}
 \left\{
   \begin{array}{l}
    {\tt send.ret}(\mathit{start},h)\mtrace \in \prefixes(\denotedfm{\motcon}{\mmenv}) :
 \\ \qquad\langle \mmenv_0, \mathit{start}\rangle \Rightarrow^\mtrace \langle \mmenv, F\rangle \wedge \mmenv_0 = \epsilon, h : {\tt send}S
\end{array}\right\}
\end{align*}

The use of $\prefixes$ in this definition is problematic, and negation is the culprit.
%
Contracts that state anything about how a trace may not end would allow just such traces since \emph{extensions} to such ``bad traces'' are acceptable, and prefix closure will throw the ``bad traces'' back into what is acceptable.
%
%Additionally, if one writes a contract more carefully to reject extensions of bad traces, there isn't an obvious operational interpretation that allows early failure.
%
For example, the denotation of temporal contracts from \dfm{} allows $\mevent\mevent \in \prefixes(\denote{\stnot{\mevent}})$, and because of prefix closure, $\mevent \in \prefixes(\denote{\stnot{\mevent}})$.
%
Temporal contract failure should not be contingent on future observations; an effective monitor should blame \emph{as soon as} a contract is violated.
%%

%%
\dfm's semantics for referring to functions is additionally problematic; we give a slightly different account that captures the spirit of their prose describing their system, and more closely reflects their implementation.
%
The temporal component of the example discussed in \autoref{sec:sort} was originally the following:
\begin{align*}
 \stnot{(\sddd~ \sortid(\_)~ \stmany{\snonevent{\retof{\sortid}(\_)}}~ \sortid(\_))} 
 \ \cap\  \stnot{\sddd~ \retof{\sortid}(\_) \sddd~ \mathit{cmp}(\_)}
\end{align*}

In contrast to our restatement, the flat use of \emph{labels} instead of \emph{bindings} would cause a second call to a supposedly-correct $\sortid$ to fail, since it internally calls the comparator of the same label, but of a different monitor construction.
%
Their implementation works around this by additionally adding a monitor-wrapping action, that generates a new label to pair with the function label to uniquely identify it.
%%

\subsection{Our semantics}
%
As noted in \autoref{sec:sort}, temporal contracts are associated with structural contracts that label function components within them.
%
For simple exposition, we will consider tuples as the main organizational tool for contracting the interactions between multiple functions.
%
Since we consider monitor constructions as a more basic notion of equality, we also see each temporal monitor construction as starting its own \emph{timeline}, which sees its own filtered view of actions in the system.
%
Thus, as values flow through contract boundaries, they are considered on different timelines.
%
\dfm{} formalized their semantics in terms of a nondeterministic machine that defined its interactions on all action streams, and thus their machine was on a single timeline.
%
The semantics of temporal contracts that we propose uses a weak equality for comparisons of non-primitive data, which we evaluate as structural equality up to closures, where we use pointer-equality.
%
Our semantics makes interaction between temporal contract monitors explicit, allowing us to verify whole programs.
%%

%
To combat the problems introduced by \dfm's original use of $\prefixes$ on top of a semantics of full traces, we give a different semantics for temporal contracts that alternates between \emph{full traces} and \emph{partial traces}.
%
Additionally, a negated temporal contract will reject all non-empty full traces of the given contract, as well as any extension of such traces.
%
This semantics of negation does not satisfy double-negation elimination (DNE), but we find that to be an acceptable trade-off; we do not need DNE in order to implement or verify temporal contracts.
%
We claim that this semantics is what \dfm{} intended their system to mean, as it matches up with the expectations of their prose, the test cases in their implementation\footnote{The functional test cases, in particular, since our model does not handle Racket's object system.}, and additionally raises blame on programs that \dfm{} were surprised their implementation accepted.
%
Since our semantics catches more ``bad'' behavior than their monitoring system, we have not simply formalized their implementation.
%%

%%
The denotational semantics in \autoref{fig:tcontract-denotation} lends itself nicely to online monitoring via a derivative parsing approach.
%
For each action $\mevent$ we come across on a timeline $\mtimeline$, we set $\mTMons(\mtimeline)$ to $\derive{\mevent}{\mTMons(\mtimeline)}$, as long as the derivative isn't failing.
%
We can show that the partial trace semantics is prefix-closed (\autoref{thm:prefix-closed}), and thus we can pinpoint the cause of an error as soon as it is sent to the monitor --- a necessary condition for effective blame management in this realm.
%%

%%
We made the design choice that call actions for bound variables ($\scallev{\mvar}{\mvpat}$) will only be sent to the temporal monitor if the value bound to $\mvar$ is itself contracted on the monitor's timeline.
%
The reason for this is that control should flow back to the timeline considered in order for an action to affect that timeline.
%
It is easy enough to amend the structural contracts to reflect the fact that a binding is considered a function in the temporal contract.

\begin{theorem}[Prefix closure]\label{thm:prefix-closed}
  $\prefixes(\denotetcone{\motcon}{\menv}) = \denotetcone{\motcon}{\menv}$
\end{theorem}

%\FloatBarrier
\newcommand*{\tconsemfigs}[4]{
 \iftwocolumn{\begin{figure}#1 #2\end{figure}
              \begin{figure}#3 #4\end{figure}}
             {\begin{figure}
              \begin{minipage}[b]{.55\linewidth}#1 #2\hrule height 0pt\end{minipage}
              \begin{minipage}[b]{.40\linewidth}#3 #4\hrule height 0pt\end{minipage}
             \end{figure}}}
\tconsemfigs{
    \begin{align*}
      \denotetconbothe{\stOr{\isset{\motcon}}}{\menv} &=
      \bigcup\denotetconbothe{\motcon}{\menv}\ldots
      \\
      \denotetconbothe{\stAnd{\isset{\motcon}}}{\menv} &=
      \bigcap\denotetconbothe{\motcon}{\menv}\ldots
      \\
      \denotetconbothe{\epsilon}{\menv} &= \setof{\epsilon}
      \\
      \denotetconbothe{\stnot{\motcon}}{\menv} &=
      \semneg{\denotetconfulle{\motcon}{\menv}}
      \\[2pt]
      \denotetcone{\stmany{\motcon{}}}{\menv} &=
      \denotetconfulle{\stmany{\motcon{}}}{\menv} \mathrel{\cdot}
      \denotetcone{\motcon}{\menv}
      \\
      \denotetcone{\stseq{\motcon_0}{\motcon_1}}{\menv} &=
      \denotetcone{\motcon_0}{\menv} \cup
      \denotetconfulle{\motcon_0}{\menv}\mathrel{\cdot}
      \denotetcone{\motcon_1}{\menv}
      \\
     \denotetcone{\stbind{\mevent}{\motcon}}{\menv} &=
      \setof{\epsilon}\cup
        \{ \mdata \mtrace : \mdata,\menv' \in \denoteevent{\mevent}{\menv},
        \\&\phantom{= \setof{\epsilon}\cup \{ \mdata\mtrace : } \mtrace \in \denotetcone{\motcon}{\menv'} \}
     \\
      \denotetcone{\mevent}{\menv} &= \setof{\epsilon}\cup\denotetconfulle{\mevent}{\menv}
      \\[2pt]
      \denotetconfulle{\stseq{\motcon_0}{\motcon_1}}{\menv} &=
      \denotetconfulle{\motcon_0}{\menv} \mathrel{\cdot}
      \denotetconfulle{\motcon_1}{\menv}
      \\
      \denotetconfulle{\stmany{\motcon{}}}{\menv} &= \denotetconfulle{\motcon}{\menv}^*
      \\
     \denotetconfulle{\stbind{\mevent}{\motcon}}{\menv} &=
     \setbuild{\mdata \mtrace}{\mdata,\menv' \in \denoteevent{\mevent}{\menv}, \mtrace \in \denotetconfulle{\motcon}{\menv'}}
     \\
      \denotetconfulle{\mevent}{\menv} &= \setbuild{\mdata}{\mdata,\menv' \in \denoteevent{\mevent}{\menv}}
      \\[2pt]
      \denoteevent{\mevent}{\menv} &= \setbuild{\mdata,\menv'}{\menv'_\must = \matches(\mevent, \mdata, \menv)}
      \\
      \semneg{\Pi} &= \setbuild{\mtrace}{\forall \mtrace' \in
        \Pi\setminus\setof{\epsilon}. \mtrace' \nleq \mtrace}
    \end{align*}}{\caption{Denotational Semantics of Temporal Contracts ($B$ means both $P$ and $F$)}\label{fig:tcontract-denotation}}
  {\begin{align*}
      \derivee{\mdata}{\epsilon}{\menv} &= \bot
      \\
      \derivee{\mdata}{\mevent}{\menv} &= \left\{
        \begin{array}{ll}
          \epsilon & \text{if } \menv'_\must = \matches(\mevent, \mdata, \menv) \\
          \bot & \text{otherwise}
        \end{array}\right.
      \\
      \derivee{\mdata}{\stbind{\mevent}{\motcon}}{\menv} &=
      \left\{\begin{array}{ll}
          \motcon,\menv' & \text{if } \menv'_\must = \matches(\mevent, \mdata, \menv) \\
          \bot & \text{otherwise}
        \end{array}\right.
      \\
      \derivee{\mdata}{\stseq{\motcon_0}{\motcon_1}}{\menv} &=
      \stOr{\setof{\derivee{\mdata}{\motcon_0}{\menv},\
          \stseq{\nullable(\motcon_0)}{\derivee{\mdata}{\motcon_1}{\menv}}}}
      \\
      \derivee{\mdata}{\stOr{\isset{\motcon}}}{\menv} &=
      \stOr{\derivee{\mdata}{\motcon}{\menv}\ldots}
      \\
      \derivee{\mdata}{\stAnd{\isset{\motcon}}}{\menv} &=
      \stAnd{\derivee{\mdata}{\motcon}{\menv}\ldots}
      \\
      \derivee{\mdata}{\stmany{\motcon{}}}{\menv} &=
      \stseq{\derivee{\mdata}{\motcon}{\menv}}{\stmany{\motcon{}}}
      \\
      \derivee{\mdata}{\stnot{\motcon}}{\menv} &=
      \nullable(\derivee{\mdata}{\motcon}{\menv}) \to \bot,
      \stnot{\derivee{\mdata}{\motcon}{\menv}}
      \\[2pt]
      \nullable(\epsilon) &= \nullable(\stmany{\motcon{}}) =
      \nullable(\stnot{\motcon}) = \epsilon
      \\
      \nullable(\stbind{\mevent}{\motcon}) &= \nullable(\mevent) = \bot
      \\
      \nullable(\stOr{\isset{\motcon}}) &=
      \bigvee{\nullable(\motcon)\ldots}
      \\
      \nullable(\stAnd{\isset{\motcon}}) &=
      \bigwedge{\nullable(\motcon)\ldots}
      \\
      \nullable(\stseq{\motcon_0}{\motcon_1}) &=
      \nullable(\motcon_0)\wedge \nullable(\motcon_1)
      \\
      \nullable(\motcon,\menv) &= \nullable(\motcon)
    \end{align*}}{\caption{Derivatives of Temporal Contracts}\label{fig:tcon-deriv}}

The semantics and derivatives here are simplified to the concrete case, for space.
%
The extension to support the approximate matching semantics uses the appropriate logical connectives across $\cup$, $\cap$ and $\neg$ to compute the overall valuation of the temporal contract following a derivation.
%
Multiple possible matches (given from $\matches$) lead to multiple possible derivations, and the temporal contract connectives are lifted over these sets of derivatives.
%
Thus, derivatation produces a set of possible derivations and a valuation indicating how sure we are to \emph{not} blame.
%%

\newcommand*{\matchsemfigs}[4]{
 \iftwocolumn{\begin{figure} #1 #2 \end{figure}
              \begin{figure} #3 #4 \end{figure}}
             {\begin{figure}
              \begin{minipage}[b]{.50\linewidth}#1 #2\hrule height 0pt\end{minipage}
              \begin{minipage}[b]{.45\linewidth}#3 #4\hrule height 0pt\end{minipage}
             \end{figure}}} 
\matchsemfigs{
\setlength{\abovedisplayskip}{0pt}
\setlength{\belowdisplayskip}{4pt}
\setlength{\abovedisplayshortskip}{0pt}
\setlength{\belowdisplayshortskip}{8pt}
  \begin{align*}
    \matches &: \Pattern \times \Qualified \times \Env \to \wp(\MatchResult) \\
    \Delta &: \wp(\MatchResult) \to \MatchResult \\
    \delta &: \wp(\Valuation) \to \Valuation
  \end{align*}
    \begin{align*}
      \mvaluation \in \Valuation &::= \may \alt \must \alt \bot \\
      \mpat \in \Pattern &::= \VPat \text{ rules plus } \alt \mconstructor(\many{\mpat}) \\
      S \subset \MatchResult &::= \menvs_\mvaluation \\
      \menvs_\bot &= \emptyset_\bot = \emptyset_\mvaluation \\
      \mdata \in \Qualified &= \isset{\mdata} \alt \mval \alt \mconstructor(\many{\mdata}) \\
      \mconstructor \in \Constructors &= \setof{{\tt call}, {\tt ret}, {\tt cons}}
      \\[2pt]
      \must \wedge \must &= \must \\
      \bot \wedge \_ &= \_ \wedge \bot = \bot \\
      \may \wedge \_ &= \_ \wedge \may = \may
      \\[2pt]
      \neg \must &= \bot \\
      \neg \may &= \may \\
      \neg \bot &= \must
    \\[2pt]
    \menvs \bowtie \menvs' &= \setbuild{\combinef{\menv}{\menv'}}{\menv \in \menvs, \menv' \in \menvs'} \\
    \combinef{\menv}{\menv'} &= \lambda x. x \in \dom(\menv') \to \menv'(x), \menv(x)
    \end{align*}}
  {\caption{Spaces and functions for matching}\label{fig:matchspace}}
  {\begin{align*}
%    \matches &: \Pattern \times \Qualified \times \Env \to \MatchResult \\
    \matches(\sany, \_, \menv) &= \menv_\must \\
    \matches(\snone, \_, \menv) &= \emptyset_\bot \\
    \matches(\mtoplevelname, \snlam{\mtoplevelname}{\mvar}{\mexp}, \menv) &= \menv_\must \\
    \matches(\snegpat{\mvpat}, \mdata, \menv) &= \menv_{\neg \mvaluation} \\
    \text{where }& \matches(\mvpat, \mdata, \menv) = \menv'_\mvaluation \\
    \matches(\sbind{\mvar}, \mdata, \menv) &= \menv[\mvar \mapsto \mdata]_\must \\
    \matches(\mvar, \mdata, \menv) &= \menv_{\menv(\mvar) \simeq \mdata} \\
    \matches(\mconstructor(\many{\mpat}), \mconstructor(\many{\mdata}), \menv) &= (\Bowtie \menvs \ldots)_{\bigwedge \mvaluation \ldots} \\
    \text{where }& \menvs_\mvaluation \ldots = \matches(\mvpat, \mdata, \menv) \ldots \\
    \matches(\mpat, \isset{\mdata}, \menv) &= \Delta\setbuild{\matches(\mpat, \mdata, \menv)}{\mdata \in \isset{\mdata}} \\
    \matches(\mdata, \mdata', \menv) &= \menv_{\mdata \simeq \mdata'} \\
    \matches(\mpat, \mdata, \menv) &= \emptyset_\bot \quad
    \text{otherwise}
    \\[2pt]
    \Delta S &= (\bigcup\limits_{\menvs_{\_} \in S}\menvs)_{\delta \setbuild{\mvaluation}{{\_}_\mvaluation \in S}} \\
    \delta \emptyset &= \bot \\
    \delta \setof{\mvaluation} &= \mvaluation \\
    \delta \isset{t} &= \may \quad \text{otherwise}
  \end{align*}}{\caption{Semantics of matching}\label{fig:matchsem}}

We define our semantics of matching in \autoref{fig:matchsem} in anticipation of abstraction, where we do not always know when two values are equal.
%
When matching against a set of possible values, we might have a $\must$ match and a $\bot$ match, in which case the entire match should be considered $\may$ matching (this is the significance of the $\Delta$ metafunction).
%
The $\triangleleft$ operator extends the left environment with the bindings of the right, though the order doesn't matter considering that binding patterns may not bind the same variable twice.
%
Matching against sets of values makes it possible that we have several possible matches.
%
Thus $\matches$ returns a set of environments possible from matching a given pattern against some data.
%
At the leaves, when considering values of the language equal, $\matches$ appeals to a weak equality function, $\simeq$, where $\mval \simeq \mval' = \must$ implies $\mval = \mval'$ in the concrete semantics, and $\mval \simeq \mval' = \bot$ implies $\mval \neq \mval'$ in the concrete semantics.
%%

%%
We say $\mexp$ satisfies a temporal contract $\mtcon$ if its action trace filtered by the timeline to which the contract is attached is in the denotation of the temporal contract ($\denotetcon{\mtcon}$).
%
Since monitors are generated during reduction, the proof is mostly technical that our monitoring system ensures an expression either satisfies its contract or blames, and hinges mainly on the correctness of derivatives:
%

\begin{theorem}[Full]\label{thm:full}
 $\denotetconfull{\derivee{\mdata}{\motcon}{\menv}} = \setbuild{\mtrace}{\mdata\mtrace \in \denotetconfulle{\motcon}{\menv}}$
\end{theorem}

\begin{theorem}[Partial]\label{thm:partial}
 $\denotetcon{\derivee{\mdata}{\motcon}{\menv}} = \setbuild{\mtrace}{\mdata\mtrace \in \denotetcone{\motcon}{\menv}}$
\end{theorem}

\begin{theorem}[Top level full]\label{thm:top-full}
 $\denotetconfull{\derive{\mdata}{\mtcon}} = \setbuild{\mtrace}{\mdata\mtrace \in \denotetconfull{\mtcon}}$
\end{theorem}

\begin{theorem}[Top level partial]\label{thm:top-partial}
 $\denotetcon{\derive{\mdata}{\mtcon}} = \setbuild{\mtrace}{\mdata\mtrace \in \denotetcon{\mtcon}}$
\end{theorem}

The latter three fall out of the first from simple inductions.
%
The first theorem depends on the following lemma, which follows from a simple induction.

\begin{lemma}[Nullability]\label{lem:nullability}
  $\nullable(\motcon) = \epsilon \iff \epsilon \in \denotetconfulle{\motcon}{\menv}$
\end{lemma}

\autoref{thm:full} has a straightforward proof except in the $\neg$ case, shown below:
%
\begin{byCases}
  \iftwocolumn{}
  {\fontsize{8pt}{9pt}\selectfont}
  \case{\motcon \equiv \stnot{\motcon{}'}}{
    \begin{byCases}
      \case{H : \nullable(\derivee{\mdata}{\motcon{}'}{\menv}) = \epsilon}{
        \begin{pfsteps*}
          \item{$\denotetconfull{\derivee{\mdata}{\motcon}{\menv}} = \emptyset$} \BY{computation}
          \item{$\epsilon \in \denotetconfull{\derivee{\mdata}{\motcon{}'}{\menv}}$}
            \BY{$H$, lemma \ref{lem:nullability}} \pflabel{deriveeps}
          \item{$\mdata \in \denotetconfulle{\motcon{}'}{\menv}$} \BY{IH, \pfref{deriveeps}}
        \end{pfsteps*}
        To show $\setbuild{\mtrace}{\mdata\mtrace \in \denotetconfulle{\motcon}{\menv}} = \emptyset$, we suppose $\mtrace \in \semneg{\denotetconfulle{\motcon{}'}{\menv}}$ and show $\mtrace \nequiv \mdata\mtrace'$:
        \begin{byCases}
          \case{\mtrace \equiv \mdata\mtrace'}{
            Since $\mdata \in \denotetconfulle{\motcon{}'}{\menv}$, by definition of $\neg$, contradiction.}
          \otherwise{$\mtrace$ not prefixed by $\mdata$}
        \end{byCases}}
      \case{H : \nullable(\derivee{\mdata}{\motcon{}'}{\menv}) = \bot}{
\newcommand{\lhs}{\semneg{\setbuild{\mtrace}{\mdata\mtrace \in \denotetconfulle{\motcon{}'}{\menv}}}}
\newcommand{\rhs}{\semneg{\denotetconfulle{\motcon{}'}{\menv}}}
        \begin{pfsteps*}
          \item{$\epsilon \notin \denotetconfull{\derivee{\mdata}{\motcon{}'}{\menv}}$}
             \BY{lemma \ref{lem:nullability}} \pflabel{derivenoeps}
          \item{$\setbuild{\mtrace}{\mdata\mtrace \in \denotetconfulle{\motcon{}'}{\menv}} = \denotetconfull{\derivee{\mdata}{\motcon{}'}{\menv}}$} \BY{IH} \pflabel{IH}
          \item{$\mdata \notin \denotetconfulle{\motcon{}'}{\menv}$} \BY{\pfref{derivenoeps}, \pfref{IH}}
          \item{Goal is $\lhs = \setbuild{\mtrace}{\mevent\mtrace \in \rhs}$} \BY{computation}
        \end{pfsteps*}
        We prove this goal by bi-containment:
        \begin{byCases}
          \case{\mathit{Hs} : \mtrace \in \lhs}{
            \begin{pfsteps*}
              \item{$\forall \mtrace' \in \setbuild{\mtrace}{\mevent\mtrace \in \denotetconfulle{\motcon{}'}{\menv}}\setminus\setof{\epsilon}. \mtrace' \nleq \mtrace$}
                  \BY{$\mathit{Hs}$ and inversion} \pflabel{Hinv}
               \item{Suppose $\mtrace' \in \denotetconfulle{\motcon{}'}{\menv}$} \pflabel{let}
               \item{$\mtrace' \nleq \mevent\mtrace$}
                 \BY{\pfref{Hinv}, \pfref{let}, prefix cancellation} \pflabel{concl}
               \item{$\mtrace \in \rhs$} \BY{\pfref{concl}}
            \end{pfsteps*}}
          \case{\mathit{Hs} : \mtrace \in \rhs}{
            \begin{pfsteps*}
              \item{$\forall \mtrace' \in \denotetconfulle{\motcon{}'}{\menv}\setminus\setof{\epsilon}. \mtrace' \nleq \mevent\mtrace$}
                \BY{$\mathit{Hs}$, inversion} \pflabel{Hsinv1}
              \item{Suppose $\mtrace' \in \setbuild{\mtrace}{\mevent\mtrace \in \denotetconfulle{\motcon{}'}{\menv}} \setminus\setof{\epsilon}$} \pflabel{let}
              \item{$\mevent\mtrace' \in \denotetconfulle{\motcon{}'}{\menv}$} \BY{\pfref{let}} \pflabel{in}
              \item{$\mtrace' \nleq \mtrace$} \BY{\pfref{Hsinv1}, \pfref{in}, prefix cancellation} \pflabel{concl}
              \item{$\mtrace \in \lhs$} \BY{\pfref{concl}}
            \end{pfsteps*}}
        \end{byCases}}
    \end{byCases}}
\end{byCases}
%z

An interesting corollary relating paths to repeated derivation:
\begin{corollary}
  $\mtrace \in \denotetcon{\mtcon} \iff \nullable(\derive{\mtrace}{\mtcon}) = \epsilon$
\end{corollary}
% %
% Depends on
% \begin{lemma}[Flat emptiness]
%   $\flatempty(\mtcon) \implies \denotetconfull{\mtcon} = \emptyset$
% \end{lemma}
% where $\flatempty$ and $\flatempty_\menv$ are defined as (where $[_\menv]$ denotes the definition applies to both)
% \begin{align*}
%   \flatempty[_\menv](T) &= \bot \quad\text{if } T\equiv\epsilon,\, T\equiv(\stmany{\mtcon}),\,\text{or }T\equiv\stnot{\mtcon} \\
%   \flatempty[_\menv](\stbind{\mevent}{\mtcon}) &= \flatempty[_\menv](\mevent) \\
%   \flatempty[_\menv](\stOr{\isset{\mtcon}}) &= \bigwedge \flatempty[_\menv](\mtcon)\ldots \\
%   \flatempty[_\menv](\stAnd{\isset{\mtcon}}) &= \bigvee \flatempty[_\menv](\mtcon)\ldots \\
%   \flatempty[_\menv](\stseq{\mtcon_0}{\mtcon_1}) &= \flatempty[_\menv](\mtcon_0) \vee \flatempty[_\menv](\mtcon_1) \\
%   \flatempty(\mtcon,\menv) &= \flatempty_\menv(\mtcon) \\[2pt]
%   \flatempty[_\menv](\snone) &= \top \\
%   \flatempty_\menv(\mvar) &= (\menv(\mvar) \overset{?}{=} \emptyset) \\
%   \flatempty[_\menv](\snegpat{\mvpat}) &= \top \quad\text{if } \mvpat\equiv\sany,\, \mvpat\equiv\sbind{\mvar}, \text{ or } \mvpat\equiv\snegpat{\mvpat'} \text{ and } \flatempty[_\menv](\mvpat') \\
%   \flatempty[_\menv](\mvpat) &= \bot \quad\text{otherwise}
% \end{align*}
% %
% Our implementation reduces temporal contracts at construction time, so that the following invariant holds of represented contracts:
% \begin{equation*}
%  \flatempty(\mtcon) \iff \mtcon = \bot
% \end{equation*}
