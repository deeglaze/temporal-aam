%
As noted in \autoref{sec:sort}, temporal contracts are associated with structural contracts that label function components within them.
%
For simple exposition, we will consider tuples as the main organizational tool for contracting the interactions between multiple functions.
%
Since we consider monitor constructions as a more basic notion of equality, we also see each temporal monitor construction as starting its own \emph{timeline}, which sees its own filtered view of events in the system.
%
Thus, as values flow through contract boundaries, they are considered on different timelines.
%
\dfm{} formalized their semantics in terms of a nondeterministic machine that defined its interactions on all event streams, and thus their machine was on a single timeline.
%
The semantics of temporal contracts that we propose uses a weak equality for comparisons of non-primitive data, which we evaluate as structural equality up to closures, where we use pointer-equality.
%
Our semantics makes interaction between temporal contract monitors explicit, allowing us to verify whole programs.
%%

%%
A denotational semantics for temporal contracts is difficult to get right, since their behavior is implicitly prefix-closed.
%
Negation is the culprit: contracts that state anything about how a trace may not end would allow just such traces since extensions to such ``bad traces'' are acceptable, and prefix closure will throw the ``bad traces'' back into what is acceptable.
%
%Additionally, if one writes a contract more carefully to reject extensions of bad traces, there isn't an obvious operational interpretation that allows early failure.
%
For example, the denotation of temporal contracts from \dfm{} allows $\mevent\mevent \in \prefixes(\denote{\stnot{\mevent}})$, and because of prefix closure, $\mevent \in \prefixes(\denote{\stnot{\mevent}})$!
%
Temporal contract failure should not be contingent on future observations; an effective monitor should blame \emph{as soon as} a contract is not satisfied.
%
We thus have a different semantics for temporal contracts that alternates between \emph{full traces} and \emph{partial traces}; a negated temporal contract will reject all non-empty full traces of the given contract, as well as any extension of such traces.
%
This semantics of negation does not satisfy double-negation elimination (DNE), but we find that to be an acceptable trade-off; we do not need DNE in order to implement or verify temporal contracts.
%
We claim that this semantics is what \dfm{} intended their system to mean, as it matches up with the expectations of their prose, the test cases in their implementation\footnote{The functional test cases, in particular, since our model does not handle Racket's object system.}, and additionally raises blame on programs that \dfm{} were surprised their implementation accepted.
%
Since our semantics catches more ``bad'' behavior than their monitoring system, we have not simply formalized their implementation.
%%

%%
The denotational semantics in \autoref{fig:tcontract-denotation} lends itself nicely to online monitoring via a derivative parsing approach.
%
For each event $\mevent$ we come across on a timeline $\mtimeline$, we set $\mTMons(\mtimeline)$ to $\derive{\mevent}{\mTMons(\mtimeline)}$, as long as the derivative isn't failing.
%
We can show that the partial trace semantics is prefix-closed (\autoref{thm:prefix-closed}), and thus we can pinpoint the cause of an error as soon as it is sent to the monitor --- a necessary condition for effective blame management in this realm.
%%

%%
We made the design choice that call events for bound variables ($\scallev{\mvar}{\mvpat}$) will only be sent to the temporal monitor if the value bound to $\mvar$ is itself contracted on the monitor's timeline.
%
The reason for this is that control should flow back to the timeline considered in order for an event to affect that timeline.
%
It is easy enough to amend the structural contracts to reflect the fact that a binding is considered a function in the temporal contract.

\begin{theorem}[Prefix closure]\label{thm:prefix-closed}
  $\prefixes(\denotetcone{\mtcon}{\menv}) = \denotetcone{\mtcon}{\menv}$
\end{theorem}

%\FloatBarrier
\newcommand*{\matchsemfigs}[4]{
 \iftwocolumn{\begin{figure} #1 #2 \end{figure}
              \begin{figure} #3 #4 \end{figure}}
             {\begin{figure}
              \begin{minipage}[b]{.50\linewidth}#1 #2\hrule height 0pt\end{minipage}
              \begin{minipage}[b]{.45\linewidth}#3 #4\hrule height 0pt\end{minipage}
             \end{figure}}} 
\matchsemfigs{
\setlength{\abovedisplayskip}{0pt}
\setlength{\belowdisplayskip}{4pt}
\setlength{\abovedisplayshortskip}{0pt}
\setlength{\belowdisplayshortskip}{8pt}
  \begin{align*}
    \matches &: \Pattern \times \Qualified \times \Env \to \wp(\MatchResult) \\
    \Delta &: \wp(\MatchResult) \to \MatchResult \\
    \delta &: \wp(\Valuation) \to \Valuation
  \end{align*}
    \begin{align*}
      \mvaluation \in \Valuation &::= \may \alt \must \alt \bot \\
      \mpat \in \Pattern &::= \VPat \text{ rules plus } \alt \mconstructor(\many{\mpat}) \\
      S \subset \MatchResult &::= \menvs_\mvaluation \\
      \menvs_\bot &= \emptyset_\bot = \emptyset_\mvaluation \\
      \mdata \in \Qualified &= \isset{\mdata} \alt \mval \alt \mconstructor(\many{\mdata}) \\
      \mconstructor \in \Constructors &= \setof{{\tt call}, {\tt ret}, {\tt cons}}
      \\[2pt]
      \must \wedge \must &= \must \\
      \bot \wedge \_ &= \_ \wedge \bot = \bot \\
      \may \wedge \_ &= \_ \wedge \may = \may
      \\[2pt]
      \neg \must &= \bot \\
      \neg \may &= \may \\
      \neg \bot &= \must
    \\[2pt]
    \menvs \bowtie \menvs' &= \setbuild{\combinef{\menv}{\menv'}}{\menv \in \menvs, \menv' \in \menvs'} \\
    \combinef{\menv}{\menv'} &= \lambda x. x \in \dom(\menv') \to \menv'(x), \menv(x)
    \end{align*}}
  {\caption{Spaces and functions for matching}\label{fig:matchspace}}
  {\begin{align*}
%    \matches &: \Pattern \times \Qualified \times \Env \to \MatchResult \\
    \matches(\sany, \_, \menv) &= \menv_\must \\
    \matches(\snone, \_, \menv) &= \emptyset_\bot \\
    \matches(\mtoplevelname, \snlam{\mtoplevelname}{\mvar}{\mexp}, \menv) &= \menv_\must \\
    \matches(\snegpat{\mvpat}, \mdata, \menv) &= \menv_{\neg \mvaluation} \\
    \text{where }& \matches(\mvpat, \mdata, \menv) = \menv'_\mvaluation \\
    \matches(\sbind{\mvar}, \mdata, \menv) &= \menv[\mvar \mapsto \mdata]_\must \\
    \matches(\mvar, \mdata, \menv) &= \menv_{\menv(\mvar) \simeq \mdata} \\
    \matches(\mconstructor(\many{\mpat}), \mconstructor(\many{\mdata}), \menv) &= (\Bowtie \menvs \ldots)_{\bigwedge \mvaluation \ldots} \\
    \text{where }& \menvs_\mvaluation \ldots = \matches(\mvpat, \mdata, \menv) \ldots \\
    \matches(\mpat, \isset{\mdata}, \menv) &= \Delta\setbuild{\matches(\mpat, \mdata, \menv)}{\mdata \in \isset{\mdata}} \\
    \matches(\mdata, \mdata', \menv) &= \menv_{\mdata \simeq \mdata'} \\
    \matches(\mpat, \mdata, \menv) &= \emptyset_\bot \quad
    \text{otherwise}
    \\[2pt]
    \Delta S &= (\bigcup\limits_{\menvs_{\_} \in S}\menvs)_{\delta \setbuild{\mvaluation}{{\_}_\mvaluation \in S}} \\
    \delta \emptyset &= \bot \\
    \delta \setof{\mvaluation} &= \mvaluation \\
    \delta \isset{t} &= \may \quad \text{otherwise}
  \end{align*}}{\caption{Semantics of matching}\label{fig:matchsem}}

We define our semantics of matching in anticipation of abstraction, where we do not always know when two values are equal.
%
When matching against a set of possible values, we might have a $\must$ match and a $\bot$ match, in which case the entire match should be considered $\may$ matching (this is the significance of the $\Delta$ metafunction).
%
The $\triangleleft$ operator extends the left environment with the bindings of the right, though the order doesn't matter considering that binding patterns may not bind the same variable twice.
%
Matching against sets of values makes it possible that we have several possible matches.
%
Thus $\matches$ returns a set of environments possible from matching a given pattern against some data.
%
At the leaves, when considering values of the language equal, $\matches$ appeals to a weak equality function, $\simeq$, where $\mval \simeq \mval' = \must$ implies $\mval = \mval'$ in the concrete semantics, and $\mval \simeq \mval' = \bot$ implies $\mval \neq \mval'$ in the concrete semantics.

\newcommand*{\tconsemfigs}[4]{
 \iftwocolumn{\begin{figure}#1 #2\end{figure}
              \begin{figure}#3 #4\end{figure}}
             {\begin{figure}
              \begin{minipage}[b]{.55\linewidth}#1 #2\hrule height 0pt\end{minipage}
              \begin{minipage}[b]{.40\linewidth}#3 #4\hrule height 0pt\end{minipage}
             \end{figure}}}
\tconsemfigs{
    \begin{align*}
      \denotetconbothe{\stOr{\isset{\motcon}}}{\menv} &=
      \bigcup\denotetconbothe{\motcon}{\menv}\ldots
      \\
      \denotetconbothe{\stAnd{\isset{\motcon}}}{\menv} &=
      \bigcap\denotetconbothe{\motcon}{\menv}\ldots
      \\
      \denotetconbothe{\epsilon}{\menv} &= \setof{\epsilon}
      \\
      \denotetconbothe{\stnot{\motcon}}{\menv} &=
      \semneg{\denotetconfulle{\motcon}{\menv}}
      \\[2pt]
      \denotetcone{\stmany{\motcon{}}}{\menv} &=
      \denotetconfulle{\stmany{\motcon{}}}{\menv} \semseq
      \denotetcone{\motcon}{\menv}
      \\
      \denotetcone{\stseq{\motcon_0}{\motcon_1}}{\menv} &=
      \denotetcone{\motcon_0}{\menv} \cup
      \denotetconfulle{\motcon_0}{\menv}\semseq
      \denotetcone{\motcon_1}{\menv}
      \\
     \denotetcone{\stbind{\mevent}{\motcon}}{\menv} &=
      \setof{\epsilon}\cup
        \{ \mdata \mtrace : \mdata,\menv' \in \denoteevent{\mevent}{\menv},
        \\&\phantom{= \setof{\epsilon}\cup \{ \mdata\mtrace : } \mtrace \in \denotetcone{\motcon}{\menv'} \}
     \\
      \denotetcone{\mevent}{\menv} &= \setof{\epsilon}\cup\denotetconfulle{\mevent}{\menv}
      \\[2pt]
      \denotetconfulle{\stseq{\motcon_0}{\motcon_1}}{\menv} &=
      \denotetconfulle{\motcon_0}{\menv} \semseq
      \denotetconfulle{\motcon_1}{\menv}
      \\
      \denotetconfulle{\stmany{\motcon{}}}{\menv} &=
      \setbuild{\mtrace^i}{i \le \omega, \mtrace \in
        \denotetconfulle{\motcon}{\menv}}
      \\
     \denotetconfulle{\stbind{\mevent}{\motcon}}{\menv} &=
     \setbuild{\mdata \mtrace}{\mdata,\menv' \in \denoteevent{\mevent}{\menv}, \mtrace \in \denotetconfulle{\motcon}{\menv'}}
     \\
      \denotetconfulle{\mevent}{\menv} &= \setbuild{\mdata}{\mdata,\menv' \in \denoteevent{\mevent}{\menv}}
      \\[2pt]
      \denoteevent{\mevent}{\menv} &= \setbuild{\mdata,\menv'}{\menv'_\must = \matches(\mevent, \mdata, \menv)}
      \\
      \semneg{\Pi} &= \setbuild{\mtrace}{\forall \mtrace' \in
        \Pi\setminus\setof{\epsilon}. \mtrace' \nleq \mtrace}
      \\
      \Pi \semseq \Pi' &= \setbuild{\mtrace \cdot \mtrace'}{\mtrace
        \in \Pi, \mtrace' \in \Pi'}
    \end{align*}}{\caption{Denotational Semantics of Temporal Contracts ($B$ means both $P$ and $F$)}\label{fig:tcontract-denotation}}
  {\begin{align*}
      \derivee{\mdata}{\epsilon}{\menv} &= \bot
      \\
      \derivee{\mdata}{\mevent}{\menv} &= \left\{
        \begin{array}{ll}
          \epsilon & \text{if } \menv'_\must = \matches(\mevent, \mdata, \menv) \\
          \bot & \text{otherwise}
        \end{array}\right.
      \\
      \derivee{\mdata}{\stbind{\mevent}{\motcon}}{\menv} &=
      \left\{\begin{array}{ll}
          \motcon,\menv' & \text{if } \menv'_\must = \matches(\mevent, \mdata, \menv) \\
          \bot & \text{otherwise}
        \end{array}\right.
      \\
      \derivee{\mdata}{\stseq{\motcon_0}{\motcon_1}}{\menv} &=
      \stOr{\setof{\derivee{\mdata}{\motcon_0}{\menv},\
          \stseq{\nullable(\motcon_0)}{\derivee{\mdata}{\motcon_1}{\menv}}}}
      \\
      \derivee{\mdata}{\stOr{\isset{\motcon}}}{\menv} &=
      \stOr{\derivee{\mdata}{\motcon}{\menv}\ldots}
      \\
      \derivee{\mdata}{\stAnd{\isset{\motcon}}}{\menv} &=
      \stAnd{\derivee{\mdata}{\motcon}{\menv}\ldots}
      \\
      \derivee{\mdata}{\stmany{\motcon{}}}{\menv} &=
      \stseq{\derivee{\mdata}{\motcon}{\menv}}{\stmany{\motcon{}}}
      \\
      \derivee{\mdata}{\stnot{\motcon}}{\menv} &=
      \nullable(\derivee{\mdata}{\motcon}{\menv}) \to \bot,
      \stnot{\derivee{\mdata}{\motcon}{\menv}}
      \\[2pt]
      \nullable(\epsilon) &= \nullable(\stmany{\motcon{}}) =
      \nullable(\stnot{\motcon}) = \epsilon
      \\
      \nullable(\stbind{\mevent}{\motcon}) &= \nullable(\mevent) = \bot
      \\
      \nullable(\stOr{\isset{\motcon}}) &=
      \bigvee{\nullable(\motcon)\ldots}
      \\
      \nullable(\stAnd{\isset{\motcon}}) &=
      \bigwedge{\nullable(\motcon)\ldots}
      \\
      \nullable(\stseq{\motcon_0}{\motcon_1}) &=
      \nullable(\motcon_0)\wedge \nullable(\motcon_1)
      \\
      \nullable(\motcon,\menv) &= \nullable(\motcon)
    \end{align*}}{\caption{Derivatives of Temporal Contracts}\label{fig:tcon-deriv}}

The semantics and derivatives here are simplified to the concrete case, for space.
%
The extension to support the approximate matching semantics uses the appropriate logical connectives across $\cup$, $\cap$ and $\neg$ to compute the overall valuation of the temporal contract following a derivation.
%
Multiple possible matches lead to multiple possible derivations, and the temporal contract connectives are lifted over these sets of derivatives.
%
Thus, derivatation produces a set of possible derivations and a valuation indicating how sure we are to \emph{not} blame.
%%

%%
We say $\mexp$ satisfies a temporal contract $\mtcon$ if its event trace filtered by the timeline to which the contract is attached is in the denotation of the temporal contract ($\denotetcon{\mtcon}$).
%
Since monitors are generated during reduction, the proof is mostly technical that our monitoring system ensures an expression either satisfies its contract or blames, and hinges mainly on the correctness of derivatives:
%

\begin{theorem}[Full]\label{thm:full}
 $\denotetconfull{\derivee{\mdata}{\motcon}{\menv}} = \setbuild{\mtrace}{\mdata\mtrace \in \denotetconfulle{\motcon}{\menv}}$
\end{theorem}

\begin{theorem}[Partial]\label{thm:partial}
 $\denotetcon{\derivee{\mdata}{\motcon}{\menv}} = \setbuild{\mtrace}{\mdata\mtrace \in \denotetcone{\motcon}{\menv}}$
\end{theorem}

\begin{theorem}[Top level full]\label{thm:top-full}
 $\denotetconfull{\derive{\mdata}{\mtcon}} = \setbuild{\mtrace}{\mdata\mtrace \in \denotetconfull{\mtcon}}$
\end{theorem}

\begin{theorem}[Top level partial]\label{thm:top-partial}
 $\denotetcon{\derive{\mdata}{\mtcon}} = \setbuild{\mtrace}{\mdata\mtrace \in \denotetcon{\mtcon}}$
\end{theorem}

The latter three fall out of the first from simple inductions.
%
The first theorem depends on the following lemma, which follows from a simple induction.

\begin{lemma}[Nullability]\label{lem:nullability}
  $\nullable(\motcon) = \epsilon \iff \epsilon \in \denotetconfulle{\motcon}{\menv}$
\end{lemma}

\autoref{thm:full} has a straightforward proof except in the $\neg$ case, which requires some tricky reasoning.
%
\begin{byCases}
  \iftwocolumn{}
  {\fontsize{8pt}{9pt}\selectfont}
  \case{\motcon \equiv \stnot{\motcon{}'}}{
    \begin{byCases}
      \case{H : \nullable(\derivee{\mdata}{\motcon{}'}{\menv}) = \epsilon}{
        \begin{pfsteps*}
          \item{$\denotetconfull{\derivee{\mdata}{\motcon}{\menv}} = \emptyset$} \BY{computation}
          \item{$\epsilon \in \denotetconfull{\derivee{\mdata}{\motcon{}'}{\menv}}$}
            \BY{$H$, lemma \ref{lem:nullability}} \pflabel{deriveeps}
          \item{$\mdata \in \denotetconfulle{\motcon{}'}{\menv}$} \BY{IH, \pfref{deriveeps}}
        \end{pfsteps*}
        To show $\setbuild{\mtrace}{\mdata\mtrace \in \denotetconfulle{\motcon}{\menv}} = \emptyset$, we suppose $\mtrace \in \semneg{\denotetconfulle{\motcon{}'}{\menv}}$ and show $\mtrace \nequiv \mdata\mtrace'$:
        \begin{byCases}
          \case{\mtrace \equiv \mdata\mtrace'}{
            Since $\mdata \in \denotetconfulle{\motcon{}'}{\menv}$, by definition of $\neg$, contradiction.}
          \otherwise{$\mtrace$ not prefixed by $\mdata$}
        \end{byCases}}
      \case{H : \nullable(\derivee{\mdata}{\motcon{}'}{\menv}) = \bot}{
\newcommand{\lhs}{\semneg{\setbuild{\mtrace}{\mdata\mtrace \in \denotetconfulle{\motcon{}'}{\menv}}}}
\newcommand{\rhs}{\semneg{\denotetconfulle{\motcon{}'}{\menv}}}
        \begin{pfsteps*}
          \item{$\epsilon \notin \denotetconfull{\derivee{\mdata}{\motcon{}'}{\menv}}$}
             \BY{lemma \ref{lem:nullability}} \pflabel{derivenoeps}
          \item{$\setbuild{\mtrace}{\mdata\mtrace \in \denotetconfulle{\motcon{}'}{\menv}} = \denotetconfull{\derivee{\mdata}{\motcon{}'}{\menv}}$} \BY{IH} \pflabel{IH}
          \item{$\mdata \notin \denotetconfulle{\motcon{}'}{\menv}$} \BY{\pfref{derivenoeps}, \pfref{IH}}
          \item{Goal is $\lhs = \setbuild{\mtrace}{\mevent\mtrace \in \rhs}$} \BY{computation}
        \end{pfsteps*}
        We prove this goal by bi-containment:
        \begin{byCases}
          \case{\mathit{Hs} : \mtrace \in \lhs}{
            \begin{pfsteps*}
              \item{$\forall \mtrace' \in \setbuild{\mtrace}{\mevent\mtrace \in \denotetconfulle{\motcon{}'}{\menv}}\setminus\setof{\epsilon}. \mtrace' \nleq \mtrace$}
                  \BY{$\mathit{Hs}$ and inversion} \pflabel{Hinv}
               \item{Suppose $\mtrace' \in \denotetconfulle{\motcon{}'}{\menv}$} \pflabel{let}
               \item{$\mtrace' \nleq \mevent\mtrace$}
                 \BY{\pfref{Hinv}, \pfref{let}, prefix cancellation} \pflabel{concl}
               \item{$\mtrace \in \rhs$} \BY{\pfref{concl}}
            \end{pfsteps*}}
          \case{\mathit{Hs} : \mtrace \in \rhs}{
            \begin{pfsteps*}
              \item{$\forall \mtrace' \in \denotetconfulle{\motcon{}'}{\menv}\setminus\setof{\epsilon}. \mtrace' \nleq \mevent\mtrace$}
                \BY{$\mathit{Hs}$, inversion} \pflabel{Hsinv1}
              \item{Suppose $\mtrace' \in \setbuild{\mtrace}{\mevent\mtrace \in \denotetconfulle{\motcon{}'}{\menv}} \setminus\setof{\epsilon}$} \pflabel{let}
              \item{$\mevent\mtrace' \in \denotetconfulle{\motcon{}'}{\menv}$} \BY{\pfref{let}} \pflabel{in}
              \item{$\mtrace' \nleq \mtrace$} \BY{\pfref{Hsinv1}, \pfref{in}, prefix cancellation} \pflabel{concl}
              \item{$\mtrace \in \lhs$} \BY{\pfref{concl}}
            \end{pfsteps*}}
        \end{byCases}}
    \end{byCases}}
\end{byCases}
%z

An interesting corollary relating paths to repeated derivation:
\begin{corollary}
  $\mtrace \in \denotetcon{\mtcon} \iff \nullable(\derive{\mtrace}{\mtcon}) = \epsilon$
\end{corollary}
% %
% Depends on
% \begin{lemma}[Flat emptiness]
%   $\flatempty(\mtcon) \implies \denotetconfull{\mtcon} = \emptyset$
% \end{lemma}
% where $\flatempty$ and $\flatempty_\menv$ are defined as (where $[_\menv]$ denotes the definition applies to both)
% \begin{align*}
%   \flatempty[_\menv](T) &= \bot \quad\text{if } T\equiv\epsilon,\, T\equiv(\stmany{\mtcon}),\,\text{or }T\equiv\stnot{\mtcon} \\
%   \flatempty[_\menv](\stbind{\mevent}{\mtcon}) &= \flatempty[_\menv](\mevent) \\
%   \flatempty[_\menv](\stOr{\isset{\mtcon}}) &= \bigwedge \flatempty[_\menv](\mtcon)\ldots \\
%   \flatempty[_\menv](\stAnd{\isset{\mtcon}}) &= \bigvee \flatempty[_\menv](\mtcon)\ldots \\
%   \flatempty[_\menv](\stseq{\mtcon_0}{\mtcon_1}) &= \flatempty[_\menv](\mtcon_0) \vee \flatempty[_\menv](\mtcon_1) \\
%   \flatempty(\mtcon,\menv) &= \flatempty_\menv(\mtcon) \\[2pt]
%   \flatempty[_\menv](\snone) &= \top \\
%   \flatempty_\menv(\mvar) &= (\menv(\mvar) \overset{?}{=} \emptyset) \\
%   \flatempty[_\menv](\snegpat{\mvpat}) &= \top \quad\text{if } \mvpat\equiv\sany,\, \mvpat\equiv\sbind{\mvar}, \text{ or } \mvpat\equiv\snegpat{\mvpat'} \text{ and } \flatempty[_\menv](\mvpat') \\
%   \flatempty[_\menv](\mvpat) &= \bot \quad\text{otherwise}
% \end{align*}
% %
% Our implementation reduces temporal contracts at construction time, so that the following invariant holds of represented contracts:
% \begin{equation*}
%  \flatempty(\mtcon) \iff \mtcon = \bot
% \end{equation*}
