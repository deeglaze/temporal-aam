
We present and analyze a slightly different formulation than \dfm's temporal contracts that allows for more precise specification of value-use.
%
But first, we must discuss why we do not import \dfm's semantics directly.
%
\subsection{\dfm's semantics}

\dfm{} give a denotational semantics to their temporal contracts looks almost identical to a textbook definition of the denotation of regular expressions, with the key difference being the inclusion of binding forms.
%
The details of the full definition are unimportant, and look similar to our denotation of full traces ($\denotetconfull{\_}$, next subsection), but with two crucial differences.
%
The first is their denotation of negation:
\newcommand{\denotedfm}[2]{\denote{#1}_{#2}}
\begin{equation*}
  \denotedfm{\stnot{\motcon}}{E} = \mathit{Trace} \setminus \denotedfm{\motcon}{E}
\end{equation*}

They use a module semantics based on an $\mathit{EF}$ machine that tracks the bindings shared across module boundaries, $E$, and a stack of module boundaries to return to, $F$.
%
Regardless of how this machine works, the denotation of a temporal contract attached to a structural contract, $\denote{\mscon\ {\tt where}\ \motcon}$, is generated by traces of $\mathit{EF}$ that are driven by sent or received calls and return actions (roughly):
\begin{align*}
 \left\{
   \begin{array}{l}
    {\tt ret}(\mathit{start},h)\mtrace \in \prefixes(\denotedfm{\motcon}{E}) :
 \\ \qquad\langle E_0, \mathit{start}\rangle \Rightarrow^\mtrace \langle E, F\rangle \wedge E_0 = \epsilon, h : S
\end{array}\right\}
\end{align*}

The use of $\prefixes$ in this definition is problematic, and negation is the culprit.
%
Contracts that state anything about how a trace may not end would allow just such traces since \emph{extensions} to such ``bad traces'' are acceptable, and prefix closure will throw the ``bad traces'' back into what is acceptable.
%
%Additionally, if one writes a contract more carefully to reject extensions of bad traces, there isn't an obvious operational interpretation that allows early failure.
%
For example, the denotation of temporal contracts from \dfm{} allows $\mevent\mevent \in \prefixes(\denote{\stnot{\mevent}})$, and because of prefix closure, $\mevent \in \prefixes(\denote{\stnot{\mevent}})$.
%%

%%
The second difference is in the semantics for referring to functions; we give a different account that captures the spirit of their prose describing their system, and more closely reflects their implementation.
%
The temporal component of the example discussed in \autoref{sec:sort} was originally the following:
\begin{align*}
 &\stnot{(\sddd~ {\tt call}(\sortid,\_,\_)~ \stmany{\snonevent{{\tt ret}(\sortid,\_)}}~ {\tt call}(\sortid,\_,\_))}
 \\ \cap& \stnot{(\sddd~ {\tt ret}(\sortid,\_,\_) \sddd~ {\tt call}(\mathit{cmp},\_,\_))}
\end{align*}

In contrast to our restatement, the flat use of \emph{labels} instead of \emph{bindings} would cause a second call to a supposedly-correct $\sortid$ to fail, since it internally calls the comparator of the same label, but of a different monitor construction.
%
Their implementation works around this by additionally adding a monitor-wrapping action, that generates a new label to pair with the function label to uniquely identify it.
%%

\subsection{Our semantics}
%
We change three aspects of \dfm's semantics:
\begin{enumerate}
  \item{temporal contracts' denotational semantics is split into both \emph{full trace} and \emph{partial trace} interpretations, with a non-standard interpretation of negation;}
  \item{matching includes \emph{uncertainty}, to allow for sound approximations;}
  \item{we use \emph{temporal monitors as modules} to interpret module interactions.}
\end{enumerate}
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Discuss denotations
%%
%
Our semantics (\autoref{fig:tcontract-denotation}) alternates between full traces ($\denotetconfull{\_}$) and partial traces ($\denotetcon{\_}$) to combat the problems introduced by \dfm's original use of $\prefixes$ on top of a semantics of full traces.
%
Our interpretation of negation disallows any future observation to redeem a trace: a negated temporal contract will reject all non-empty full traces of the given contract, as well as any extension of such traces\footnote{This semantics of negation does not satisfy double-negation elimination (DNE).}.
%
We claim that this semantics is what \dfm{} intended their system to mean, as it matches up with the expectations of their prose, the test cases in their implementation\footnote{The functional test cases, in particular, since our model does not handle Racket's object system.}, and additionally raises blame on programs that \dfm{} were surprised their implementation accepted --- in particular, a program that produces the faulty trace discussed in \autoref{sec:sort}.
%
Since our semantics catches more ``bad'' behavior than their monitoring system, we have not simply formalized their implementation.
%%

\begin{theorem}[Prefix closure]\label{thm:prefix-closed}
  $\prefixes(\denotetcone{\motcon}{\menv}) = \denotetcone{\motcon}{\menv}$
\end{theorem}

%\FloatBarrier
\newcommand*{\nomatch}{{\tt \#f}}
\newcommand*{\tconsemfigs}[4]{
 \iftwocolumn{\begin{figure}#1 #2\end{figure}
              \begin{figure}#3 #4\end{figure}}
             {\begin{figure}
              \begin{minipage}[b]{.55\linewidth}#1 #2\hrule height 0pt\end{minipage}
              \begin{minipage}[b]{.40\linewidth}#3 #4\hrule height 0pt\end{minipage}
             \end{figure}}}
\tconsemfigs{
    \begin{align*}
      \denotetconbothe{\stOr{\isset{\motcon}}}{\menv} &=
      \bigcup\denotetconbothe{\motcon}{\menv}\ldots
      \\
      \denotetconbothe{\stAnd{\isset{\motcon}}}{\menv} &=
      \bigcap\denotetconbothe{\motcon}{\menv}\ldots
      \\
      \denotetconbothe{\epsilon}{\menv} &= \setof{\epsilon}
      \\
      \denotetconbothe{\stnot{\motcon}}{\menv} &=
      \semneg{\denotetconfulle{\motcon}{\menv}}
      \\[2pt]
      \denotetcone{\stmany{\motcon{}}}{\menv} &=
      \denotetconfulle{\stmany{\motcon{}}}{\menv} \mathrel{\cdot}
      \denotetcone{\motcon}{\menv}
      \\
      \denotetcone{\stseq{\motcon_0}{\motcon_1}}{\menv} &=
      \denotetcone{\motcon_0}{\menv} \cup
      \denotetconfulle{\motcon_0}{\menv}\mathrel{\cdot}
      \denotetcone{\motcon_1}{\menv}
      \\
     \denotetcone{\stbind{\mevent}{\motcon}}{\menv} &=
      \setof{\epsilon}\cup
        \{ \mdata \mtrace : \mdata,\menv' \in \denoteevent{\mevent}{\menv},
        \\&\phantom{= \setof{\epsilon}\cup \{ \mdata\mtrace : } \mtrace \in \denotetcone{\motcon}{\menv'} \}
     \\
      \denotetcone{\mevent}{\menv} &= \setof{\epsilon}\cup\denotetconfulle{\mevent}{\menv}
      \\[2pt]
      \denotetconfulle{\stseq{\motcon_0}{\motcon_1}}{\menv} &=
      \denotetconfulle{\motcon_0}{\menv} \mathrel{\cdot}
      \denotetconfulle{\motcon_1}{\menv}
      \\
      \denotetconfulle{\stmany{\motcon{}}}{\menv} &= \denotetconfulle{\motcon}{\menv}^*
      \\
     \denotetconfulle{\stbind{\mevent}{\motcon}}{\menv} &=
     \setbuild{\mdata \mtrace}{\mdata,\menv' \in \denoteevent{\mevent}{\menv}, \mtrace \in \denotetconfulle{\motcon}{\menv'}}
     \\
      \denotetconfulle{\mevent}{\menv} &= \setbuild{\mdata}{\mdata,\menv' \in \denoteevent{\mevent}{\menv}}
      \\[2pt]
      \denoteevent{\mevent}{\menv} &= \setbuild{\mdata,\menv'}{\setof{\menv'_\must} = \matches(\mevent, \mdata, \menv)}
      \\
      \semneg{\Pi} &= \setof{\epsilon}\cup\setbuild{\mtrace}{\forall \mtrace' \in
        \Pi\setminus\setof{\epsilon}. \mtrace' \nleq \mtrace}
    \end{align*}}{\caption{Denotational Semantics of Temporal Contracts ($B$ means both $P$ and $F$)}\label{fig:tcontract-denotation}}
  {\begin{align*}
      \derivee{\mdata}{\epsilon}{\menv} &= \bot
      \\
      \derivee{\mdata}{\mevent}{\menv} &= \left\{
        \begin{array}{ll}
          \epsilon & \text{if } \setof{\menv_\must} = \matches(\mevent, \mdata, \menv) \\
          \bot & \setof{\nomatch} = \matches(\mevent, \mdata, \menv)
        \end{array}\right.
      \\
      \derivee{\mdata}{\stbind{\mevent}{\motcon}}{\menv} &=
      \left\{\begin{array}{ll}
          \motcon,\menv' & \text{if } \setof{\menv'_\must} = \matches(\mevent, \mdata, \menv) \\
          \bot & \setof{\nomatch} = \matches(\mevent, \mdata, \menv)
        \end{array}\right.
      \\
      \derivee{\mdata}{\stseq{\motcon_0}{\motcon_1}}{\menv} &=
      \stOr{\setof{\stseq{\derivee{\mdata}{\motcon_0}{\menv}}{(\motcon_1,\menv)},\
          \stseq{\nullable(\motcon_0)}{\derivee{\mdata}{\motcon_1}{\menv}}}}
      \\
      \derivee{\mdata}{\stOr{\isset{\motcon}}}{\menv} &=
      \stOr{\derivee{\mdata}{\motcon}{\menv}\ldots}
      \\
      \derivee{\mdata}{\stAnd{\isset{\motcon}}}{\menv} &=
      \stAnd{\derivee{\mdata}{\motcon}{\menv}\ldots}
      \\
      \derivee{\mdata}{\stmany{\motcon{}}}{\menv} &=
      \stseq{\derivee{\mdata}{\motcon}{\menv}}{(\stmany{\motcon{}},\menv)}
      \\
      \derivee{\mdata}{\stnot{\motcon}}{\menv} &=
      \nullable(\derivee{\mdata}{\motcon}{\menv}) \to \bot,
      \stnot{\derivee{\mdata}{\motcon}{\menv}}
      \\[2pt]
      \nullable(\epsilon) &= \nullable(\stmany{\motcon{}}) =
      \nullable(\stnot{\motcon}) = \epsilon
      \\
      \nullable(\stbind{\mevent}{\motcon}) &= \nullable(\mevent) = \bot
      \\
      \nullable(\stOr{\isset{\motcon}}) &=
      \bigvee{\nullable(\motcon)\ldots}
      \\
      \nullable(\stAnd{\isset{\motcon}}) &=
      \bigwedge{\nullable(\motcon)\ldots}
      \\
      \nullable(\stseq{\motcon_0}{\motcon_1}) &=
      \nullable(\motcon_0)\wedge \nullable(\motcon_1)
      \\
      \nullable(\motcon,\menv) &= \nullable(\motcon)
    \end{align*}}{\caption{Derivatives of Temporal Contracts}\label{fig:tcon-deriv}}

The semantics and derivatives here are simplified to the concrete case for clarity.
%
We discuss the cases where $\matches$ returns uncertain results in \autoref{sec:abstract-semantics}.
%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Discuss matching
%%
Matching allows binding arbitrary values from the language for later comparison, so the space of temporal contract derivatives is unbounded.
%
After abstraction the value space becomes finite, but comparison for (concrete) equality is not decidable, so we define our matching semantics (\autoref{fig:matchsem}) with a notion of uncertainty in the form of a weak equality (allows the answer of \may).
%
We go into more detail about how to handle uncertainty in \autoref{sec:abstract-semantics}, so for this section the reader may assume $\simeq$ never returns \may, and that the semantics of matching is standard.

%We made the design choice that call actions for bound variables ($\scallev{\mvar}{\mvpat}$) will only be sent to the temporal monitor if the value bound to $\mvar$ is itself contracted on the monitor's timeline.
%
%The reason for this is that control should flow back to the timeline considered in order for an action to affect that timeline.
%
%It is easy enough to amend the structural contracts to reflect the fact that a binding is considered a function in the temporal contract.

\newcommand*{\matchsemfigs}[4]{
 \iftwocolumn{\begin{figure} #1 #2 \end{figure}
              \begin{figure} #3 #4 \end{figure}}
             {\begin{figure}
              \begin{minipage}[b]{.50\linewidth}#1 #2\hrule height 0pt\end{minipage}
              \begin{minipage}[b]{.45\linewidth}#3 #4\hrule height 0pt\end{minipage}
             \end{figure}}}
\matchsemfigs{
\setlength{\abovedisplayskip}{0pt}
\setlength{\belowdisplayskip}{4pt}
\setlength{\abovedisplayshortskip}{0pt}
\setlength{\belowdisplayshortskip}{8pt}
  \begin{align*}
    \matches &: \Pattern \times \Qualified \times \Env \to \wp(\MatchResult) \\
  \end{align*}
    \begin{align*}
      \mvaluation \in \Valuation &::= \may \alt \must \alt \bot \\
      \mpat \in \Pattern &::= \VPat \text{ rules plus } \alt \mconstructor(\many{\mpat}) \\
      \mathit{mr} \in \MatchResult &::= \menv_\mvaluation \alt \nomatch \\
      S \subset \MatchResult \\
      \text{Let } \menv_\bot &= \nomatch \\
      \mdata \in \Qualified &= \isset{\mdata} \alt \mval \alt \mconstructor(\many{\mdata}) \\
      \mconstructor \in \Constructors &= \setof{{\tt call}, {\tt ret}, {\tt cons}}
    \\[2pt]
    S \bowtie S' &= \setbuild{\combinef{\mathit{mr}}{\mathit{mr}'}}{\mathit{mr} \in S, \mathit{mr}' \in S'} \\
    \combinef{\menv_\mvaluation}{\menv'_{\mvaluation'}} &= (\lambda x. ({\tt if}\ x \in \dom(\menv')\\
                                                  &\phantom{= (\lambda x. {\tt if}}
                                                   \menv'(x) \\
                                                  &\phantom{= (\lambda x. {\tt if}}
                                                   \menv(x)))_{\mvaluation \wedge \mvaluation'} \\
    \wedge,\vee & \text{ glb, lub of } \bot < \may < \must
    \end{align*}}
  {\caption{Spaces and functions for matching}\label{fig:matchspace}}
  {\begin{align*}
    \matches(\sany, \_, \menv) &= \setof{\menv_\must} \\
    \matches(\snone, \_, \menv) &= \setof{\nomatch} \\
    \matches(\mtoplevelname, \snlam{\mtoplevelname}{\mvar}{\mexp}, \menv) &= \setof{\menv_\must} \\
    \matches(\snegpat{\mvpat}, \mdata, \menv) &= \mathit{case}\ \matches(\mvpat, \mdata, \menv)\\
      &\alt \setof{\nomatch} \Rightarrow \setof{\menv_\must} \\
      &\alt \setof{\menv'_\must\ldots} \Rightarrow \setof{\nomatch} \\
      &\alt \_ \Rightarrow \setof{\menv_\may} \\
    \matches(\sbind{\mvar}, \mdata, \menv) &= \setof{\menv[\mvar \mapsto \mdata]_\must} \\
    \matches(\mvar, \mdata, \menv) &= \matches(\menv(\mvar), \mdata, \menv) \\
    \matches(\mconstructor(\many{\mpat}), \mconstructor(\many{\mdata}), \menv) &= (\Bowtie S \ldots) \\
    \text{where }& S \ldots = \matches(\mvpat, \mdata, \menv) \ldots \\
    \matches(\mpat, \isset{\mdata}, \menv) &= \bigcup \matches(\mpat,\mdata,\menv)\ldots \\
    \matches(\mdata, \mdata', \menv) &= \setof{\menv_{\mdata \simeq \mdata'}} \\
    \matches(\mpat, \mdata, \menv) &= \setof{\nomatch} \quad
    \text{otherwise}
  \end{align*}}{\caption{Semantics of matching}\label{fig:matchsem}}

Matching against sets of values makes it possible that we have several possible matches.
%
Thus $\matches$ returns a set of environments possible from matching a given pattern against some data, and if failure is possible (\nomatch).
%
The interesting case is for constructed data, where we must combine results for each tree element.
%
We simply left-associate $\bowtie$ over results to get a cross-product of the different match combinations.
%
The $\triangleleft$ operator extends the left environment with the bindings of the right, though the order doesn't matter considering that binding patterns may not bind the same variable twice.
%
%%

%%
The denotational semantics is not executable, so the correctness of derivatives with respect to the denotational semantics is crucial to the correctness of our monitoring system.
%
We must show the correctness of both the full and partial interpretations of both open and closed temporal contracts, though all have similar proofs.
%
We say $\mexp$ satisfies a temporal contract $\mtcon$ its trace of actions sent to the temporal monitor is in the denotation of the temporal contract ($\denotetcon{\mtcon}$).
%
Since monitors are generated during reduction, the proof is mostly technical that our monitoring system ensures an expression either satisfies its contract or blames, but its hinges mainly on the correctness of derivatives:
%

\begin{theorem}[Derivatives correct]\label{thm:deriv}
 \begin{enumerate}
  \item{$\denotetconfull{\derivee{\mdata}{\motcon}{\menv}} =
    \setbuild{\mtrace}{\mdata\mtrace \in
      \denotetconfulle{\motcon}{\menv}}$}
  \item{$\denotetcon{\derivee{\mdata}{\motcon}{\menv}} = \setbuild{\mtrace}{\mdata\mtrace \in \denotetcone{\motcon}{\menv}}$}
  \item{$\denotetconfull{\derive{\mdata}{\mtcon}} = \setbuild{\mtrace}{\mdata\mtrace \in \denotetconfull{\mtcon}}$}
  \item{$\denotetcon{\derive{\mdata}{\mtcon}} = \setbuild{\mtrace}{\mdata\mtrace \in \denotetcon{\mtcon}}$}
 \end{enumerate}
\end{theorem}
The key lemma is the correctness of our nullability function, which follows from a simple induction.

\begin{lemma}[Nullability]\label{lem:nullability}
  $\nullable(\motcon) = \epsilon \iff \epsilon \in \denotetconfulle{\motcon}{\menv}$
\end{lemma}

Thus assuming \autoref{lem:nullability}, each case of \autoref{thm:deriv} has a straightforward proof except in the $\neg$ case, shown below (for the first proposition):
%
\begin{byCases}
  \iftwocolumn{}
  {\fontsize{8pt}{9pt}\selectfont}
  \case{\motcon \equiv \stnot{\motcon{}'}}{
    \begin{byCases}
      \case{H : \nullable(\derivee{\mdata}{\motcon{}'}{\menv}) = \epsilon}{
        \begin{pfsteps*}
          \item{$\denotetconfull{\derivee{\mdata}{\motcon}{\menv}} = \emptyset$} \BY{computation}
          \item{$\epsilon \in \denotetconfull{\derivee{\mdata}{\motcon{}'}{\menv}}$}
            \BY{$H$, lemma \ref{lem:nullability}} \pflabel{deriveeps}
          \item{$\mdata \in \denotetconfulle{\motcon{}'}{\menv}$} \BY{IH, \pfref{deriveeps}}
        \end{pfsteps*}
        To show $\setbuild{\mtrace}{\mdata\mtrace \in \denotetconfulle{\motcon}{\menv}} = \emptyset$, we suppose $\mtrace \in \semneg{\denotetconfulle{\motcon{}'}{\menv}}$ and show $\mtrace \nequiv \mdata\mtrace'$:
        \begin{byCases}
          \case{\mtrace \equiv \mdata\mtrace'}{
            Since $\mdata \in \denotetconfulle{\motcon{}'}{\menv}$, by definition of $\neg$, contradiction.}
          \otherwise{$\mtrace$ not prefixed by $\mdata$}
        \end{byCases}}
      \case{H : \nullable(\derivee{\mdata}{\motcon{}'}{\menv}) = \bot}{
\newcommand{\lhs}{\semneg{\setbuild{\mtrace}{\mdata\mtrace \in \denotetconfulle{\motcon{}'}{\menv}}}}
\newcommand{\rhs}{\semneg{\denotetconfulle{\motcon{}'}{\menv}}}
        \begin{pfsteps*}
          \item{$\epsilon \notin \denotetconfull{\derivee{\mdata}{\motcon{}'}{\menv}}$}
             \BY{lemma \ref{lem:nullability}} \pflabel{derivenoeps}
          \item{$\setbuild{\mtrace}{\mdata\mtrace \in \denotetconfulle{\motcon{}'}{\menv}} = \denotetconfull{\derivee{\mdata}{\motcon{}'}{\menv}}$} \BY{IH} \pflabel{IH}
          \item{$\mdata \notin \denotetconfulle{\motcon{}'}{\menv}$} \BY{\pfref{derivenoeps}, \pfref{IH}}
          \item{Goal is $\lhs = \setbuild{\mtrace}{\mevent\mtrace \in \rhs}$} \BY{computation}
        \end{pfsteps*}
        We prove this goal by bi-containment:
        \begin{byCases}
          \case{\mathit{Hs} : \mtrace \in \lhs}{
            \begin{pfsteps*}
              \item{$\forall \mtrace' \in \setbuild{\mtrace}{\mevent\mtrace \in \denotetconfulle{\motcon{}'}{\menv}}\setminus\setof{\epsilon}. \mtrace' \nleq \mtrace$}
                  \BY{$\mathit{Hs}$ and inversion} \pflabel{Hinv}
               \item{Suppose $\mtrace' \in \denotetconfulle{\motcon{}'}{\menv}$} \pflabel{let}
               \item{$\mtrace' \nleq \mevent\mtrace$}
                 \BY{\pfref{Hinv}, \pfref{let}, prefix cancellation} \pflabel{concl}
               \item{$\mtrace \in \rhs$} \BY{\pfref{concl}}
            \end{pfsteps*}}
          \case{\mathit{Hs} : \mtrace \in \rhs}{
            \begin{pfsteps*}
              \item{$\forall \mtrace' \in \denotetconfulle{\motcon{}'}{\menv}\setminus\setof{\epsilon}. \mtrace' \nleq \mevent\mtrace$}
                \BY{$\mathit{Hs}$, inversion} \pflabel{Hsinv1}
              \item{Suppose $\mtrace' \in \setbuild{\mtrace}{\mevent\mtrace \in \denotetconfulle{\motcon{}'}{\menv}} \setminus\setof{\epsilon}$} \pflabel{let}
              \item{$\mevent\mtrace' \in \denotetconfulle{\motcon{}'}{\menv}$} \BY{\pfref{let}} \pflabel{in}
              \item{$\mtrace' \nleq \mtrace$} \BY{\pfref{Hsinv1}, \pfref{in}, prefix cancellation} \pflabel{concl}
              \item{$\mtrace \in \lhs$} \BY{\pfref{concl}}
            \end{pfsteps*}}
        \end{byCases}}
    \end{byCases}}
\end{byCases}
%z

\iflong{
An interesting corollary relating paths to repeated derivation:
\begin{corollary}
  $\mtrace \in \denotetcon{\mtcon} \iff \nullable(\derive{\mtrace}{\mtcon}) = \epsilon$
\end{corollary}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Discuss temporal monitors as modules
%%
Actions should only be visible to a temporal contract monitor if the action affects that monitor.
%
This is not an issue in \dfm's semantics, since they consider only one module at a time.
%
For each {\tt tmon} redex, our semantics creates a fresh runtime monitor for the contract; we store the state of these monitors in a global environment $\mTMons$, where the freshness comes from a space of timelines.
%
We call these different keys ``timelines'' since time is relative to each module.
%
We use timelines to distinguish where different function contracts will send their actions to be checked.
%
Thus, as functions cross module boundaries, they also shift timelines: the more boundaries a function crosses, the more timelines will be aware of the calls made to it (due to nested wrappings).
%
The specifics of timelines are discussed in \autoref{sec:technical}.
%%

% %
% Depends on
% \begin{lemma}[Flat emptiness]
%   $\flatempty(\mtcon) \implies \denotetconfull{\mtcon} = \emptyset$
% \end{lemma}
% where $\flatempty$ and $\flatempty_\menv$ are defined as (where $[_\menv]$ denotes the definition applies to both)
% \begin{align*}
%   \flatempty[_\menv](T) &= \bot \quad\text{if } T\equiv\epsilon,\, T\equiv(\stmany{\mtcon}),\,\text{or }T\equiv\stnot{\mtcon} \\
%   \flatempty[_\menv](\stbind{\mevent}{\mtcon}) &= \flatempty[_\menv](\mevent) \\
%   \flatempty[_\menv](\stOr{\isset{\mtcon}}) &= \bigwedge \flatempty[_\menv](\mtcon)\ldots \\
%   \flatempty[_\menv](\stAnd{\isset{\mtcon}}) &= \bigvee \flatempty[_\menv](\mtcon)\ldots \\
%   \flatempty[_\menv](\stseq{\mtcon_0}{\mtcon_1}) &= \flatempty[_\menv](\mtcon_0) \vee \flatempty[_\menv](\mtcon_1) \\
%   \flatempty(\mtcon,\menv) &= \flatempty_\menv(\mtcon) \\[2pt]
%   \flatempty[_\menv](\snone) &= \top \\
%   \flatempty_\menv(\mvar) &= (\menv(\mvar) \overset{?}{=} \emptyset) \\
%   \flatempty[_\menv](\snegpat{\mvpat}) &= \top \quad\text{if } \mvpat\equiv\sany,\, \mvpat\equiv\sbind{\mvar}, \text{ or } \mvpat\equiv\snegpat{\mvpat'} \text{ and } \flatempty[_\menv](\mvpat') \\
%   \flatempty[_\menv](\mvpat) &= \bot \quad\text{otherwise}
% \end{align*}
% %
% Our implementation reduces temporal contracts at construction time, so that the following invariant holds of represented contracts:
% \begin{equation*}
%  \flatempty(\mtcon) \iff \mtcon = \bot
% \end{equation*}
