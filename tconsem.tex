%
As noted in \autoref{sec:sort}, temporal contracts are associated with structural contracts that label function components within them.
%
For simple exposition, we will consider tuples as the main organizational tool for contracting the interactions between multiple functions.
%
Since we consider monitor constructions as a more basic notion of equality, we also see each temporal monitor construction as starting its own \emph{timeline}, which sees its own filtered view of events in the system.
%
Thus, as values flow through contract boundaries, they are considered on different timelines.
%
\dfm formalized their semantics in terms of a nondeterministic machine that defined its interactions on all event streams, and thus their machine was on a single timeline.
%
The semantics of temporal contracts that we propose uses pointer-equality of monitors for comparisons of non-primitive data.
%
Our semantics makes interaction between temporal contract monitors explicit, allowing us to verify whole programs.
%%

%%
A denotational semantics for temporal contracts is difficult to get right, since their behavior is implicitly prefix-closed.
%
Liveness-looking properties have a hidden, insidious behavior with negation: contracts that state anything about how a trace may not end would allow just such traces since extensions to such ``bad traces'' are acceptable, and prefix closure will throw the ``bad traces'' back into what is acceptable.
%
For example, $\mevent\mevent \in \prefixes(\denote{\stnot{\mevent}}_{\menv})$, and because of prefix closure, $\mevent \in \prefixes(\denote{\stnot{\mevent}}_{\menv})$!
%
Temporal contract satisfaction should not be contingent on future observations; an effective monitor should blame \emph{as soon as} a contract is not satisfied.
%
We thus have a different semantics for temporal contracts that ping-pongs between \emph{full traces} and \emph{partial traces}; a negated temporal contract will reject all full traces of the given contract, as well as any extension of such traces.
%
This semantics of negation does not satisfy double-negation elimination (DNE), but we find that to be an acceptable trade-off; we do not need DNE in order to implement or verify temporal contracts.
%
We claim that this semantics is what \dfm intended their system to mean, as it matches up with the expectations of their prose and the test cases in their implementation.
%
Furthermore, our implementation catches more ``bad'' behavior than their monitoring system, meaning we have not simply formalized their implementation; rather, we have formalized a more complete system and implemented it.
%%

%%
The denotational semantics in \autoref{fig:tcontract-denotation} lends itself nicely to online monitoring via a derivative parsing approach.
%
For each event $\mevent$ we come across on a timeline $\mtimeline$, we set $\mTMons(\mtimeline)$ to $\derive{\mevent}{\mTMons(\mtimeline)}$, as long as the derivative isn't failing.
%
We can show that the partial trace semantics is prefix-closed (\autoref{thm:prefix-closed}), and thus we can pinpoint the cause of an error as soon as it is sent to the monitor --- a necessary condition for effective blame management in this realm.
%%

%%
We made the design choice to require a function contract monitor wrapping for named values to consider their calls or returns as events.
%
The reason for this is that control should flow back to the timeline considered in order for an event to affect that timeline.
%
It is easy enough to amend the structural contracts to reflect the fact that a binding is considered a function in the temporal contract.

\begin{theorem}[Prefix closure]\label{thm:prefix-closed}
  $\prefixes(\denotetcone{\mtcon}{\menv}) = \denotetcone{\mtcon}{\menv}$
\end{theorem}

%\FloatBarrier
\begin{figure}
 \begin{align*}
   \denotetcone{\stOr{\mtcon \ldots}}{\menv} &= \bigcup\denotetcone{\mtcon}{\menv}\ldots
\\
    \denotetcone{\stAnd{\mtcon \ldots}}{\menv} &= \bigcap\denotetcone{\mtcon}{\menv}\ldots
\\
    \denotetcone{\stmany{\mtcon}}{\menv} &= \denotetconfulle{\stmany{\mtcon}}{\menv} \semseq \denotetcone{\mtcon}{\menv}
\\
    \denotetcone{\stnot{\mtcon}}{\menv} &= \semneg{\denotetconfulle{\mtcon}{\menv}}
\\
    \denotetcone{\stseq{\mtcon_0}{\mtcon_1}}{\menv} &= \denotetcone{\mtcon_0}{\menv} \cup \denotetconfulle{\mtcon_0}{\menv}\semseq \denotetcone{\mtcon_1}{\menv}
\\
    \denotetcone{\stbind{\mevent}{\mtcon}}{\menv} &= \setof{\epsilon} \cup \setbuild{\mevent' \mtrace}{\menv' = \matches(\mevent, \mevent', \menv), \mtrace \in \denotetcone{\mtcon}{\menv'}}
\\
    \denotetcone{\epsilon}{\menv} &= \setof{\epsilon}
\\
    \denotetcone{\mevent}{\menv} &= \setof{\epsilon} \cup \denotetconfulle{\mevent}{\menv}
\\[2pt]
    \denotetconfulle{\mtcon,\menv}{\menv} &= \denotetconfulle{\mtcon}{\menv}
\\
    \denotetconfulle{\stOr{\mtcon \ldots}}{\menv} &= \bigcup\denotetconfulle{\mtcon}{\menv}\ldots
\\
    \denotetconfulle{\stAnd{\mtcon \ldots}}{\menv} &= \bigcap\denotetconfulle{\mtcon}{\menv}\ldots
\\
    \denotetconfulle{\stnot{\mtcon}}{\menv} &= \semneg{\denotetconfulle{\mtcon}{\menv}}
\\
    \denotetconfulle{\stseq{\mtcon_0}{\mtcon_1}}{\menv} &= \denotetconfulle{\mtcon_0}{\menv} \semseq \denotetconfulle{\mtcon_1}{\menv}
\\
    \denotetconfulle{\stmany{\mtcon}}{\menv} &= \setbuild{\mtrace^i}{i \le \omega, \mtrace \in \denotetconfulle{\mtcon}{\menv}}
\\
    \denotetconfulle{\stbind{\mevent}{\mtcon}}{\menv} &= \setbuild{\mevent' \mtrace}{\menv' = \matches(\mevent, \mevent', \menv), \mtrace \in \denotetconfulle{\mtcon}{\menv'}}
\\
    \denotetconfulle{\epsilon}{\menv} &= \setof{\epsilon}
\\
    \denotetconfulle{\mevent}{\menv} &= \setbuild{\mevent'}{\menv' = \matches(\mevent, \mevent', \menv)}
\\[2pt]
    \semneg{\Pi} &= \setbuild{\mtrace}{\forall \mtrace' \in \Pi\setminus\setof{\epsilon}. \mtrace' \nleq \mtrace}
\\
    \Pi \semseq \Pi' &= \setbuild{\mtrace \cdot \mtrace'}{\mtrace \in \Pi, \mtrace' \in \Pi'}
 \end{align*}
  \caption{Denotational Semantics of Temporal Contracts}
  \label{fig:tcontract-denotation}
\end{figure}

\begin{figure}
  \begin{align*}
    \derivee{\mevent}{\epsilon}{\menv} &= \bot
\\
    \derivee{\mevent}{\mevent'}{\menv} &= \left\{
      \begin{array}{ll}
        \epsilon & \text{if } \menv' = \matches(\mevent', \mevent, \menv) \\
        \bot & \text{otherwise}
      \end{array}\right.
\\
    \derivee{\mevent}{\stbind{\mevent'}{\mtcon}}{\menv} &=
    \left\{\begin{array}{ll}
      \mtcon,\menv' & \text{if } \menv' = \matches(\mevent', \mevent, \menv) \\
      \bot & \text{otherwise}
    \end{array}\right.
\\
    \derivee{\mevent}{\stseq{\mtcon_0}{\mtcon_1}}{\menv} &= \stOr{\setof{\derivee{\mevent}{\mtcon_0}{\menv},\ \stseq{\nullable(\mtcon_0)}{\derivee{\mevent}{\mtcon_1}{\menv}}}}
\\
    \derivee{\mevent}{\stOr{\mtcon\ldots}}{\menv} &= \stOr{\derivee{\mevent}{\mtcon}{\menv}\ldots}
\\
    \derivee{\mevent}{\stAnd{\mtcon\ldots}}{\menv} &= \stAnd{\derivee{\mevent}{\mtcon}{\menv}\ldots}
\\
    \derivee{\mevent}{\stmany{\mtcon}}{\menv} &= \stseq{\derivee{\mevent}{\mtcon}{\menv}}{\stmany{\mtcon}}
\\
    \derivee{\mevent}{\stnot{\mtcon}}{\menv} &= \nullable(\derivee{\mevent}{\mtcon}{\menv}) \to \bot, \stnot{\derivee{\mevent}{\mtcon}{\menv}}
\\[2pt]
    \nullable(\epsilon) &= \nullable(\stmany{\mtcon}) = \nullable(\stnot{\mtcon}) = \epsilon
\\
    \nullable(\stbind{\mevent}{\mtcon}) &= \nullable(\mevent) = \bot
\\
    \nullable(\stOr{\mtcon\ldots}) &= \bigvee{\nullable(\mtcon)\ldots}
\\
    \nullable(\stAnd{\mtcon\ldots}) &= \bigwedge{\nullable(\mtcon)\ldots}
\\
    \nullable(\stseq{\mtcon_0}{\mtcon_1}) &= \nullable(\mtcon_0)\wedge \nullable(\mtcon_1)
\\
    \nullable(\mtcon,\menv) &= \nullable(\mtcon)
  \end{align*}
  \caption{Derivatives of Temporal Contracts}
  \label{fig:tcon-deriv}
\end{figure}

%
We say $\mexp$ satisfies a temporal contract $\mtcon$ if its event trace filtered by the timeline to which the contract is attached ($\denote{\mexp}_\mtimeline$) is in the denotation of the temporal contract ($\denotetcon{\mtcon}$).
%

\begin{theorem}[Full]
 $\denotetconfull{\derivee{\mevent}{\mtcon}{\menv}} = \setbuild{\mtrace}{\mevent\mtrace \in \denotetconfulle{\mtcon}{\menv}}$
\end{theorem}

\begin{theorem}[Partial]
 $\denotetcon{\derivee{\mevent}{\mtcon}{\menv}} = \setbuild{\mtrace}{\mevent\mtrace \in \denotetcone{\mtcon}{\menv}}$
\end{theorem}

\begin{theorem}[Top level full]
 $\denotetconfull{\derive{\mevent}{\mtcon}} = \setbuild{\mtrace}{\mevent\mtrace \in \denotetconfull{\mtcon}}$
\end{theorem}

\begin{theorem}[Top level partial]
 $\denotetcon{\derive{\mevent}{\mtcon}} = \setbuild{\mtrace}{\mevent\mtrace \in \denotetcon{\mtcon}}$
\end{theorem}

The latter three fall out of the first from simple inductions.
%
The first theorem depends on the following lemma

\begin{lemma}[Nullability]\label{lem:nullability}
  $\nullable(\mtcon) = \epsilon \iff \epsilon \in \denotetconfulle{\mtcon}{\menv}$
\end{lemma}
and has a straightforward proof except in the $\neg$ case, which requires some tricky reasoning.
%
\begin{byCases}
  \iftwopage{}
  {\fontsize{8pt}{9pt}\selectfont}
  \case{\mtcon \equiv \stnot{\mtcon'}}{
    \begin{byCases}
      \case{H : \nullable(\derivee{\mevent}{\mtcon'}{\menv}) = \epsilon}{
        \begin{pfsteps*}
          \item{$\denotetconfull{\derivee{\mevent}{\mtcon}{\menv}} = \emptyset$} \BY{computation}
          \item{$\epsilon \in \denotetconfull{\derivee{\mevent}{\mtcon'}{\menv}}$}
            \BY{$H$, lemma \ref{lem:nullability}} \pflabel{deriveeps}
          \item{$\mevent \in \denotetconfulle{\mtcon'}{\menv}$} \BY{IH, \pfref{deriveeps}}
        \end{pfsteps*}
        To show $\setbuild{\mtrace}{\mevent\mtrace \in \denotetconfulle{\mtcon}{\menv}} = \emptyset$, we suppose $\mtrace \in \semneg{\denotetconfulle{\mtcon'}{\menv}}$ and show $\mtrace \nequiv \mevent\mtrace'$:
        \begin{byCases}
          \case{\mtrace \equiv \mevent\mtrace'}{
            Since $\mevent \in \denotetconfulle{\mtcon'}{\menv}$, by definition of $\neg$, contradiction.}
          \otherwise{$\mtrace$ not prefixed by $\mevent$}
        \end{byCases}}
      \case{H : \nullable(\derivee{\mevent}{\mtcon'}{\menv}) = \bot}{
\newcommand{\lhs}{\semneg{\setbuild{\mtrace}{\mevent\mtrace \in \denotetconfulle{\mtcon'}{\menv}}}}
\newcommand{\rhs}{\semneg{\denotetconfulle{\mtcon'}{\menv}}}
        \begin{pfsteps*}
          \item{$\epsilon \notin \denotetconfull{\derivee{\mevent}{\mtcon'}{\menv}}$}
             \BY{lemma \ref{lem:nullability}} \pflabel{derivenoeps}
          \item{$\setbuild{\mtrace}{\mevent\mtrace \in \denotetconfulle{\mtcon'}{\menv}} = \denotetconfull{\derivee{\mevent}{\mtcon'}{\menv}}$} \BY{IH} \pflabel{IH}
          \item{$\mevent \notin \denotetconfulle{\mtcon'}{\menv}$} \BY{\pfref{derivenoeps}, \pfref{IH}}
          \item{Goal is $\lhs = \setbuild{\mtrace}{\mevent\mtrace \in \rhs}$} \BY{computation}
        \end{pfsteps*}
        We prove this goal by bi-containment:
        \begin{byCases}
          \case{\mathit{Hs} : \mtrace \in \lhs}{
            \begin{pfsteps*}
              \item{$\forall \mtrace' \in \setbuild{\mtrace}{\mevent\mtrace \in \denotetconfulle{\mtcon'}{\menv}}\setminus\setof{\epsilon}. \mtrace' \nleq \mtrace$}
                  \BY{$\mathit{Hs}$ and inversion} \pflabel{Hinv}
               \item{Suppose $\mtrace' \in \denotetconfulle{\mtcon'}{\menv}$} \pflabel{let}
               \item{$\mtrace' \nleq \mevent\mtrace$}
                 \BY{\pfref{Hinv}, \pfref{let}, prefix cancellation} \pflabel{concl}
               \item{$\mtrace \in \rhs$} \BY{\pfref{concl}}
            \end{pfsteps*}}
          \case{\mathit{Hs} : \mtrace \in \rhs}{
            \begin{pfsteps*}
              \item{$\forall \mtrace' \in \denotetconfulle{\mtcon'}{\menv}\setminus\setof{\epsilon}. \mtrace' \nleq \mevent\mtrace$}
                \BY{$\mathit{Hs}$, inversion} \pflabel{Hsinv1}
              \item{Suppose $\mtrace' \in \setbuild{\mtrace}{\mevent\mtrace \in \denotetconfulle{\mtcon'}{\menv}} \setminus\setof{\epsilon}$} \pflabel{let}
              \item{$\mevent\mtrace' \in \denotetconfulle{\mtcon'}{\menv}$} \BY{\pfref{let}} \pflabel{in}
              \item{$\mtrace' \nleq \mtrace$} \BY{\pfref{Hsinv1}, \pfref{in}, prefix cancellation} \pflabel{concl}
              \item{$\mtrace \in \lhs$} \BY{\pfref{concl}}
            \end{pfsteps*}}
        \end{byCases}}
    \end{byCases}}
\end{byCases}
%z

An additional property we need to have is that we can tell when a contract is empty, so that we can blame appropriately.
\begin{theorem}
  $\mtrace \in \denotetcon{\mtcon} \iff \neg\flatempty(\mtcon)$
\end{theorem}
%
Depends on
\begin{lemma}[Flat emptiness]
  $\flatempty(\mtcon) \implies \denotetconfull{\mtcon} = \emptyset$
\end{lemma}
Where $\flatempty$ is defined similarly to $\nullable$, but every base case is $\bot$, and the $\vee$ and $\wedge$ are swapped (thus $\top$ can only come from an empty $\cup$ --- the failing contract).
%
Our implementation reduces temporal contracts at construction time, so that the following invariant holds of represented contracts:
\begin{equation*}
 \flatempty(\mtcon) \iff \mtcon = \bot
\end{equation*}
