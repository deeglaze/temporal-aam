%
As noted in \autoref{sec:sort}, temporal contracts are associated with structural contracts that label function components within them.
%
For simple exposition, we will consider tuples as the main organizational tool for contracting the interactions between multiple functions.
%
Since we consider monitor constructions as a more basic notion of equality, we also see each temporal monitor construction as starting its own \emph{timeline}, which sees its own filtered view of events in the system.
%
Thus, as values flow through contract boundaries, they are considered on different timelines.
%
\dfm formalized their semantics in terms of a nondeterministic machine that defined its interactions on all event streams, and thus their machine was on a single timeline.
%
The semantics of temporal contracts that we propose uses pointer-equality of monitors for comparisons of non-primitive data.
%
Our semantics makes interaction between temporal contract monitors explicit, allowing us to verify whole programs.
%%

%%
A denotational semantics for temporal contracts is difficult to get right, since their behavior is implicitly prefix-closed.
%
Negation is the culprit: contracts that state anything about how a trace may not end would allow just such traces since extensions to such ``bad traces'' are acceptable, and prefix closure will throw the ``bad traces'' back into what is acceptable.
%
%Additionally, if one writes a contract more carefully to reject extensions of bad traces, there isn't an obvious operational interpretation that allows early failure.
%
For example, $\mevent\mevent \in \prefixes(\denote{\stnot{\mevent}}_{\menv})$, and because of prefix closure, $\mevent \in \prefixes(\denote{\stnot{\mevent}}_{\menv})$!
%
Temporal contract satisfaction should not---and indeed cannot---be contingent on future observations; an effective monitor should blame \emph{as soon as} a contract is not satisfied.
%
We thus have a different semantics for temporal contracts that ping-pongs between \emph{full traces} and \emph{partial traces}; a negated temporal contract will reject all full traces of the given contract, as well as any extension of such traces.
%
This semantics of negation does not satisfy double-negation elimination (DNE), but we find that to be an acceptable trade-off; we do not need DNE in order to implement or verify temporal contracts.
%
We claim that this semantics is what \dfm intended their system to mean, as it matches up with the expectations of their prose, the test cases in their implementation\footnote{The functional test cases, in particular, since our model does not handle Racket's object system.}, and additionally raises blame on programs that \dfm were surprised their implementation accepted.
%
Since our semantics catches more ``bad'' behavior than their monitoring system, we have not simply formalized their implementation.
%%

%%
The denotational semantics in \autoref{fig:tcontract-denotation} lends itself nicely to online monitoring via a derivative parsing approach.
%
For each event $\mevent$ we come across on a timeline $\mtimeline$, we set $\mTMons(\mtimeline)$ to $\derive{\mevent}{\mTMons(\mtimeline)}$, as long as the derivative isn't failing.
%
We can show that the partial trace semantics is prefix-closed (\autoref{thm:prefix-closed}), and thus we can pinpoint the cause of an error as soon as it is sent to the monitor --- a necessary condition for effective blame management in this realm.
%%

%%
We made the design choice that call events for bound variables ($\scallev{\mvar,\mvpat}$) will only be sent to the temporal monitor if the value bound to $\mvar$ is itself contracted on the monitor's timeline.
%
The reason for this is that control should flow back to the timeline considered in order for an event to affect that timeline.
%
It is easy enough to amend the structural contracts to reflect the fact that a binding is considered a function in the temporal contract.

\begin{theorem}[Prefix closure]\label{thm:prefix-closed}
  $\prefixes(\denotetcone{\mtcon}{\menv}) = \denotetcone{\mtcon}{\menv}$
\end{theorem}

%\FloatBarrier
\newcommand*{\matchsemfigs}[4]{
 \iftwocolumn{\begin{figure} #1 #2 \end{figure}
              \begin{figure} #3 #4 \end{figure}}
             {\begin{figure}
              \begin{minipage}[b]{.50\linewidth}#1 #2\hrule height 0pt\end{minipage}
              \begin{minipage}[b]{.45\linewidth}#3 #4\hrule height 0pt\end{minipage}
             \end{figure}}} 
\matchsemfigs{  
    \begin{align*}
      \mvaluation &::= \may \alt \must \alt \bot \\
      \menvs \subset \Env &::= \menv \ldots \\
      \MatchResult &::= \menvs_\mvaluation \\
      \menvs_\bot &= \emptyset_\bot \\
      \mdata \in \Qualified &= S \alt \mconstant \alt \mconstructor(\mdata \ldots) \\
      S \subset \Qualified &
      \\[2pt]
      \may \oplus \_ &= \_ \oplus \may = \may \\
      \bot \oplus \mvaluation &= \mvaluation
      \\[2pt]
      \must \wedge \must &= \must \\
      \bot \wedge \_ &= \_ \wedge \bot = \bot \\
      \may \wedge \_ &= \_ \wedge \may = \may
      \\[2pt]
      \neg \must &= \bot \\
      \neg \may &= \may \\
      \neg \bot &= \must
    \\[2pt]
    \menvs \bowtie \menvs' &= \setbuild{\combinef{\menv}{\menv'}}{\menv \in \menvs, \menv' \in \menvs'} \\
    \combinef{\menv}{\menv'} &= \lambda x. x \in \dom(\menv') \to \menv'(x), \menv(x)
    \end{align*}}
  {\caption{Spaces and functions for matching}\label{fig:matchspace}}
  {\begin{align*}
%    \matches &: \Pattern \times \Qualified \times \Env \to \MatchResult \\
    \matches(\sany, \_, \menv) &= \menv_\must \\
    \matches(\snone, \_, \menv) &= \emptyset_\bot \\
    \matches(\mtoplevelname,
    \bclos{\mtoplevelname}{\mscon_D}{k}{j}{\mtimeline}{\mscon_R}{\mmlab^{\prime}}{\maddr},
    \menv) &= \menv_\must \\
    \matches(\snegpat{\mvpat}, \mdata, \menv) &= \menv_{\neg \mvaluation} \\
    \text{where }& \matches(\mvpat, \mdata, \menv) = \menv'_\mvaluation \\
    \matches(\sbind{\mvar}, \mdata, \menv) &= \menv[\mvar \mapsto \mdata]_\must \\
    \matches(\mvar, \mdata, \menv) &= \menv_{\menv(\mvar) \simeq \mdata} \\
    \matches(\mpat\equiv\mconstructor(\mvpat, \ldots), S, \menv) &= \Delta\setbuild{\matches(\mpat, \mdata, \menv)}{\mdata \in S} \\
    \matches(\mconstructor(\mvpat, \ldots), \mconstructor(\mdata, \ldots), \menv) &= (\Bowtie \menvs \ldots)_{\bigwedge \mvaluation \ldots} \\
    \text{where }& \menvs_\mvaluation \ldots = \matches(\mvpat, \mdata, \menv) \ldots \\
    \matches(\mdata, \mdata', \menv) &= \menv_{\bigoplus\limits_{\mdata'' \in \mdata'}{{\mdata \simeq \mdata''}}} \\
    \matches(\mpat, \mdata, \menv) &= \emptyset_\bot \quad
    \text{otherwise}
    \\[2pt]
    \Delta S &= (\bigcup\limits_{\menvs_{\_} \in S}\menvs)_{\delta \setbuild{\mvaluation}{\menvs_\mvaluation \in S}} \\
    \delta \setof{\mvaluation} &= \mvaluation \\
    \delta S &= \may \quad \text{otherwise}
  \end{align*}}{\caption{Semantics of matching}\label{fig:matchsem}}

\newcommand*{\tconsemfigs}[4]{
 \iftwocolumn{\begin{figure}#1 #2\end{figure}
              \begin{figure}#3 #4\end{figure}}
             {\begin{figure}
              \begin{minipage}[b]{.55\linewidth}#1 #2\hrule height 0pt\end{minipage}
              \begin{minipage}[b]{.40\linewidth}#3 #4\hrule height 0pt\end{minipage}
             \end{figure}}}
\tconsemfigs{
    \begin{align*}
      \denotetconbothe{\stOr{\mtcon \ldots}}{\menv} &=
      \bigcup\denotetconbothe{\mtcon}{\menv}\ldots
      \\
      \denotetconbothe{\stAnd{\mtcon \ldots}}{\menv} &=
      \bigcap\denotetconbothe{\mtcon}{\menv}\ldots
      \\
      \denotetconbothe{\epsilon}{\menv} &= \setof{\epsilon}
      \\
      \denotetconbothe{\stnot{\mtcon}}{\menv} &=
      \semneg{\denotetconfulle{\mtcon}{\menv}}
      \\[2pt]
      \denotetcone{\stmany{\mtcon}}{\menv} &=
      \denotetconfulle{\stmany{\mtcon}}{\menv} \semseq
      \denotetcone{\mtcon}{\menv}
      \\
      \denotetcone{\stseq{\mtcon_0}{\mtcon_1}}{\menv} &=
      \denotetcone{\mtcon_0}{\menv} \cup
      \denotetconfulle{\mtcon_0}{\menv}\semseq
      \denotetcone{\mtcon_1}{\menv}
      \\
     \denotetcone{\stbind{\mevent}{\mtcon}}{\menv} &=
     \setof{\epsilon} \cup \{ \mevent' \mtrace :
       \menv' = \matches(\mevent, \mevent', \menv),
       \\&\phantom{= \setof{\epsilon} \cup \{ \mevent'\mtrace : \ }
         \mtrace \in \denotetcone{\mtcon}{\menv'} \}
     \\
      \denotetcone{\mevent}{\menv} &= \setof{\epsilon} \cup
      \denotetconfulle{\mevent}{\menv}
      \\[2pt]
      \denotetconfulle{\stseq{\mtcon_0}{\mtcon_1}}{\menv} &=
      \denotetconfulle{\mtcon_0}{\menv} \semseq
      \denotetconfulle{\mtcon_1}{\menv}
      \\
      \denotetconfulle{\stmany{\mtcon}}{\menv} &=
      \setbuild{\mtrace^i}{i \le \omega, \mtrace \in
        \denotetconfulle{\mtcon}{\menv}}
      \\
     \denotetconfulle{\stbind{\mevent}{\mtcon}}{\menv} &=
     \setbuild{\mevent' \mtrace}{\menv' = \matches(\mevent, \mevent',
       \menv), \mtrace \in \denotetconfulle{\mtcon}{\menv'}}
     \\
      \denotetconfulle{\mevent}{\menv} &= \setbuild{\mevent'}{\menv' =
        \matches(\mevent, \mevent', \menv)}
      \\[2pt]
      \semneg{\Pi} &= \setbuild{\mtrace}{\forall \mtrace' \in
        \Pi\setminus\setof{\epsilon}. \mtrace' \nleq \mtrace}
      \\
      \Pi \semseq \Pi' &= \setbuild{\mtrace \cdot \mtrace'}{\mtrace
        \in \Pi, \mtrace' \in \Pi'}
    \end{align*}}{\caption{Denotational Semantics of Temporal Contracts}\label{fig:tcontract-denotation}}
  {\begin{align*}
      \derivee{\mevent}{\epsilon}{\menv} &= \bot
      \\
      \derivee{\mevent}{\mevent'}{\menv} &= \left\{
        \begin{array}{ll}
          \epsilon & \text{if } \menv' = \matches(\mevent', \mevent, \menv) \\
          \bot & \text{otherwise}
        \end{array}\right.
      \\
      \derivee{\mevent}{\stbind{\mevent'}{\mtcon}}{\menv} &=
      \left\{\begin{array}{ll}
          \mtcon,\menv' & \text{if } \menv' = \matches(\mevent', \mevent, \menv) \\
          \bot & \text{otherwise}
        \end{array}\right.
      \\
      \derivee{\mevent}{\stseq{\mtcon_0}{\mtcon_1}}{\menv} &=
      \stOr{\setof{\derivee{\mevent}{\mtcon_0}{\menv},\
          \stseq{\nullable(\mtcon_0)}{\derivee{\mevent}{\mtcon_1}{\menv}}}}
      \\
      \derivee{\mevent}{\stOr{\mtcon\ldots}}{\menv} &=
      \stOr{\derivee{\mevent}{\mtcon}{\menv}\ldots}
      \\
      \derivee{\mevent}{\stAnd{\mtcon\ldots}}{\menv} &=
      \stAnd{\derivee{\mevent}{\mtcon}{\menv}\ldots}
      \\
      \derivee{\mevent}{\stmany{\mtcon}}{\menv} &=
      \stseq{\derivee{\mevent}{\mtcon}{\menv}}{\stmany{\mtcon}}
      \\
      \derivee{\mevent}{\stnot{\mtcon}}{\menv} &=
      \nullable(\derivee{\mevent}{\mtcon}{\menv}) \to \bot,
      \stnot{\derivee{\mevent}{\mtcon}{\menv}}
      \\[2pt]
      \nullable(\epsilon) &= \nullable(\stmany{\mtcon}) =
      \nullable(\stnot{\mtcon}) = \epsilon
      \\
      \nullable(\stbind{\mevent}{\mtcon}) &= \nullable(\mevent) = \bot
      \\
      \nullable(\stOr{\mtcon\ldots}) &=
      \bigvee{\nullable(\mtcon)\ldots}
      \\
      \nullable(\stAnd{\mtcon\ldots}) &=
      \bigwedge{\nullable(\mtcon)\ldots}
      \\
      \nullable(\stseq{\mtcon_0}{\mtcon_1}) &=
      \nullable(\mtcon_0)\wedge \nullable(\mtcon_1)
      \\
      \nullable(\mtcon,\menv) &= \nullable(\mtcon)
    \end{align*}}{\caption{Derivatives of Temporal Contracts}\label{fig:tcon-deriv}}

%
We say $\mexp$ satisfies a temporal contract $\mtcon$ if its event trace filtered by the timeline to which the contract is attached ($\denote{\mexp}_\mtimeline$) is in the denotation of the temporal contract ($\denotetcon{\mtcon}$).
%

\begin{theorem}[Full]
 $\denotetconfull{\derivee{\mevent}{\mtcon}{\menv}} = \setbuild{\mtrace}{\mevent\mtrace \in \denotetconfulle{\mtcon}{\menv}}$
\end{theorem}

\begin{theorem}[Partial]
 $\denotetcon{\derivee{\mevent}{\mtcon}{\menv}} = \setbuild{\mtrace}{\mevent\mtrace \in \denotetcone{\mtcon}{\menv}}$
\end{theorem}

\begin{theorem}[Top level full]
 $\denotetconfull{\derive{\mevent}{\mtcon}} = \setbuild{\mtrace}{\mevent\mtrace \in \denotetconfull{\mtcon}}$
\end{theorem}

\begin{theorem}[Top level partial]
 $\denotetcon{\derive{\mevent}{\mtcon}} = \setbuild{\mtrace}{\mevent\mtrace \in \denotetcon{\mtcon}}$
\end{theorem}

The latter three fall out of the first from simple inductions.
%
The first theorem depends on the following lemma

\begin{lemma}[Nullability]\label{lem:nullability}
  $\nullable(\mtcon) = \epsilon \iff \epsilon \in \denotetconfulle{\mtcon}{\menv}$
\end{lemma}
and has a straightforward proof except in the $\neg$ case, which requires some tricky reasoning.
%
\begin{byCases}
  \iftwocolumn{}
  {\fontsize{8pt}{9pt}\selectfont}
  \case{\mtcon \equiv \stnot{\mtcon'}}{
    \begin{byCases}
      \case{H : \nullable(\derivee{\mevent}{\mtcon'}{\menv}) = \epsilon}{
        \begin{pfsteps*}
          \item{$\denotetconfull{\derivee{\mevent}{\mtcon}{\menv}} = \emptyset$} \BY{computation}
          \item{$\epsilon \in \denotetconfull{\derivee{\mevent}{\mtcon'}{\menv}}$}
            \BY{$H$, lemma \ref{lem:nullability}} \pflabel{deriveeps}
          \item{$\mevent \in \denotetconfulle{\mtcon'}{\menv}$} \BY{IH, \pfref{deriveeps}}
        \end{pfsteps*}
        To show $\setbuild{\mtrace}{\mevent\mtrace \in \denotetconfulle{\mtcon}{\menv}} = \emptyset$, we suppose $\mtrace \in \semneg{\denotetconfulle{\mtcon'}{\menv}}$ and show $\mtrace \nequiv \mevent\mtrace'$:
        \begin{byCases}
          \case{\mtrace \equiv \mevent\mtrace'}{
            Since $\mevent \in \denotetconfulle{\mtcon'}{\menv}$, by definition of $\neg$, contradiction.}
          \otherwise{$\mtrace$ not prefixed by $\mevent$}
        \end{byCases}}
      \case{H : \nullable(\derivee{\mevent}{\mtcon'}{\menv}) = \bot}{
\newcommand{\lhs}{\semneg{\setbuild{\mtrace}{\mevent\mtrace \in \denotetconfulle{\mtcon'}{\menv}}}}
\newcommand{\rhs}{\semneg{\denotetconfulle{\mtcon'}{\menv}}}
        \begin{pfsteps*}
          \item{$\epsilon \notin \denotetconfull{\derivee{\mevent}{\mtcon'}{\menv}}$}
             \BY{lemma \ref{lem:nullability}} \pflabel{derivenoeps}
          \item{$\setbuild{\mtrace}{\mevent\mtrace \in \denotetconfulle{\mtcon'}{\menv}} = \denotetconfull{\derivee{\mevent}{\mtcon'}{\menv}}$} \BY{IH} \pflabel{IH}
          \item{$\mevent \notin \denotetconfulle{\mtcon'}{\menv}$} \BY{\pfref{derivenoeps}, \pfref{IH}}
          \item{Goal is $\lhs = \setbuild{\mtrace}{\mevent\mtrace \in \rhs}$} \BY{computation}
        \end{pfsteps*}
        We prove this goal by bi-containment:
        \begin{byCases}
          \case{\mathit{Hs} : \mtrace \in \lhs}{
            \begin{pfsteps*}
              \item{$\forall \mtrace' \in \setbuild{\mtrace}{\mevent\mtrace \in \denotetconfulle{\mtcon'}{\menv}}\setminus\setof{\epsilon}. \mtrace' \nleq \mtrace$}
                  \BY{$\mathit{Hs}$ and inversion} \pflabel{Hinv}
               \item{Suppose $\mtrace' \in \denotetconfulle{\mtcon'}{\menv}$} \pflabel{let}
               \item{$\mtrace' \nleq \mevent\mtrace$}
                 \BY{\pfref{Hinv}, \pfref{let}, prefix cancellation} \pflabel{concl}
               \item{$\mtrace \in \rhs$} \BY{\pfref{concl}}
            \end{pfsteps*}}
          \case{\mathit{Hs} : \mtrace \in \rhs}{
            \begin{pfsteps*}
              \item{$\forall \mtrace' \in \denotetconfulle{\mtcon'}{\menv}\setminus\setof{\epsilon}. \mtrace' \nleq \mevent\mtrace$}
                \BY{$\mathit{Hs}$, inversion} \pflabel{Hsinv1}
              \item{Suppose $\mtrace' \in \setbuild{\mtrace}{\mevent\mtrace \in \denotetconfulle{\mtcon'}{\menv}} \setminus\setof{\epsilon}$} \pflabel{let}
              \item{$\mevent\mtrace' \in \denotetconfulle{\mtcon'}{\menv}$} \BY{\pfref{let}} \pflabel{in}
              \item{$\mtrace' \nleq \mtrace$} \BY{\pfref{Hsinv1}, \pfref{in}, prefix cancellation} \pflabel{concl}
              \item{$\mtrace \in \lhs$} \BY{\pfref{concl}}
            \end{pfsteps*}}
        \end{byCases}}
    \end{byCases}}
\end{byCases}
%z

An additional property we need to have is that we can tell when a contract is empty, so that we can blame appropriately.
\begin{theorem}
  $\mtrace \in \denotetcon{\mtcon} \iff \neg\flatempty(\mtcon)$
\end{theorem}
%
Depends on
\begin{lemma}[Flat emptiness]
  $\flatempty(\mtcon) \implies \denotetconfull{\mtcon} = \emptyset$
\end{lemma}
Where $\flatempty$ is defined similarly to $\nullable$, but every base case is $\bot$, and the $\vee$ and $\wedge$ are swapped (thus $\top$ can only come from an empty $\cup$ --- the failing contract).
%
Our implementation reduces temporal contracts at construction time, so that the following invariant holds of represented contracts:
\begin{equation*}
 \flatempty(\mtcon) \iff \mtcon = \bot
\end{equation*}
