\begin{figure}
  \begin{align*}
    \mscon \in \SContract &::= \sflat{\mexp} \alt \sarr{\mtoplevelname}{\mscon}{\mscon} \alt \sconsc{\mscon}{\mscon}
\\
    \mexp \in \Expr &::= \sTMon{k}{l}{j}{\mscon}{\mtcon}{\mexp}
                    \alt \sSMon{k}{l}{j}{\mtimeline}{\mscon}{\mexp}
                    \alt \text{other forms}
\\
\mmlab,k,l,j \in \Label&\text{ an infinite set} \\
\mtimeline \in \Timeline &\text{ an infinite set}
  \end{align*}
  \caption{Syntax of structural contracts with labels}
  \label{fig:scontract-syntax}
\end{figure}

\begin{figure}
  \begin{align*}
  \motcon \in \TContract^\circ &::=
      \mevent \alt \snonevent{\mevent}
 \alt \epsilon
 \alt \stnot{\motcon}
 \alt \stseq{\motcon}{\motcon}
 \alt \stmany{\motcon{}} \\
&\alt \stOr{\isset{\motcon}}
 \alt \stAnd{\isset{\motcon}}
 \alt \stbind{\mevent}{\motcon}
\\
\mtcon \in \TContract &= \text{same rules as } \TContract^\circ \text{ for } \mtcon \text{ plus } \alt \motcon, \menv \\
\menv \in \Env &= \Var \to \wp(\Value) \\
\mevent \in \Event &::= \scevev{\mname}{\mvpat} \alt \sany \\
\mcev \in \FunctionEvent &::= {\tt call} \alt {\tt ret} \\
\mvpat \in \VPat &::= \mval \alt \sbind{\mvar} \alt \mname \alt \scons(\mvpat,\mvpat) \alt \snegpat{\mvpat} \alt \sany \alt \snone \\
\mvar \in \Var &\quad\text{an infinite set} \\
\mname \in \Name &::= \mvar \alt \mtoplevelname
  \end{align*}
  \caption{Syntax of temporal contracts}
  \label{fig:tcontract-syntax}
\end{figure}

Temporal contracts provide a declarative language for monitoring the temporal ordering of events that pass through module boundaries.
%
The syntax is presented in \autoref{fig:tcontract-syntax}.
%
%
We notate sets of some element type with metavariable $e$ as $\isset{e}$, and lists as $\many{e}$.
%
We write the interpolation of sets and lists into many arguments as $e\ldots$, following the rules of \citet{dvanhorn:Kohlbecker1987Macrobyexample}.
%
The if-then-else syntax we use follows Dijkstra ($\mathit{guard} \to \mathit{then}, \mathit{else}$), where anything non-$\bot$ is considered true.
%
We use $x\equiv S(y,\ldots)$ to mean ``$x$ matches $S(y,\ldots)$;'' alternatively, there exist elements $y\ldots$ such that $x = S(y,\ldots)$.
%
For brevity, we will use $\mname(\mvpat)$ and $\retof{\mname}(\mvpat)$ to mean $\scallev{\mname}{\mvpat}$ and $\sretev{\mname}{\mvpat}$ respectively.
%%

%%
Temporal contracts ($\mtcon$) include events ($\mevent$) (for $\mevent$ction), negated events ($\snonevent{\mevent}$), event matching scoped over a following contract ($\stbind{\mevent}{\mtcon}$), concatenation ($\stseq{\mtcon}{\mtcon}$) (often represented using juxtaposition), negated contracts ($\stnot{\mtcon}$), Kleene closure of events ($\stmany{\mtcon}$), union ($\stOr{\isset{\mtcon}}$), intersection ($\stAnd{\isset{\mtcon}}$), the empty temporal contract ($\epsilon$), and an open temporal contract closed by an environment ($\motcon, \menv$).
%
We consider the fail contract $\bot$ as a macro for $\stOr{\setof{}}$.
%
The difference between $\snonevent{\mevent}$ and $\stnot{\mtcon}$ is that the first must be an event and force time to step forward once, whereas the second may match arbitrarily many events.
%%

%%
Events themselves are expressed as patterns denoting calls ($\scallev{\mname}{\mvpat}$) or returns ($\sretev{\mname}{\mvpat}$), with respect to a particular function $\mname$ and with its argument or result matching a pattern $\mvpat$.
%
If $\mname$ is a label ($\mtoplevelname$), we simply check that the monitor wrapping the function has the same label (attached via the structural contract).
%
However, if $\mname$ is a variable ($\mvar$), then we consult a binding environment that the monitoring system builds as we pass binding events to determine if the function is exactly equal to the value bound.
%
Patterns can match values ($\mval$), variable bindings and references ($\sbind{\mvar}$, $\mvar$), labeled functions ($\mtoplevelname$), structured data ($\scons(\mvpat,\mvpat)$), negated patterns that do not bind ($\snegpat{\mvpat}$), anything or nothing ($\sany$, $\snone$).
%%
\newcommand{\sortid}{\mathit{sort}}
\subsection{\dfm's sort example, revised} \label{sec:sort}
%
\renewcommand*{\arraystretch}{1.2}
\newcommand*{\call}[1]{\scallev{#1}{\_}}
\newcommand*{\ret}[1]{\sretev{#1}{\_}}
\begin{align*}
 \sortid &: (\mathit{cmp} : \mathit{Pos} \to \mathit{Pos} \to \mathit{Bool})\ (List\ Pos) \to (List\ Pos) \\
 \text{where } &\stnot{(\stmany{\snonevent{\sortid(\_,\_)}} \sortid(\_,\_)~ \stmany{\snonevent{\retof{\sortid}(\_)}}~ \sortid(\_,\_))} \\
 \cap\  &(\stmany{\snonevent{\sortid(\_,\_)}}~ \sortid(?\mathit{cmp}, \_)~ \stmany{\snonevent{\retof{\sortid}(\_)}}~ \retof{\sortid}(\_)~ \stmany{\snonevent{\mathit{cmp}(\_,\_)}})
\end{align*}
%
%%
This example presents the contract for a hypothetical $\sortid$ function which takes two arguments: a comparator and a list (of positive numbers).
%
The temporal component, given by the ``where'' clauses following its structural (arrow) contract.
%
The first of these clauses states that a second call to $\sortid$ may not occur if there is no intervening return from $\sortid$, \ie, it is non-reentrant.
%
The second temporal clause specifies a higher-order property; given a call to $\sortid$, its associated $\mathit{cmp}$ argument cannot be called after $\sortid$ returns.
%
Since $\mathit{cmp}$ will be wrapped with its higher-order contract at each call, which creates new values, the bindings for $\mathit{cmp}$ will be distinct across execution.
%%
%
%%
%
%%
\iflong{
\subsection{File example} \label{sec:file}
%
\begin{align*}
 &FileSystemContract\, =\, open\, :\, String\, \to\, FileContract \\
 &FileContract =~ Record \\
 &\begin{array}{ @{\quad~}l@{\ :} @{~}l@{\ \to\ } l }
  read & Unit & String \\
  write & String & Unit \\
  close & Unit & Unit
 \end{array} \\
 &\text{where}\quad \sddd~ \ret{close}
 %\caption{File example}
 %\label{fig:file}
\end{align*}
%
%%
This example gives the contract for a hypothetical file system, which can be used to open files by giving the $open$ function a filename (a $String$); the client is then given a file handle contracted by $FileContract$.
%
A file handle, in turn, is a record of functions which interact with the file: $read$, $write$, and $close$, all which perform the expected behaviors.
%%
%
%%
The temporal contract is what is interesting: it is not phrased in terms of a negation, but rather an affirmation.
%
Its goal is to state that a user of the file is forbidden from making use of the file handle (through the use of its component functions) after the user has $close$d the file.
%
It is phrased such that there is no ``$\sddd$'' at the end of its trace; this means that the last reference one can make to such a monitored record is returning from $close$; after that, it cannot be used.
%
%TODO: Do we need to define prefix-closure?
Note that this is not a \emph{liveness property}; this does not mean that a return from $close$ \emph{must} happen, as traces are \emph{prefix-closed}.
%
Instead, the property is a \emph{safety property}, though expressed in the affirmative.
%%
%
%%
\subsection{TCP example} \label{sec:tcp}
%
\newcommand*{\tcpc}{\mathit{TCPConnection}}
\newcommand*{\tcpcc}{\mathit{TCPConnectionContract}}
\newcommand*{\tcpsock}{\mathit{TCPSocket}}
\newcommand*{\tcpsendc}{\mathit{TCPSendContract}}
\newcommand*{\tcprecvc}{\mathit{TCPRecvContract}}
\newcommand*{\tcpdata}{\mathit{TCPData}}
\newcommand*{\tcpstyle}[1]{\texttt{#1}}
%\FloatBarrier
\begin{figure}
 \newcommand*{\send}[1]{\scallev{send}{#1}}
 \newcommand*{\rcv}[1]{\sretev{recv}{#1}}
 \newcommand*{\notclose}{\snonevent{\call{close}}}
 \newcommand*{\tcpsyn}{\tcpstyle{SYN}}
 \newcommand*{\tcpack}{\tcpstyle{ACK}}
 \newcommand*{\tcpsynack}{\tcpstyle{SYN\&ACK}}
 \newcommand*{\tcpfin}{\tcpstyle{FIN}}
 %\newcommand*{\tcpfinack}{\tcpstyle{FIN\&ACK}}
 $\tcpcc\, =~ Record$ \\
 $\begin{array}{ @{\quad~}l@{\ :} @{~}l @{\ \to\ }l }
  open & \tcpsock & \tcpsendc \\
  listen & \tcpsock & \tcprecvc
 \end{array}$ \\
 $\tcpdata =$
 $~ \tcpsyn \mid \tcpack \mid \tcpsynack \mid \tcpfin \mid \tcpstyle{Data}(\_)$
%
 $\tcpc =~ Record$ \\
 $\begin{array}{ @{\quad~}l@{\ :} @{~}l@{\ \to\ } l }
  send & \tcpdata & Unit \\
  recv & Unit & \tcpdata \\
  timeout & Duration & Unit \\
  close & Unit & Unit
 \end{array}$ \\
%
 $\tcpsendc =~ \tcpc$ \\
 $\begin{array}{ @{~}r@{\quad} l @{}l }
  \text{where}
  &&\send{\tcpsyn}~ \notclose \\
  &&\rcv{\tcpsynack}~ \notclose \\
  &&\send{\tcpack}~ \stmany{\notclose} \\
%
  &&\cup
  \begin{aligned}
   &\left(
    \begin{aligned}
     &\rcv{\tcpfin}~ \send{\tcpack} \\
     &\send{\tcpfin}~ \rcv{\tcpack}
    \end{aligned}
   \right) \\
   &\left(
    \begin{aligned}
     &\call{close}~ \send{\tcpfin} \\
     &\rcv{\tcpack}~ \rcv{\tcpfin}~ \send{\tcpack}
    \end{aligned}
   \right)
  \end{aligned} \\
  &&\ret{timeout}~ \ret{close}
 \end{array}$
%
 $\tcprecvc =~ \tcpc$ \\
 $\begin{array}{ @{~}r@{\quad} l @{}l @{}l }
  \text{where}
  &&\rcv{\tcpsyn}~ \notclose \\
  &&\send{\tcpsynack}~ \notclose \\
  &&\rcv{\tcpack}~ \stmany{\notclose} \\
%
  &&\cup
  \begin{aligned}
   &\left(
    \begin{aligned}
     &\call{close}~ \send{\tcpfin} \\
     &\rcv{\tcpack}~ \rcv{\tcpfin}~ \send{\tcpack}
    \end{aligned}
   \right) \\
   &\left(
    \begin{aligned}
     &\rcv{\tcpfin}~ \send{\tcpack} \\
     &\call{close}~ \send{\tcpfin}~ \rcv{\tcpack}
    \end{aligned}
   \right)
  \end{aligned} \\
  &&\ret{timeout}~ \ret{close}
 \end{array}$
%
 \caption{TCP example}
 \label{fig:tcp}
\end{figure}
%
% TODO: Source this from WP
\begin{figure}
 \centering
 \fontsize{4}{5} \selectfont
 \def \svgwidth{\columnwidth}
 \input{tcp-fsm.pdf_tex}
 \caption{Simplified TCP FSM for \autoref{fig:tcp}}
 \label{fig:tcp-fsm}
\end{figure}
%
%%
In \autoref{fig:tcp} we show the contract for a hypothetical TCP connection module.
%
A client of this module may $open$ a $\tcpsock$ for initiating a connection or may $listen$ to a $\tcpsock$ for passively connecting.
%
A $\tcpc$ is defined similarly to our file system example; it is a record of functions which interact with the connection: $send$, $recv$, $timeout$, and $close$.
%
Notably, $send$ and $recv$ interact with data of the form $\tcpdata$, which can be one of the special packets used in the TCP protocol or can simply be some amount of user data ($\tcpstyle{Data}(\_)$).
%
%TODO: maybe express timing out in a better manner?
The $timeout$ function is unimportant to our discussion; it is used internally by the module to set timeouts for interactions with the other end of the TCP connection; clients do not directly use it and it is included solely for the ability to reason over timeouts in the temporal contract.
%%
%
%%
A socket on the ``sending'' end of the TCP connection (having used $open$) is obliged to use the connection according to the temporal component of $\tcpsendc$.
%
Likewise, a socket on the ``receiving'' end of the TCP connection (having used $listen$) is constrained by $\tcprecvc$.
%
The contracts are very involved, but they implement a simplified version of the TCP connection lifecycle given in \autoref{fig:tcp-fsm}.
%
Note that the temporal clause in each contract is phrased in the affirmative, as in \autoref{sec:file}; however, unlike that example, this property is indeed a (restricted) kind of \emph{liveness property}.
%
It states that the client uses the socket in a manner consistent with the TCP protocol and can expect the other end to likewise adhere.
%
The key difference between this property and a traditional liveness property is that it speaks of a liveness property with respect to \emph{a particular contract-monitoring} of a $\tcpc$; prefix-closure is still present at the top level (cf. \autoref{fig:tcontract-denotation}) and thus the protocol noted in the temporal contract may not occur if no $\tcpc$ is used.
%%
}