\section{Introduction}

Software systems are typically large, consist of many modules, and have invariants that are typically inexpressible or too costly to express (and prove) in the language's static type system, if it has one.
%
When this is the case, one might hope to rely on software contracts~\cite{dvanhorn:Findler2002Contracts} to give dynamic guarantees about the behavior of one's system, blaming the correct party responsible for any violation of these invariants.
%
A proposed system of \emph{temporal contracts}~\citep{ianjohnson:dfm:icfp2011} provide a linguistic mechanism to describe temporal properties that usually are checked extra-linguistically via model-checking an abstraction of the program.
%
Example temporal properties are, ``a file can only be closed if it has been opened'' and, ``if function A is given a function B, then B may not be called once A returns.''
%
Such invariants are important for interfaces that have set-up and tear-down protocols to follow.
%%

%%
There are downsides to software contracts, however.
%
If a contract is violated, a blame exception is thrown or the program simply terminates with the error.
%
Contracts do not ensure correctness --- they help the process of constructing correct programs.
%
In addition, contracts can introduce considerable overhead to the program.
%
Just wrapping a function in a contract monitor can disable compiler optimizations, and depending on the level of checking a contract does, the entry and exit of contract boundaries can also take a long time (indeed, we run arbitary programs as such checks!).
%
These are important costs to pay at the beginning of development, but as programs mature, we need a way to safely remove contract checking and have a performance and correctness return on the initial investment.
%%

%%
Temporal contracts pose an additional challenge over higher-order function contracts to statically verify, as they monitor extended interactions with a module, and not just localized pieces.
%
We propose a framework that is composable with techniques to verify functional contracts, that has low technical overhead (no translation to a model-checker's language necessary).
%
The technique uses the Abstracting Abstract Machines (AAM) approach~\citet{dvanhorn:VanHorn2010Abstracting} to check for reachability of a temporal contract blame.
%
The language for temporal contracts closely mimics linear temporal logic (LTL), but distinguishes itself in a way that makes LTL model-checking prohibitive on top of the initial cost of constructing a model to feed an LTL model-checker.
%
Temporal contracts can talk about value flow and use over time via binding in the specification --- this is not something that LTL can locally express.
%
The semantics of temporal contracts also is geared towards checking safety properties, since dynamic liveness checking is undecidable.
%
AAM was originally targeted towards describing flow analyses, but is robust enough to apply to model-checking safety properties of higher-order programs.
%
It is well-known that control-flow analysis can be stated in terms of model-checking, but this observation is misleading; one must use quadratically many model-checking queries to discover what a monovariant flow analysis can discover in one run.
%
The realm of temporal contract verification is similar: to use a model-checker, we would have to run a data-flow analysis up front in order to collect values that might be used as bindings, enumerate all possible binding/reference insantiations of the temporal contract, and then translate those contracts into LTL queries --- much more work than just running the program abstractly and reporting reachable blame states.
%

%%
Our contributions in this paper are as follows:
\begin{itemize}
 \item{an extension to \citeauthor{ianjohnson:dfm:icfp2011}'s temporal contract semantics;}
 \item{a new automaton model that we use to implement the monitor for this new semantics; and}
 \item{a sound abstraction to computably verify temporal contract satisfaction}
\end{itemize}
%%

%%
\section{Related Work}
%%

%%
Model-checking and contract verification (proving functional correctness) are huge fields and it is important to view our work in the greater context of these worlds of research.
%
The main separating factor between this work and related work is that all model-checking literature so far has treated the specification of temporal properties as \emph{extra-linguistic}, meaning there is no mechanism in the object language that could monitor for the properties.
%
Contracts are defined by their behavior of witnessing program execution, and thus do not have the same guarantees that a static type system has, such as, ``this function \emph{always} returns an integer when given an integer.''
%
In that vein, temporal contracts can never guarantee liveness properties of a program.
%
\citet{ianjohnson:dthf:complete} show that contracts that simulate types will never violate the guarantee that well-typed programs will never be blamed in a gradually-typed system.
%
Likewise, if we interpret temporal contracts in a stricter fashion --- sequenced events \emph{must} happen --- then in the abstract we can verify liveness properties.
%%

%%
\paragraph{First-order model-checking:}
The SLAM project~\citep{ianjohnson:Ball:2002:SLP:503272.503274} for model-checking C assumes that all function pointers of the same type alias.
%
For C programs that use callbacks heavily, this overapproximation leads to longer checking times due to more (spurious) paths to follow, and the imprecision inherent in any program approximation gets exacerbated by the additional pressure on abstract resources.

\paragraph{Higher-order model-checking:}
Java and C++ both have several high-quality model-checking tools \citep{ianjohnson:bandera, ianjohnson:java-pathfinder, ianjohnson:LLBMC}, some of which are bounded model-checkers, meaning they cannot fully verify temporal properties - only present counter-examples (that may not be true counter-examples).
%
Bandera~\citep{ianjohnson:bandera} is a sophisticated tool-chain that uses several static analysis techniques to extract a finite model from a Java program to feed to various back-end model-checkers.
%
Similar to our approach, Bandera employs control-flow analysis in order to produce compact models, but unsimilarly, the checking mechanisms are not in the control-flow analysis itself.
%%

%%
A technique that specifically targets higher-order languages, higher-order recursion schemes (HORS)~\citep{ianjohnson:Knapik:2002:HPT:646794.704852}, assumes a call-by-name semantics for the language it checks.
%
The current techniques for the initial abstraction of a program to HORS is not generally applicable to untyped or impure languages, since it creates the recursion schemes from the simple types of a given program.
%
HORS can be applied for call-by-value order if the program is first transformed into CPS, since then the intended evaluation order is encoded into call-by-name.
%
This still does not address the need for simple types, and does not apply for languages that cannot be expressed in CPS.

\paragraph{Static contract verification:}
In the world of statically verifying software contracts, there is much more work.
%
There have been many successful efforts in the realm of first-order contract verification~\citep{ianjohnson:fahndrich:contracts:2011,ianjohnson:vcc:2009}, but the techniques employed are inherently first-order: the only values are booleans.
%
\citet{ianjohnson:Flanagan:2006:HTC:1111037.1111059}'s notion of hybrid type checking is one way to state the problem: dynamic types are essentially flat contracts, and are treated as subtypes of anything during static checking.
%
If an external theorem prover can prove that the flat contracts always hold, the dynamic checks can be safely removed.
%
\citet{dvanhorn:Xu2012Hybrid} describe a higher-order contract verification system for OCaml by inlining all contract monitors and relying on a system of simplifications further enhanced by an SMT solver to optimize away dynamic checks.
%
\citet{dvanhorn:TobinHochstadt2012Higherorder} use AAM on a module semantics with higher-order contracts and is the most related to this work; whereas they focus on a concrete semantics for handling unknown values and an external theorem prover to show contract containment, our work focuses on an orthogonal issue of temporal contract monitoring and uses model-checking techniques.
%
Our techniques should smoothly integrate with theirs when considering partial programs, and is left to future work.
%%

%%
\section{Overview of temporal higher-order contracts}
%%

\FloatBarrier
\input{overview}
%%
\section{Semantics of Temporal Contracts} \label{sec:temporal-semantics}

\input{tconsem}

%%
\section{Semantics}\label{sec:technical}

\input{langsem}
%%
\section{Pattern-matching state machines}
\FloatBarrier

\input{pmsm}

\section{Abstract semantics}

We use the AAM approach to soundly approximate our concrete semantics.
%
This first requires a CESK-like machine to transform, but there are known ways to systematically transform Felleisen-style reduction semantics into corresponding CESK machines ~\citep{?}.
%
The important aspect of the abstraction process is not this transformation, but the fact that the space of values becomes \emph{finite}, meaning the space of PMSM machine configurations is finite.
%
Therefore, the only aspects of PMSMs that we need to tamper with are allowing binding to sets of values, and the notion of equality, to weaken it to be conservative with our abstractions.
%
In our semantics with just closures, conses, booleans and integers, we consider:
\begin{itemize}
 \item syntactically equal closures and conses to be ``\emph{maybe}-equal'';
 \item equal booleans and integers to be ``\emph{must}-equal'';
 \item integer comparisons with the abstract $\mathbf{Int}$ element to be ``\emph{maybe}-equal'' (assuming a simple flat abstraction of the integers);
 \item and all other possibilities to be ``\emph{never}-equal''.
\end{itemize}
%
This notion of equality lifts over sets of values in the obvious way.
%
There are several different techniques that we could apply in order to improve the precision of the analysis:
\begin{itemize}
\item{use abstract counting ~\citep{dvanhorn:Might:2006:GammaCFA} to improve equality checking of allocated data;}
\item{use abstract garbage collection~\citep{dvanhorn:Might:2006:GammaCFA} to remove dead temporal monitors;}
\item{use abstract garbage collection to remove bindings to dead values in live temporal monitors, considering a monitor transition that dereferences a dangling pointer to represent an impossible state (and thus can be discarded);}
\item{separate continuation management to a pushdown abstraction~\citep{dvanhorn:Vardoulakis2011CFA2}; or}
\item{use a polyvariant allocation strategy such as $m$-CFA ~\citep{dvanhorn:Might2010Resolving} or polymorphic splitting~\citep{dvanhorn:wright-jagannathan-toplas98}.}
\end{itemize}
%
We leave this exploration and evaluation of possibilities to future work.
%%

\section{Evaluation}
%%

%%
Our examples didn't take hours to check!
%
Our model is available online \footnote{\url{http://github.com/ianj/temporal-aam}}.
%%

%%
\section{Conclusion}
%%

%%
Shit works.
%%
