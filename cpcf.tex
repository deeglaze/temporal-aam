 \documentclass[preprint,onecolumn,9pt]{sigplanconf} %{onecol}
\usepackage{alltt,mathpartir,multicol}
\usepackage{amsmath,amsthm}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{url}
\usepackage{graphicx}
\usepackage{balance}
\usepackage{calc}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}

\newcommand{\naive}{naive}
\newcommand{\naively}{naively}
\newcommand{\Naive}{Naive}
\newcommand{\Naively}{Naively}
% \usepackage{xltxtra}
% \setmonofont[Scale=MatchLowercase]{DejaVu Sans Mono}
%
\input{preamble}

\begin{document}

\conferenceinfo{WXYZ '05}{date, City.}
\copyrightyear{2005}
\copyrightdata{[to be supplied]}
\title{Static Verification of Temporal Higher-Order Contracts}

\authorinfo{J. Ian Johnson}
           {Northeastern University}
           {ianj@ccs.neu.edu}
\authorinfo{Nicholas Alexander Marquez}
           {Northeastern University}
           {nam@ccs.neu.edu}
\authorinfo{David Van Horn}
           {Northeastern University}
           {dvanhorn@ccs.neu.edu}
\maketitle
\begin{abstract}
  Shwazam.
\end{abstract}

\section{Introduction}

Software systems are typically large, consist of many modules, and have invariants that are typically inexpressible or too costly to express (and prove) in the language's static type system, if it has one.
%
When this is the case, one might hope to rely on software contracts~\cite{p} to give dynamic guarantees about the behavior of one's system, blaming the correct party responsible for any violation of these invariants.
%
A proposed system of \emph{temporal contracts}~\citep{ianjohnson:dfm:icfp11} provide a linguistic mechanism to describe temporal properties that usually are checked extra-linguistically via model-checking an abstraction of the program.
%
Example temporal properties are, ``a file can only be closed if it has been opened'' and, ``if function A is given a function B, then B may not be called once A returns.''
%
Such invariants are important for interfaces that have set-up and tear-down protocols to follow.
%%

%%
There are downsides to software contracts, however.
%
If a contract is violated, a blame exception is thrown or the program simply terminates with the error.
%
Contracts do not ensure correctness --- they help the process of constructing correct programs.
%
In addition, contracts can introduce considerable overhead to the program.
%
Just wrapping a function in a contract monitor can disable compiler optimizations, and depending on the level of checking a contract does, the entry and exit of contract boundaries can also take a long time (indeed, we run arbitary programs as such checks!).
%
These are important costs to pay at the beginning of development, but as programs mature, we need a way to safely transition away from contracts and have a performance and correctness return on the initial investment.
%%

%%
Temporal contracts pose an additional challenge over higher-order function contracts to statically verify, as they monitor extended interactions with a module, and not just localized pieces.
%
We propose a framework that is composable with techniques to verify functional contracts, and transparently leverages model checking technology to verify adherence to temporal contracts.
%
The technique uses the Abstracting Abstract Machines (AAM) approach~\citet{dvanhorn:AAM} to forming the Kripke structure that we eventually model-check.
%
AAM was originally targeted towards describing flow analyses, but is robust enough to apply to model-checking higher-order programs.
%
The online nature of higher-order flow analysis algorithms creates demand for an online LTL model checker.
%
Since AAM describes its abstractions in terms of a reduction relation, Maude's LTL checker~\citep{?} is our tool of choice.
%
There is a fly in the ointment, however.
%
To converge on a Kripke structure more quickly we sometimes apply a \emph{store widening} technique, that is expressed in terms of a \emph{meta-}reduction-relation.
%
We can use Maude's reflective capabilities to express this relation, but the Kripke structure we want must be reifed from the states of the meta-reduction-relation.
%
Maude's checker does not have an interface for driving a meta-reduction-relation to reify a Kripke structure from its states, so we propose a design for such a mechanism, but evaluate our current system on a fully-run store-widened semantics.
%%

%%
Our contributions in this paper are as follows:
\begin{itemize}
 \item{a sound translation of temporal higher-order contracts to LTL propositions}
 \item{a sound abstraction scheme for creating a Kripke structure for a higher-order program}
 \item{a design for a demand-driven reflective model-checking interface}
\end{itemize}
%%

%%
\section{Related Work}
%%

%%
Model-checking and contract verification (proving functional correctness) are huge fields and it is important to view our work in the greater context of these worlds of research.
%%

%%
\paragraph{First-order model-checking:}{
The SLAM project~\citep{?} for model-checking C assumes that all function pointers of the same type alias.
%
For C programs that use callbacks heavily, this overapproximation leads to longer checking times due to more (spurious) paths to follow, and the imprecision inherent in any program approximation gets exacerbated by the additional pressure on abstract resources.
}
\paragraph{Higher-order model-checking}{
A technique that specifically targets higher-order languages, higher-order recursion schemes (HORS)~\citep{?}, assumes a call-by-name semantics for the language it checks.
%
The current techniques for the initial abstraction of a program to HORS is not generally applicable to untyped or impure languages, since it creates the recursion schemes from the simple types of a given program.
%
HORS can be applied for call-by-value order if the program is first transformed into CPS, since then the intended evaluation order is encoded into call-by-name.
%
This still does not address the need for simple types, and does not apply for languages that cannot be expressed in CPS.
}
\paragraph{Static contract verification}{
In the world of statically verifying software contracts, there is much more work.
%
There have been many successful efforts in the realm of first-order contract verification~\citep{?,?,?}, but the techniques employed are inherently first-order: the only values are booleans.
%
\citet{flanagan:hybrid-type-checking}'s notion of hybrid type checking is one way to state the problem: dynamic types are essentially flat contracts, and are treated as subtypes of anything during static checking.
%
If an external theorem prover can prove that the flat contracts always hold, the dynamic checks can be safely removed.
%
\citet{dvanhorn:oopsla2012:symbolic-eval} use AAM on a module semantics with higher-order contracts and is the most related to this work; whereas they focus on a concrete semantics for handling unknown values and an external theorem prover to show contract containment, our work focuses on an orthogonal issue of temporal contract monitoring and uses model-checking techniques.
%
Our techniques should smoothly integrate with theirs when considering partial programs, and is left to future work.
%
\citet{dvanhorn:xu:ocaml-simplifier} describe a higher-order contract verification system for OCaml by inlining all contract monitors and relying on a system of simplifications further enhanced by an SMT solver to optimize away dynamic checks.
}
%%

%%
\section{Overview of temporal higher-order contracts}
%%

%%
\begin{figure}
%  \begin{align}
%   SortContract = \\
%   \quad sort\ &:\ (List Pos) \\
%               &\rarrow\ (cmp\ :\ Pos \rarrow Pos \rarrow Bool)
%  \end{align}
 \caption{Sort example}
\end{figure}

\begin{figure}
 \caption{File example}
\end{figure}

\begin{figure}
 \caption{TCP example}
\end{figure}
%%

%%
\section{Semantics of Temporal Higher-Order Contracts}
%%

%%
See section \ref{sec:technical} for now.
%%

%%
\section{Approximation of Temporal Contracts into LTL}
%%

%%
LTL only has a finite set of atomic proposisitions for states, so there is no hope for a fully precise account for the binding across states.
%
We instead have to enumerate the concrete propositions on instantiations of the bindings.
%
Binding implicitly requires equality, so we must treat (possible) references conservatively.
%
We can use our control-flow analysis to limit how many instantiations we need to do.
%
The temporal concatenation operator cannot be translated structurally since bindings in the left contract can have references in the right contract.
%
Thus, our translation function takes the contract to translate, the result of the flow analysis, an accumulator for temporal contracts that ``happen next,'' and an environment of bindings.
%%

%%
The atomic propositions we use for checking the temporal contracts are much like the events defined in the temporal contract grammar, except we have additional information about which timeline they appear on.
%%

% \begin{align*}
%   \denoteevent{\scallev{\mtoplevelname, \mvpat}}{\menv}{\mtimeline} &=
%     \aptopcall{\mtoplevelname}{\denotevpat{\mvpat}{\menv}}{\mtimeline}
% \\
%   \denoteevent{\scallev{\mname, \mvpat}}{\menv}{\mtimeline} &=
%     \apvcall{\menv(\mname)}{\denotevpat{\mvpat}{\menv}}{\mtimeline}
% \\
%   \denoteevent{\sretev{\mtoplevelname, \mvpat}}{\menv}{\mtimeline} &=
%     \aptopret{\mtoplevelname}{\denotevpat{\mvpat}{\menv}}{\mtimeline}
% \\
%   \denoteevent{\sretev{\mname, \mvpat}}{\menv}{\mtimeline} &=
%     \apvret{\menv(\mname)}{\denotevpat{\mvpat}{\menv}}{\mtimeline}
% %%
% \\[2pt]
% %%
%   \denotevpat{\mname}{\menv} &= \menv(\mname)
% \\
%   \denotevpat{\mvpat}{\menv} &= \mvpat \quad\text{otherwise}
% \end{align*}
%%
$\toltl{\_}{\_}{\_}{\_}{\_} : \Timeline \times \TContract \times \Graph \times \Env \times \TConEnvStack \to \LTLProp$
\begin{figure}
  \begin{align*}
   \toltl{\mtimeline}{\mevent}{\mgraph}{\menv}{\mtestack} &=
     \ltland{\denoteevent{\mevent}{\menv}{\mtimeline}}
            {\ltlnext{\stacktoltl{\mtimeline}{\mtestack}{\mgraph}}}
    \\
    \toltl{\mtimeline}{\snonevent{\mevent}}{\mgraph}{\menv}{\mtestack} &=
      \ltland{\apneg{\denoteevent{\snonevent{\mevent}}{\menv}{\mtimeline}}}
             {\ltlnext{\stacktoltl{\mtimeline}{\mtestack}{\mgraph}}}
    \\
    \toltl{\mtimeline}{\stnot{\mtcon}}{\mgraph}{\menv}{\mtestack} &=
      \ltlnot{\toltl{\mtimeline}{\mtcon}{\mgraph}{\menv}{\mtestack}}
    \\
    \toltl{\mtimeline}{\stOr{\mtcon_0}{\mtcon_1}}{\mgraph}{\menv}{\mtestack} &=
      \ltlor{\toltl{\mtimeline}{\mtcon_0}{\mgraph}{\menv}{\mtestack}}
            {\toltl{\mtimeline}{\mtcon_1}{\mgraph}{\menv}{\mtestack}}
    \\
    \toltl{\mtimeline}{\stseq{\mtcon_0}{\mtcon_1}}{\mgraph}{\menv}{\mtestack} &=
      \toltl{\mtimeline}{\mtcon_0}{\mgraph}{\menv}{\cons{(\mtcon_1,\menv)}{\mtestack}}
    \\
    \toltl{\mtimeline}{\stmany{\mtconNoB}}{\mgraph}{\menv}{\mtestack} &=
      \ltlW{\toltl{\mtimeline}{\mtconNoB}{\mgraph}{\menv}{\emptytestack}}{\stacktoltl{\mtimeline}{\mtestack}{\mgraph}}
    \\
    \toltl{\mtimeline}{\stcall{\mname}{\mname'}{\mtcon}}{\mgraph}{\menv}{\mtestack} &=
      \bigwedge\limits_{(\ltlprop,\menv') \in \matchcall(\mname,\mname',\menv,\mgraph)}{
        \mkern-60mu\ltland{\ltlprop}{\ltlnext{\stacktoltl{\mtimeline}{\cons{(\mtcon,\menv')}{\mtestack}}{\mgraph}}}}
    \\
    \toltl{\mtimeline}{\stret{\mname}{\mname'}{\mtcon}}{\mgraph}{\menv}{\mtestack} &=
      \bigwedge\limits_{(\ltlprop,\menv') \in \matchret(\mname,\mname',\menv,\mgraph)}{
        \mkern-60mu\ltland{\ltlprop}{\ltlnext{\stacktoltl{\mtimeline}{\cons{(\mtcon,\menv')}{\mtestack}}{\mgraph}}}}
    \\
      \toltl{\mtimeline}{\sddd}{\mgraph}{\menv}{\mtestack} &= \stacktoltl{\mtimeline}{\mtestack}{\mgraph}
%%
\\[2pt]
%%
    \stacktoltl{\mtimeline}{\emptytestack}{\mgraph} &= \ltlTrue
\\
    \stacktoltl{\mtimeline}{\cons{(\mtcon,\menv)}{\mtestack}}{\mgraph} &=
      \toltl{\mtimeline}{\mtcon}{\mgraph}{\menv}{\mtestack}
  \end{align*}
  
  \caption{Translation of temporal contracts to LTL}
\label{fig:translation}
\end{figure}
%%

%%
The metafunction $\splitpattern$ is crutial for the understanding of bindings in the temporal contract.
%
All points in the abstract state space that match the event will contribute their bindings to the environment for interpreting the rest of the contract.
%
This can lead to a blow-up for temporal contracts that liberally use binding, but we can prune the number of propositions we construct by restricting the graph to only nodes reachable from the ones we match against the event.
%
Since CFA abstracts bindings, we can't always be certain we have exact equality when looking up bindings, too.
%
Thus, $\splitpattern$ considers some values to both match and not match a given pattern.
%%

\begin{align*}
  \splitpattern(\scallev{\mfnpat}{\mvpat}, \mgraph, \menv) &= \setbuild{(\mnode,\restricttoreachable(\mgraph,\mnode), \menv')}{(\mnode,\menv') \in \matchcall(\mfnpat, \mvpat, \mgraph, \menv)}\\
\\
  \splitpattern(\sretev{\mfnpat}{\mvpat}, \mgraph, \menv) &= \setbuild{(\mnode,\restricttoreachable(\mgraph,\mnode), \menv')}{(\mnode,\menv') \in \matchret(\mfnpat, \mvpat, \mgraph, \menv)}\\
\\
  \matchcall(\mtoplevelname, \mvpat, \mgraph, \menv) &=
    \setbuild{(\mnode, \menv')}
             {\\
              \mnode\equiv\co{\spush{\kmcall{\mmlab_u}{\mmlab_c}{\mlab}{\mscon_R, \mtimeline, \menv_0, \mtoplevelname, \maddr}}{\mkaddr}, \mval, \msto}{\msmlab}{\mstimeline} \in \mgraph\span\omit \\
                &\wedge \menv' \in \matchv(\mvpat, \mval, \menv)}
\\
  \matchcall(\mname, \mvpat, \mgraph, \menv) &=
    \setbuild{(\mnode, \menv')}
             {\\
              \mnode\equiv\co{\spush{\kmcall{\mmlab_u}{\mmlab_c}{\mlab}{\mscon_R, \mtimeline, \menv_0, \mtoplevelname, \maddr}}{\mkaddr}, \mval, \msto}{\msmlab}{\mstimeline} \in \mgraph\span\omit \\
                &\wedge \menv' \in \matchv(\mvpat, \mval, \menv)} \\
  \text{if } & \menv(\mname) = \blclos{\mtoplevelname}{\mmlab_u}{\mmlab_c}{\mlab}{\mscon_?}{\mscon_R}{\menv}{\mtimeline}{\maddr}
\\
  \matchret(\mtoplevelname, \mvpat, \mgraph, \menv) &=
    \setbuild{(\mnode, \menv')}
             {\\
              \mnode\equiv\co{\spush{\krt{\mmlab',\mtimeline'}}{\mkaddr}, \mval, \msto}{\mtoplevelname}{\mstimeline} \in \mgraph\span\omit \\
                &\wedge \menv' \in \matchv(\mvpat, \mval, \menv)}
\\
  \matchret(\mname, \mvpat, \mgraph, \menv) &=
    \setbuild{(\mnode, \menv')}
             {\\
              \mnode\equiv\co{\spush{\krt{\mmlab',\mtimeline'}}{\mkaddr}, \mval, \msto}{\mtoplevelname}{\mtimeline} \in \mgraph\span\omit \\
                &\wedge \menv' \in \matchv(\mvpat, \mval, \menv)} \\
  \text{if } & \menv(\mname) \equiv \blclos{\mtoplevelname}{\mmlab_u}{\mmlab_c}{\mlab}{\mscon_c}{\mscon_R}{\menv''}{\mtimeline}{\maddr}
\\
 \matchv(\swc, \mval, \menv) &= \setof{\menv}
\\
 \matchv(\sbind{\mname}, \mval, \menv) &= \setof{\ext{\menv}{\mname}{\mval}}
\\
 \matchv(\sref{\mname}, \mval, \menv) &= \text{ if } \mval \sqsupseteq \menv(\mname) \text{ then } \setof{\menv} \text{ else } \varnothing
\\
 \matchv(\mconstant, \mval, \menv) &= \text{ if } \mval \sqsupseteq \mconstant \text{ then } \setof{\menv} \text{ else } \varnothing
\end{align*}

\section{Design for a reflective model checker}
%%

%%
Ya... if we actually do this.
%%

%%
\section{Evaluation}
%%

%%
Our examples didn't take hours to check!
%
Our model is available online \footnote{\url{http://github.com/ianj/temporal-aam}}.
%%

%%
\section{Conclusion}
%%

%%
Shit works.
%%

%%
\section{Everything Technical}\label{sec:technical}

%%
Syntax:
\begin{align*}
\mexp \in \Expr &::=
      \svar[^\mlab]{\mvar}
 \alt \sapp[^\mlab]{\mexp}{\mexp}
 \alt \slam[^\mlab]{\mvar}{\mexp} \\
&\alt \sif[^\mlab]{\mexp}{\mexp}{\mexp} 
 \alt \sMon{\mmlab}{\mmlab}{\mlab}{\mcontract, \mexp}
 \alt \slit{\mconstant} \\
\mconstant \in \Constant &= -1 \alt 0 \alt 1 \alt \ldots \alt \strue \alt \sfalse \alt \scons \alt \scar \alt \ldots \\
\mvar \in \Var &\quad\text{ an infinite set} \\
\mlab \in \Label &\quad\text{ an infinite set} \\
\mmlab,\mname \in \ModuleLabel &\text{ an infinite set} \\
\msmlab \in \ModuleLabel^{\toplevel} &::= \mmlab \alt \toplevel \\
\mcontract \in \Contract &= \SContract \times \TContract \\
\mscon \in \SContract &::= \sflat{\mexp} \alt \sarr{\mname}{\mscon}{\mscon} \alt \sconsc{\mscon}{\mscon} \\
\mtcon \in \TContract &::=
      \stseq{\mbevent}{\mtcon}
 \alt \mtconNoB
 \alt \stnot{\mtcon}
 \alt \stOr{\mtcon}{\mtcon}
 \alt \stseq{\mtcon}{\mtcon}
 \alt \stmany{\mtconNoB}
 \alt \sddd \\
\mtconNoB &::= \maevent \alt \snonevent{\maevent} \alt \stOr{\mtconNoB}{\mtconNoB} \\
\maevent, \mbevent &\in \Event \\
\maevent &::= \scallev{\mname}{\mvpat} \alt \sretev{\mname}{\mvpat} \\
\mbevent &::= \scallev{\mbfun}{\mbvar} \alt \sretev{\mbfun}{\mbvar} \\
&\alt \scallev{\mbfun}{\mvpat} \alt \sretev{\mbfun}{\mvpat} \\
&\alt \scallev{\mname}{\mbvar} \alt \sretev{\mname}{\mbvar} \\
\mbfun, \mbvar &::= \mname_{id} \quad\text{ where $id$ identifies the binding } \\
\mvpat \in \VPat &::= \mname \alt \swc \alt \mconstant
\end{align*}
%%

%%
Wrapping monitors around values associates entirely fresh NFA states.
%
The names given to bindings are really associated with the bindings.
%
We have to give up some precision for decidability --- we use a monovariant allocation scheme for monitor allocation.
%
This scheme allows us to lift all textual temporal contracts to the top level and check individually.
%
A polyvariant scheme would require either knowing how many abstract bindings are allocated during execution, or an exhaustive enumeration of possible bindings as propositions to check.
%
Since we run CFA before appealing to the model checker, the former is feasible, but it distracts from the overall exposition.
%%

%%
Value space:
\begin{align*}
  \mval \in \Value &=
    \clos{\mvar, \mexp, \menv}
   \alt \blclos{\mname}{\mmlab}{\mmlab}{\mlab}{\mscon}{\mscon}{\menv}{\mtimeline}{\maddr}
   \alt \mconstant \\
%   \alt \blackhole \\
&  \alt \vconsf{\maddr}
   \alt \vcons{\maddr}{\maddr}
   \alt \vconst{\maddr}{\maddr}{\mstimeline}
   \alt \sunit \\
  \menv \in \Env &= \Var \parto (\Addr \times \Timeline^{\toplevel}) \\
  \maddr \in \Addr &\text{ an infinite set} \\
  \mstimeline \in \Timeline^{\toplevel} &::= \maddr \alt \toplevel \\
  \mnames &\in \wp(\Var) \\
\end{align*}
%%

%%
State space:
\begin{align*}
  \mstate \in \State &::=
      \ev[^\mlab]{\mexp, \menv, \msto, \mkont}{\msmlab}{\mstimeline}
 \alt \co{\mkont, \mval, \msto}{\msmlab}{\mstimeline} \\
&\alt \ap[^\mlab]{\mval, \mval, \msto, \mkont}{\msmlab}{\mstimeline}
 \alt \ck{\mmlab}{\mmlab}{\mlab}{\pm}{\mscon, \maddr, \menv, \mval, \msto, \mkont}{\msmlab}{\mstimeline}
 \alt \sblame{\mmlab} \\
\msto \in \Store &= \Addr \parto \wp(\Storeable) \\
\Storeable &= \Value + \Kont + \TContract \\
\mframe \in \Frame &::=
      \kar[^\mlab]{\mexp,\menv}
 \alt \kfn[^\mlab]{\mval}
 \alt \kif{\mexp, \mexp, \menv} \\
&\alt \krt{\mmlab, \mtimeline}
 \alt \kmon{\mmlab}{\mmlab}{\mlab}{\mscon, \mtimeline, \menv}
 \alt \kflat[^\mlab]{\mmlab, \mval} \\
&\alt \kchkA[^\mlab]{\mmlab, \mmlab, \mscon, \maddr, \maddr, \maddr}
 \alt \kchkD[^\mlab]{\mmlab, \mmlab, \maddr, \maddr, \maddr, \maddr}
 \alt \kcheck[^\mlab]{\mmlab, \mval} \\
&\alt \kpost[^\mlab]{\mscon, \mtimeline, \menv}
 \alt \kmcall{\mmlab}{\mmlab}{\mlab}{\mscon, \mtimeline, \menv, \mname, \maddr} \\
\mkont \in \Kont &::= \kmt \alt \spush{\mframe}{\mkaddr}
\end{align*}

% \begin{align*}
%     \accept &: \ModuleLabel \times \ModuleLabel \times \Label \times \SContract \times \Value \\
%             &\to (\Value \times \Store) + \Expr + \bot
% \end{align*}
% \begin{align*}
%   \accept(\mmlab_u, \mmlab_c, \mlab, \sarr{\mname}{\mscon_D}{\mscon_R}, \mval) &=
%           \blclos{\mname}{\mmlab_u}{\mmlab_c}{\mlab}{\mscon_D}{\mscon_R}{\menv}{\maddr}, \\
% \phantom{\accept(\mmlab_u, \mmlab_c, \mlab, \sarr{\mname}{\mscon_D}{\mscon_R}, \mval)} &\phantom{= }
%           \ext{\msto}{\maddr}{\setof{\mval}} \\
%   \text{if } \mval \equiv \clos{\mvar, \mexp, \menv'} \text{ or }&
%              \mval \equiv \blclos{\mname'}{\mmlab_u'}{\mmlab_c'}{\mlab'}{\mscon_D'}{\mscon_R'}{\menv'}{\maddr'}
%   \\
%   \accept(\mmlab_u, \mmlab_c, \mlab, \sflat(\mexp), \mval) &= \mexp \\
%   \accept(\mmlab_u, \mmlab_c, \mlab, \sarr{\mname}{\mscon_D}{\mscon_R}, \mval) &= \bot \text{ otherwise}
% \end{align*}

\begin{figure*}
  \begin{gather*}
    \begin{array}{@{}r@{\ }c@{\ }l@{}}
      \mstate & \machstep &\mstate' \text{ defined to be the following} \\
      %% EVAL
      \ev{\svar\mvar, \menv, \msto, \mkont}{\msmlab}{\mstimeline} &\machstep&
      \co{\mkont, \mval, \msto}{\msmlab}{\mstimeline}
      \text{ if } (\maddr, \mstimeline') = \menv(\mvar), \mval \in \msto(\maddr)
      \\
    %%
      \ev{\sapp[^\mlab]{\mexpi0}{\mexpi1}, \menv, \msto, \mkont}{\msmlab}{\mstimeline} &\machstep&
      \ev{\mexpi0, \menv, \msto', \spush{\kar[^\mlab]{\mexpi1, \menv}}{\mkaddr}}{\msmlab}{\mstimeline}
      \\
      &&\text{where } \mkaddr = \alloc(\mstate) \\
      &&\phantom{\text{where }} \msto' = \ext{\msto}{\mkaddr}{\setof{\mkont}} \\
      %%
      \ev{\sif{\mexpi0}{\mexpi1}{\mexpi2}, \menv, \msto, \mkont}{\msmlab}{\mstimeline} &\machstep&
      \ev{\mexpi0, \menv, \msto', \spush{\kif{\mexpi1, \mexpi2, \menv}}{\mkaddr}}{\msmlab}{\mstimeline} \\
      &&\text{where } \mkaddr = \alloc(\mstate) \\
      &&\phantom{\text{where }} \msto' = \ext{\msto}{\mkaddr}{\setof{\mkont}} \\
     %%
      \ev{\slam{\mvar}{\mexp}, \menv, \msto, \mkont}{\msmlab}{\mstimeline} &\machstep&
      \co{\mkont, \clos{\mvar, \mexp, \menv}, \msto}{\msmlab}{\mstimeline}
      \\
      %%
      \ev{\slit{\mconstant}, \menv, \msto, \mkont}{\msmlab}{\mstimeline} &\machstep&
      \co{\mkont, \mconstant, \msto}{\msmlab}{\mstimeline}
      \\
      %%
      %% CONTINUE
      \co{\spush{\kif{\mexpi0, \mexpi1, \menv}}{\mkaddr}, \strue, \menv, \msto}{\msmlab}{\mstimeline} &\machstep&
      \ev{\mexpi0, \menv, \msto, \mkont}{\msmlab}{\mstimeline} \text{ if } \mkont \in \msto(\mkaddr)
      \\
      %%
      \co{\spush{\kif{\mexpi0, \mexpi1, \menv}}{\mkaddr}, \sfalse, \menv, \msto}{\msmlab}{\mstimeline} &\machstep&
      \ev{\mexpi1, \menv, \msto, \mkont}{\msmlab}{\mstimeline} \text{ if } \mkont \in \msto(\mkaddr)
      \\
      %%
      \co{\spush{\kar[^\mlab]{\mexp, \menv}}{\mkaddr}, \mval, \msto}{\msmlab}{\mstimeline} &\machstep&
      \ev[^\mlab]{\mexpi, \menv, \msto', \spush{\kfn[^\mlab]{\mval}}{\mkaddr}}{\msmlab}{\mstimeline}
      \\
      && \text{where } \maddr' = \alloc(\mstate) \\
      &&\phantom{\text{where }} \msto' = \ext{\msto}{\maddr'}{\setof{\mval}} \\
      %%
      \co{\spush{\kfn[^\mlab]{\mval_f}}{\mkaddr}, \mval, \msto}{\msmlab}{\mstimeline} &\machstep&
      \ap{\mval_f, \mval, \msto, \mkont}{\msmlab}{\mstimeline} \text{ if } \mkont \in \msto(\mkaddr)
      \\
      %%
      %% APPLY
      \ap{\clos{\mvar, \mexp, \menv}, \mval, \msto, \mkont}{\msmlab}{\mstimeline} &\machstep&
      \ev{\mexp, \menv', \msto', \mkont}{\msmlab}{\mstimeline} \\
      &&\text{where } \maddr = \alloc(\mstate) \\
      &&\phantom{\text{where }} \menv' = \menv[\mvar \mapsto (\maddr, \mstimeline)] \\
      &&\phantom{\text{where }} \msto' = \ext{\msto}{\maddr}{\setof{\mval}}
    \end{array}    
  \end{gather*}
  \caption{Standard reduction rules}
  \label{fig:standard}
\end{figure*}

\begin{figure*}
  \begin{gather*}
    \begin{array}{@{}r@{\ }c@{\ }l@{}}
      \mstate & \machstep &\mstate' \text{ defined to be the following} \\
      %% EVAL
      \ev{\sMon{\mmlab_u}{\mmlab_c}{\mlab}{(\mscon, \mtcon), \mexp}, \menv, \msto, \mkont}
         {\msmlab}{\mstimeline} &\machstep&
      \ev[^\mlab]{\mexp, \menv, \msto', \spush{\kmon{\mmlab_u}{\mmlab_c}{\mlab}{\mscon, \mtimeline, \menv}}{\mkaddr}}
         {\msmlab}{\mstimeline} \\
      &&\text{where } (\mkaddr, \mtimeline) = \alloc(\mstate) \\
      &&\phantom{\text{where }}
         \msto' = \msto \sqcup [\mkaddr \mapsto \setof{\mkont},
                                \mtimeline \mapsto \setof{\mtcon}]
      \\
      %%
      %% CONTINUE
      \co{\spush{\krt{\mmlab',\mtimeline'}}{\mkaddr}, \mval, \msto}
         {\msmlab}{\mstimeline}
        &\machstep&
      \co{\mkont, \mval, \msto}
         {\mmlab'}{\mtimeline'} \text{ if } \mkont \in \msto(\mkaddr)
      \\
      %%
      \co{\spush{\kmon{\mmlab_u}{\mmlab_c}{\mlab}{\mscon, \mtimeline, \menv}}{\mkaddr}, \mval, \msto}
         {\msmlab}{\mstimeline} &\machstep&
      \ck{\mmlab_u}{\mmlab_c}{\mlab}{+}
         {\mscon, \mtimeline, \menv, \mval, \msto, \mkont}
         {\msmlab}{\mstimeline} \text{ if } \mkont \in \msto(\mkaddr)
      \\
      %%
      %% Administrative contract checking
      %% Flat
      \ck{\mmlab_u}{\mmlab_c}{\mlab}{\mvariance}
         {\sflat{\mexp}, \mtimeline, \menv, \mval, \msto, \mkont}
         {\msmlab}{\mstimeline} &\machstep&
      \ev{\mexp, \menv, \msto', \spush{\kflat[^\mlab]{\mmlab_p, \mval}}{\mkaddr}}
         {\msmlab}{\mstimeline} \\
      &&\text{where } \mkaddr = \alloc(\mstate) \\
      &&\phantom{\text{where }} \msto' = \ext{\msto}{\mkaddr}{\setof{\mkont}} \\
      &&\phantom{\text{where }} \mmlab_p = \varianceite{\mvariance}{\mmlab_u}{\mmlab_c}
      \\
      % %% Higher-order
      \ck{\mmlab_u}{\mmlab_c}{\mlab}{\mvariance}
         {\sarr{\mname}{\mscon_D}{\mscon_R}, \mtimeline, \menv, \mval, \msto, \mkont}
         {\msmlab}{\mstimeline} &\machstep&
      \co{\mkont, \blclos{\mname}{\mmlab_u}{\mmlab_c}{\mlab}{\mscon_D}{\mscon_R}{\menv}{\mtimeline}{\maddr}, \msto'}
         {\msmlab}{\mstimeline} \\
      &\text{ if }& \mval \equiv \clos{\mvar, \mexp, \menv'}
       \text{ or }  \mval \equiv \blclos{\mname'}{\mmlab_u'}{\mmlab_c'}{\mlab'}{\mscon_D'}{\mscon_R'}{\menv'}{\mtimeline'}{\maddr'} \\
      &&\text{where } \maddr = \alloc(\mstate) \\
      &&\phantom{\text{where }} \msto' = \ext{\msto}{\maddr}{\setof{\mval}}
      \\
      %%
      \ck{\mmlab_u}{\mmlab_c}{\mlab}{\mvariance}
         {\sarr{\mname}{\mscon_D}{\mscon_R}, \mtimeline, \menv, \mval, \msto, \mkont}
         {\msmlab}{\mstimeline} &\machstep&
      \sblame{\mmlab_p} \\
      &\text{ if }& \mval \nequiv \clos{\mvar, \mexp, \menv'}
       \text{ and } \mval \nequiv \blclos{\mname'}{\mmlab_u'}{\mmlab_c'}{\mlab'}{\mscon_D'}{\mscon_R'}{\menv'}{\mtimeline'}{\maddr'} \\
      &&\text{where } \mmlab_p = \varianceite{\mvariance}{\mmlab_u}{\mmlab_c}
      \\
      %% CONS CONTRACT
      % Start checking car
      \co{\spush{\kmon{\mmlab_u}{\mmlab_c}{\mlab}{\sconsc{\mscon_A}{\mscon_D}, \mtimeline, \menv}}{\mkaddr},
          \mval,
          \msto}
         {\msmlab}{\mstimeline} &\machstep&
      \ck{\mmlab_u}{\mmlab_c}{\mlab}{+}
         {\mscon_A,
          \mtimeline,
          \menv,
          \mval_A,
          \msto,
          \spush{\kchkA[^{\mmlab_u, \mmlab_c}_\mlab]{\mscon_D, \mtimeline, \menv, \maddr'_A, \maddr'_D, \maddr_D}}
                {\mkaddr}}
         {\msmlab}{\mstimeline} \\
      &\text{ if }& \mval \equiv \vcons{\maddr_A}{\maddr_D} \text{ or }
                    \mval \equiv \vconst{\maddr_A}{\maddr_D}{\mstimeline'} \text{ and } \mval_A \in \msto(\maddr_A) \\
      &&\text{where } (\maddr'_A, \maddr'_D) = \alloc(\mstate)
      \\
      % Start checking cdr
      \co{\spush{\kchkA[^{\mmlab_u, \mmlab_c}_\mlab]{\mscon_D, \mtimeline, \menv, \maddr'_A, \maddr'_D, \maddr_D}}{\mkaddr},
          \mval, \msto}
         {\msmlab}{\mstimeline} &\machstep&
      \ck{\mmlab_u}{\mmlab_c}{\mlab}{+}
         {\mscon_D, \mtimeline, \menv, \mval_D, \msto',
                                \spush{\kchkD{\maddr'_A, \maddr'_D, \mtimeline}}{\mkaddr}}
         {\msmlab}{\mstimeline}
      \text{ if } \mval_D \in \msto(\maddr_D) \\
      &&\text{where } \msto' = \ext{\msto}{\maddr'_A}{\setof{\mval}}
      \\
      %%
      % End checking cdr
      \co{\spush{\kchkD{\maddr_A, \maddr_D, \mtimeline}}{\mkaddr}, \mval, \msto}
         {\msmlab}{\mstimeline}
       &\machstep&
      \co{\mkont, \vconst{\maddr_A}{\maddr_D}{\mtimeline}, \ext{\msto}{\maddr_D}{\setof{\mval}}}
         {\msmlab}{\mstimeline}
        \text{ if } \mkont \in \msto(\mkaddr)
      \\
      %% END CONS CONTRACT
      %%
      \co{\spush{\kflat[^\mlab]{\mmlab_u, \mval'}}{\mkaddr}, \mval, \msto}{\msmlab}{\mstimeline} &\machstep&
      \ap[^\mlab]{\mval, \mval', \msto, \spush{\kcheck{\mmlab_u, \mval'}}{\mkaddr}}{\msmlab}{\mstimeline}
      \\
      %%
      \co{\spush{\kcheck{\mmlab_u, \mval}}{\mkaddr}, \strue, \msto}{\msmlab}{\mstimeline} &\machstep&
      \co{\mkont, \mval, \msto}{\msmlab}{\mstimeline} \text{ if } \mkont \in \msto(\mkaddr)
      %% \attach{\mval_C}{\mval}
      \\
      %%
      \co{\spush{\kcheck{\mmlab_u, \mval}}{\mkaddr}, \sfalse, \msto}{\msmlab}{\mstimeline} &\machstep&
      \sblame{\mmlab_u}
      \\
      %%
      \co{\spush{\kmcall{\mmlab_u}{\mmlab_c}{\mlab}{\mscon_R, \mtimeline, \menv, \mname, \maddr}}{\mkaddr},
          \mval,
          \msto}{\msmlab}{\mstimeline} &\machstep&
      \ap{\mval_f,
          \mval,
          \msto,
          \spush{\kpost[^{\mmlab_u, \mmlab_c}_\mlab]{\mscon_R, \mtimeline, \menv, \msmlab}}{\mkaddr}}
         {\mname}{\mtimeline}
        \text{ if } \mval_f \in \msto(\maddr)
      \\
      %%
      % Start checking the post-condition before returning
      \co{\spush{\kpost[^{\mmlab_u, \mmlab_c}_\mlab]{\mscon_R, \mtimeline, \menv, \mname}}{\mkaddr}, \mval, \msto}
         {\msmlab}{\mstimeline}
       &\machstep&
      \ck{\mmlab_u}{\mmlab_c}{\mlab}{+}
         {\mscon_R, \menv, \mval, \msto, \spush{\krt{\mname, \mtimeline}}{\mkaddr}}
         {\msmlab}{\mstimeline}
      \\
      %%
      %% APPLY
      \ap[^\mlab]{\blclos{\mname}{\mmlab_u}{\mmlab_c}{\mlab'}{\mscon_D}{\mscon_R}{\menv}{\mtimeline}{\maddr},
                  \mval,
                  \msto,
                  \mkont}
                 {\msmlab}{\mstimeline} &\machstep&
      \ck{\mmlab_u}{\mmlab_c}{\mlab'}{-}
         {\mscon_D, \menv, \mval, \msto',
          \spush{\kmcall{\mmlab_u}{\mmlab_c}{\mlab}{\mscon_R, \mtimeline, \menv, \mname, \maddr}}{\mkaddr}}
         {\msmlab}{\mstimeline} \\
      &&\text{where } \mkaddr = \alloc(\mstate) \\
      &&\phantom{\text{where }} \msto' = \ext{\msto}{\mkaddr}{\setof{\mkont}}
      %%
    \end{array}
  \end{gather*}
  \caption{Non-standard rules}
\label{fig:concrete}
\end{figure*}
%\balance
%\bibliographystyle{plain}
%\input{paper.bbl}
%\bibliography{local,bibliography}

% \include{appendix}
\end{document}