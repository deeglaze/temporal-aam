\section{Introduction}

Software systems are large, consist of many modules, and have invariants that are either outright inexpressible or too costly to express (and prove) in the language's static type system --- if it has one.
%
When this is the case, one might hope to rely on software contracts~\cite{dvanhorn:dvanhorn:meyer-eiffel} to give dynamic guarantees about the behavior of one's system.
%
In modern, higher-order languages, the question of ``who violated the contract?'' becomes non-trivial, and we graduate to higher-order contracts ~\citep{dvanhorn:Findler2002Contracts} to blame the correct party responsible for any violation of these invariants.
%
A proposed system of \emph{temporal higher-order contracts}~\citep{ianjohnson:dfm:icfp2011} (henceform DFM) provides a linguistic mechanism to describe temporal properties of behavioral values flowing through the program.
%
%when traditionally such properties are checked extra-linguistically by model-checking an abstracted form of the program.
%
Example temporal properties are, ``a file can only be closed if it has been opened'' and, in the higher-order setting, ``if function A is given a function B, then that B may not be called once A returns.''
%
Such invariants are important for interfaces that have set-up and tear-down protocols to follow, or even pure interfaces that have particular compositions of calls needed to construct some object.
%%

%%
There are downsides to software contracts, however.
%
Since contracts are strictly for runtime monitoring, they do not themselves ensure correctness --- they help the process of constructing correct programs.
%
In addition, contracts can introduce considerable overhead to the program.
%
These may be acceptable costs to pay at the beginning of development, but model-checking provides an additional level of confidence in correctness or pinpoints means for failure.
%
A sound model checker can justify safely removing contract checking and have a performance-and-correctness return on the initial investment.
%%

%%
Temporal contracts pose an additional challenge over higher-order function contracts to statically verify, as they monitor extended interactions with a module, and not just localized pieces.
%
We propose a framework that is composable with techniques to verify functional contracts, that has low technical overhead (\eg, no translation to a model-checker's language necessary).
%
The technique uses the Abstracting Abstract Machines (AAM) approach \citep{dvanhorn:VanHorn2010Abstracting} to check for reachability of a temporal contract blame.
%%

%%
AAM was originally targeted towards describing flow analyses, but is robust enough to apply to model-checking safety properties of higher-order programs.
%
It is well-known that control-flow analysis can be stated in terms of model-checking~\citep{ianjohnson:analysis-is-mc}, but this observation is misleading; one must use a quadratic number of model-checking queries to discover what a monovariant flow analysis can discover in one run.
%
In general, the queries are at least linear in the size of the abstract value space, which is exponential in some polyvariant analyses such as 1-CFA. % TODO: cite Van Horn, Mairson?
%
The value space tends to be sparse in practice, but an ahead-of-time query generator cannot discover it without a polyvariant analysis.
%
The realm of temporal contract verification is similar: to use a model-checker, we would have to run a data-flow analysis up front in order to collect values that might be used as bindings, enumerate all possible binding/reference insantiations of the temporal contract, and then translate those contracts into LTL queries --- much more work than just running the program abstractly and reporting reachable blame states.
%

%%
Our contributions in this paper are as follows:
\begin{itemize}
 \item{an alternative to \dfm's temporal contract semantics amenable to analysis yet faithful to their examples;}
 \item{a notion of derivative for regular expressions with back-references;}
 \item{a sound abstraction to computably verify temporal contract satisfaction.}
\end{itemize}
%%

%%
\section{Overview of temporal higher-order contracts}
%%

%\FloatBarrier
\input{overview}
%%
\section{Semantics of Temporal Contracts} \label{sec:temporal-semantics}

\input{tconsem}

%%
\section{Semantics}\label{sec:technical}

\input{langsem}
%%

\section{Abstract semantics}

We use the AAM approach to soundly approximate our concrete semantics.
%
This first requires a CESK-like machine to transform, but there are known ways to systematically transform Felleisen-style reduction semantics into corresponding CESK machines ~\citep{dvanhorn:Danvy-Nielsen:RS-04-26}.
%
The important aspect of the abstraction process is not this transformation, but the fact that the space of values becomes \emph{finite}, meaning the space of temporal contract derivatives is finite (proven via simple coinduction).
%
In our semantics with just closures, conses, booleans and integers, we consider:
\begin{itemize}
 \item syntactically equal closures and conses to be ``\emph{maybe}-equal'';
 \item equal booleans and integers to be ``\emph{must}-equal'';
 \item integer comparisons with the abstract $\mathbf{Int}$ element to be ``\emph{maybe}-equal'' (assuming a simple flat abstraction of the integers);
 \item and all other possibilities to be ``\emph{never}-equal''.
\end{itemize}
%
Any time a temporal contract is in a \emph{may} state, we blame conservatively.
%
Since timelines can be abstractly allocated more than once, each time we send an action to the monitor, we have to both step and not step the contract, which can kill precision and performance.
%
On top a basic abstraction from AAM, we evaluate the following techniques to improve the precision of the analysis:
\begin{itemize}
\item{($\mu$) use abstract counting ~\citep{dvanhorn:Might:2006:GammaCFA} to improve equality checking of allocated data and provide a non-trivial $\gamma_1?$;}
\item{($\Gamma$) use abstract garbage collection~\citep{dvanhorn:Might:2006:GammaCFA} to remove dead temporal monitors;}
\item{($\Gamma_\tau$) use abstract garbage collection to remove bindings to dead values in live temporal monitors.
%
This means we reduce $\mtcon,\menv$ to $\mtcon,\menv'$, where $\menv'$ restricts variables to the values in $\menv$ that touch only reachable addresses.
%
The concrete semantics would operate the same way regardless of GC, but this is akin to using weak boxes to maintain values in temporal contract environments;}
\item{($\Xi$) separate continuation management to a pushdown abstraction~\citep{dvanhorn:Vardoulakis2011CFA2}.}%; or}
%\item{use a polyvariant allocation strategy such as $m$-CFA ~\citep{dvanhorn:Might2010Resolving} or polymorphic splitting~\citep{dvanhorn:wright-jagannathan-toplas98}.}
\end{itemize}
%%

\section{Evaluation}
%%

\begin{figure}
  \input{benchmark-table}
  \caption{Benchmark results. Numbers are run-time (ms) / spurious blames (\%)}
  \label{fig:evaluation}
\end{figure}
%%
We built temporal higher-order contracts into our existing framework for analyzing a subset of Scheme \footnote{Model and benchmarks available online \url{http://github.com/dvanhorn/oaam/tree/thocon}}.
%
Our benchmarks are a collection of examples from \dfm's paper and implementation, along with a larger-than-toy example:
\paragraph{{\tt sort1}:}{\dfm's motivating example of a non-reentrant sort function where the given comparison function may not be called after sort returns\footnote{If sort stashes the comparator in a global and we call it afterwards, \dfm's implementation does not raise blame, whereas ours does.}.
%
The structural contract for {\tt sort1} is weak: {\tt (listof integer?) -> any/c}.
}
\paragraph{{\tt sort2}:}{like {\tt sort1}, but with a stronger structural contract that will confuse a regular analysis: {\tt (listof integer?) -> (listof integer?)}.}
\paragraph{{\tt sort3}:}{like {\tt sort2}, but call sort more than once (mapped over a list of lists), in order to confuse non-$\Gamma_\tau$ analyses.}
\paragraph{{\tt malloc}:}{A pair of two functions, malloc and free, where malloc returns an ever-growing counter and free does nothing. They are contracted so that free may not be called with addresses that were previously freed and not subsequently returned by malloc.}
\paragraph{{\tt file}:}{A function, {\tt open}, which given a file path, produces a list of read, write and close functions. They are contracted such that none of these functions may be called after close. Using this interface, we copy the contents of files in one list and write them to the files in the other.}
\paragraph{{\tt FTP}:}{An FTP server built on TCP. \textbf{TODO: Alex}}
%%

%%
The analysis results and run times for our benchmark programs are in \autoref{fig:evaluation}, categorized by the additional machinery as labeled in the previous section.
%
Analyses without garbage collection used the global store widening to accelerate convergence.
%%

%%
The minor variations to the sort example motivated our additional analytical machinery, \textbf{TO BE SEEN} and proved strong enough to verify the more complicated example of the FTP interaction.
%
No technique we employed could fully verify the {\tt malloc} example, since the protocol depends on being able to prove equality between values that are mutated and grown without bound; our abstraction for numbers is simple, so the mutated counter immediately jumps to \textbf{Int}$\top$, where comparisons conservatively both succeed and fail.

%%
\section{Related Work}
%%

%%
Model-checking and contract verification (proving functional correctness) are huge fields and it is important to view our work in the greater context of these worlds of research.
%
The main separating factor between this work and the model-checking literature is that temporal property verification is \emph{extra-linguistic}, meaning there is no mechanism in the object language that could monitor for the properties.
%
Furthermore, work that focuses on the linguistic mechanism does not also focus on the verification mechanism.
%%

%%
\paragraph{Runtime monitoring:}
Monitoring sequences of actions at runtime is a mature and active area of research.
%
This area has similarities to temporal contracts due to the use of runtime monitoring and of languages for describing execution traces, but nothing in the area has the concept of blame or has a static story.
%
The notion of an action is reminiscent of aspect-oriented programming's notion of a \emph{join-point}, and thus we see several systems built on AspectJ \citep{ianjohnson:aspectj} that offer a domain-specific language for running \emph{advice} when the action trace matches a specified pattern, \eg, Tracematches \citep{ianjohnson:Allan05addingtrace} and J-LO ~\citep{ianjohnson:jlo}.
%
Tracematches use a language similar to temporal contracts but do not support negation; they also have a different purpose: execute advice at more specific times based on the program history, and not to offer a high-level specification system with blame that contracts provide.
%
J-LO on the other hand offers a monitoring system based on LTL propositions with binding constructs that tracks the satisfaction of the LTL proposition with the assumption that future portions of the proposition hold.
%
If the \emph{now} portion of the proposition fails to hold, the monitor raises a failure (it does not blame).
%
The language for temporal contracts is an extension of regular expressions with back references, as many desirable properties are difficult to express in LTL with back-references (DLTL ~\cite{ianjohnson:jlo})\footnote{A sentiment expressed by DLTL's inventor~\citep{boddenadmission}}.
%
Temporal contracts and DLTL can talk about value flow and use over time via binding in the specification --- this is not something that LTL can locally express, and DLTL does not currently have any model checking tool-support.
%
J-LO's goal is closer to temporal contracts, but its language is not; conversely, tracematches match the language and not the goal.
%
In both cases, the only static analysis is on the specification itself in order to improve runtime performance, and not on the monitored program's adherence to the specification.
%
Both systems are also tied to Java's class structure, so they cannot express properties of higher-order behavior or refinements on values.

\paragraph{Higher-order model-checking:}
Java and C++ both have several high-quality model-checking tools \citep{ianjohnson:bandera, ianjohnson:java-pathfinder, ianjohnson:LLBMC}, some of which are bounded model-checkers; meaning they cannot fully verify temporal properties --- only present possible counter-examples.
%
Bandera~\citep{ianjohnson:bandera} is a collection of tools that uses static analysis techniques to extract a finite model from a Java program to feed to select back-end model-checkers.
%
Similar to our approach, Bandera employs flow analysis in order to produce compact models.
%
Unsimilarly, it does not synthesize checkers for runtime monitoring the expressed properties, nor does it natively support higher-order functions.
%
A complete separation of model generation and model-checking also degrades precision, since the more in-depth constraint solving typical model-checkers do can help prune the control-flow space; our approach is amenable to integrated constraint solving and is left to future work.
%%

%%
A technique that specifically targets higher-order languages, higher-order recursion schemes (HORS)~\citep{ianjohnson:Knapik:2002:HPT:646794.704852}, is rooted in simply-typed, call-by-name lambda terms, but has model-checking solutions that have been extended to call-by-value ~\citep{ianjohnson:DBLP:journals/jacm/Kobayashi13} and untyped ~\citep{dvanhorn:Tsukada2010Untyped} languages, through heavy type-theoretic machinery.
%
Model-checking an untyped HORS is undecidable, and such model checkers make various approximations biased to soundly model-check programs in traditional type systems rather than traditional untyped languages.
%
Our technique is lighter weight and more transparently correct since it follows from a systematic transformation of a standard semantics.
%
Additionally, the AAM approach makes extensions to more complex language features straightforward, whereas in HORS one would need to CPS, double CPS, or perform a functional encoding of a new form of data; all of which impose additional proof obligations and points-of-failure for the analysis implementor.
%
Finally, HORS do not synthesize runtime monitors or have a notion of blame, unlike our system.
%%

%%
\paragraph{Behavioral contract verification:}
In the world of static sotware contract verification, there is more closely related work.
%
There have been many successful efforts in the realm of first-order contract verification~\citep{ianjohnson:fahndrich:contracts:2011,ianjohnson:vcc:2009}, but the techniques employed are inherently first-order: the only values are booleans.
%
\citet{ianjohnson:Flanagan:2006:HTC:1111037.1111059}'s notion of hybrid type checking is one way to state the problem: dynamic types are essentially flat contracts, and are treated as subtypes of anything during static checking.
%
If an external theorem prover can prove that the flat contracts always hold, the dynamic checks can be safely removed.
%
\citet{dvanhorn:Xu2012Hybrid} describes a higher-order contract verification system for OCaml by inlining all contract monitors and relying on a system of simplifications further enhanced by an SMT solver to optimize away dynamic checks.
%
\citet{dvanhorn:TobinHochstadt2012Higherorder} use AAM on a module semantics with higher-order contracts and is the most related to this work.
%
However, whereas their work focuses on a concrete semantics for handling unknown values and an external theorem prover to show contract containment, our work focuses on an orthogonal issue of temporal contract monitoring.
%
Our techniques should smoothly integrate with theirs when considering partial programs, and is left to future work (\cref{sec:conclusion}).
%%

%%
\section{Conclusion and future work} \label{sec:conclusion}
%%

%%
We demonstrated that a linguistic construction for monitoring temporal properties of higher-order programs (temporal higher-order contracts) can be transparently abstracted to provide a sound verification algorithm, almost for free, given the AAM approach.
%
Our preliminary evaluation provides evidence that this can be an effective approach to verifying programs with finite protocols, given the right combination of existing analysis machinery.
%
The way forward is clear: build a quality temporal monitoring library and contract a large project to find weaknesses in the language of temporal contracts, and finally evaluate the verification algorithm on this ``more realistic'' example.
%
Potential weaknesses we can identify:
\begin{itemize}
\item{the blame story needs better understanding, with deotonic logic:
%
currently, the party that generates the action that causes a contract to fail gets blamed, and there is no way to express that some action must happen before the end of the monitor's lifetime.
%
The action-emitting party might be innocent, just working at the behest of a different party that is obliged not to violate the contract.
%
Instead of attaching a temporal contract to a single structural contract with the {\tt tmon} form, we instead allow structural contracts to \emph{emit} temporal contracts as obligations of a given party, and additionally blame for unfinished obligations at monitor collection time, end of execution, or after a specified amount of time;
}
%
\item{calls and returns don't match in the temporal contracts themselves:
%
the actions are currently interpreted without a notion of matching, which could turn out to be too flat and limiting for proper specifications --- the implementation from \dfm{} allows labeling calls so that return actions can refer to the matching call.
%
It is unclear whether an analysis can precisely match calls and returns in both the contracts and control-flow, due to the several stacks that apparently entails, but at least a ``good enough'' approximation should exist;
}
%
\item{some specifications are better suited to DLTL or state machines:
%
some examples in \dfm's test suite included using side effects in the temporal monitor's matching to encode state transitions.
To more adequately handle this idiom without sophisticated handling of side-effects, we may wish to mix and match ways in which we express properties.
%
For example, a contract in a different language is considered primitive, and only continues when the contract is accepting (much like sequence contracts work now).
}
%
\item{whole program analysis is intractible at scale:
%
we can verify on a per-module basis if we add temporal contracts to a semantics of partial programs, such as in \citet{dvanhorn:TobinHochstadt2012Higherorder}.
%
The primary difficulty there is a sound definition of {\tt havoc} in the presence of temporal contracts, which simulates all possible interactions with a module.
%
Additional concerns lie in adequately maintaining enough information about unknown values to prune search space, without also exploding the search space with all the distinguished unknown values, but there is existing work on this that we can leverage~\citep{ianjohnson:DBLP:journals/cacm/DilligDA10}.
}
\end{itemize}
%
%
