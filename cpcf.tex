\documentclass[preprint,onecolumn,9pt]{sigplanconf} %{onecol}
\usepackage{alltt,mathpartir,multicol}
\usepackage{amsmath,amsthm,natbib}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{url}
\usepackage{graphicx,color}
\usepackage{anyfontsize}
\usepackage{balance}
\usepackage{calc}
\usepackage[english]{babel}
\usepackage[noabbrev]{cleveref}
\usepackage[hidelinks]{hyperref}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}

\newcommand{\naive}{naive}
\newcommand{\naively}{naively}
\newcommand{\Naive}{Naive}
\newcommand{\Naively}{Naively}
% \usepackage{xltxtra}
% \setmonofont[Scale=MatchLowercase]{DejaVu Sans Mono}
%
\input{preamble}

\begin{document}

\conferenceinfo{WXYZ '05}{date, City.}
\copyrightyear{2005}
\copyrightdata{[to be supplied]}
\title{Static Verification of Temporal Higher-Order Contracts}

\authorinfo{J. Ian Johnson}
           {Northeastern University}
           {ianj@ccs.neu.edu}
\authorinfo{Nicholas Alexander Marquez}
           {Northeastern University}
           {nam@ccs.neu.edu}
\authorinfo{David Van Horn}
           {Northeastern University}
           {dvanhorn@ccs.neu.edu}
\maketitle
\begin{abstract}
  Behavioral contracts allow languages to internalize a notion of ``type checking'' at run time, so that untyped or statically-typed-but-currently-failing-the-type-checker programs can still be run/tested with expected invariants checked on-the-fly.
%
  Contracts go beyond typical type systems because they give full access to the language, allowing expression of strong invariants that a traditional type checker could not verify.
%
  Contract violations during testing or even after deployment help correct both the implementation and specification of software without having to provide a proof of correctness up-front.
%%

%%
  Temporal higher-order contracts provide a language for specifying and dynamically monitoring adhereance to stateful protocols in a higher-order language.
%
  Just as higher-order function contracts internalize an extra-linguistic type-checking process to the dynamic semantics, we claim that temporal contracts internalize the extra-linguistic process of model-checking.
%
  To demonstrate, we propose using abstracting abstract machines (AAM) on a language with temporal higher-order contracts to generate both a finite model and the proof obligations to feed to an off-the-shelf model-checker.
%
  This approach affords us a simple and direct proof of soundness.
\end{abstract}

\section{Introduction}

Software systems are typically large, consist of many modules, and have invariants that are typically inexpressible or too costly to express (and prove) in the language's static type system, if it has one.
%
When this is the case, one might hope to rely on software contracts~\cite{dvanhorn:Findler2002Contracts} to give dynamic guarantees about the behavior of one's system, blaming the correct party responsible for any violation of these invariants.
%
A proposed system of \emph{temporal contracts}~\citep{ianjohnson:dfm:icfp2011} provide a linguistic mechanism to describe temporal properties that usually are checked extra-linguistically via model-checking an abstraction of the program.
%
Example temporal properties are, ``a file can only be closed if it has been opened'' and, ``if function A is given a function B, then B may not be called once A returns.''
%
Such invariants are important for interfaces that have set-up and tear-down protocols to follow.
%%

%%
There are downsides to software contracts, however.
%
If a contract is violated, a blame exception is thrown or the program simply terminates with the error.
%
Contracts do not ensure correctness --- they help the process of constructing correct programs.
%
In addition, contracts can introduce considerable overhead to the program.
%
Just wrapping a function in a contract monitor can disable compiler optimizations, and depending on the level of checking a contract does, the entry and exit of contract boundaries can also take a long time (indeed, we run arbitary programs as such checks!).
%
These are important costs to pay at the beginning of development, but as programs mature, we need a way to safely remove contract checking and have a performance and correctness return on the initial investment.
%%

%%
Temporal contracts pose an additional challenge over higher-order function contracts to statically verify, as they monitor extended interactions with a module, and not just localized pieces.
%
We propose a framework that is composable with techniques to verify functional contracts, that has low technical overhead (no translation to a model-checker's language necessary).
%
The technique uses the Abstracting Abstract Machines (AAM) approach~\citet{dvanhorn:VanHorn2010Abstracting} to check for reachability of a temporal contract blame.
%
The language for temporal contracts closely mimics linear temporal logic (LTL), but distinguishes itself in a way that makes LTL model-checking prohibitive on top of the initial cost of constructing a model to feed an LTL model-checker.
%
Temporal contracts can talk about value flow and use over time via binding in the specification --- this is not something that LTL can locally express.
%
The semantics of temporal contracts also is geared towards checking safety properties, since dynamic liveness checking is undecidable.
%
AAM was originally targeted towards describing flow analyses, but is robust enough to apply to model-checking safety properties of higher-order programs.
%
It is well-known that control-flow analysis can be stated in terms of model-checking, but this observation is misleading; one must use quadratically many model-checking queries to discover what a monovariant flow analysis can discover in one run.
%
The realm of temporal contract verification is similar: to use a model-checker, we would have to run a data-flow analysis up front in order to collect values that might be used as bindings, enumerate all possible binding/reference insantiations of the temporal contract, and then translate those contracts into LTL queries --- much more work than just running the program abstractly and reporting reachable blame states.
%

%%
Our contributions in this paper are as follows:
\begin{itemize}
 \item{an extension to \citeauthor{ianjohnson:dfm:icfp2011}'s temporal contract semantics;}
 \item{a new automaton model that we use to implement the monitor for this new semantics; and}
 \item{a sound abstraction to computably verify temporal contract adhereance}
\end{itemize}
%%

%%
\section{Related Work}
%%

%%
Model-checking and contract verification (proving functional correctness) are huge fields and it is important to view our work in the greater context of these worlds of research.
%
The main separating factor between this work and related work is that all model-checking literature so far has treated the specification of temporal properties as \emph{extra-linguistic}, meaning there is no mechanism in the object language that could monitor for the properties.
%
Contracts are defined by their behavior of witnessing program execution, and thus do not have the same guarantees that a static type system has, such as, ``this function \emph{always} returns an integer when given an integer.''
%
In that vein, temporal contracts can never guarantee liveness properties of a program.
%
\citet{ianjohnson:dthf:complete} show that contracts that simulate types will never violate the guarantee that well-typed programs will never be blamed in a gradually-typed system.
%
Likewise, if we interpret temporal contracts in a stricter fashion --- sequenced events \emph{must} happen --- then in the abstract we can verify liveness properties.
%%

%%
\paragraph{First-order model-checking:}
The SLAM project~\citep{ianjohnson:Ball:2002:SLP:503272.503274} for model-checking C assumes that all function pointers of the same type alias.
%
For C programs that use callbacks heavily, this overapproximation leads to longer checking times due to more (spurious) paths to follow, and the imprecision inherent in any program approximation gets exacerbated by the additional pressure on abstract resources.

\paragraph{Higher-order model-checking:}
Java and C++ both have several high-quality model-checking tools \citep{ianjohnson:bandera, ianjohnson:java-pathfinder, ianjohnson:LLBMC}, some of which are bounded model-checkers, meaning they cannot fully verify temporal properties - only present counter-examples (that may not be true counter-examples).
%
Bandera~\citep{ianjohnson:bandera} is a sophisticated tool-chain that uses several static analysis techniques to extract a finite model from a Java program to feed to various back-end model-checkers.
%
Similar to our approach, Bandera employs control-flow analysis in order to produce compact models, but unsimilarly, the checking mechanisms are not in the control-flow analysis itself.
%%

%%
A technique that specifically targets higher-order languages, higher-order recursion schemes (HORS)~\citep{ianjohnson:Knapik:2002:HPT:646794.704852}, assumes a call-by-name semantics for the language it checks.
%
The current techniques for the initial abstraction of a program to HORS is not generally applicable to untyped or impure languages, since it creates the recursion schemes from the simple types of a given program.
%
HORS can be applied for call-by-value order if the program is first transformed into CPS, since then the intended evaluation order is encoded into call-by-name.
%
This still does not address the need for simple types, and does not apply for languages that cannot be expressed in CPS.

\paragraph{Static contract verification:}
In the world of statically verifying software contracts, there is much more work.
%
There have been many successful efforts in the realm of first-order contract verification~\citep{ianjohnson:fahndrich:contracts:2011,ianjohnson:vcc:2009}, but the techniques employed are inherently first-order: the only values are booleans.
%
\citet{ianjohnson:Flanagan:2006:HTC:1111037.1111059}'s notion of hybrid type checking is one way to state the problem: dynamic types are essentially flat contracts, and are treated as subtypes of anything during static checking.
%
If an external theorem prover can prove that the flat contracts always hold, the dynamic checks can be safely removed.
%
\citet{dvanhorn:Xu2012Hybrid} describe a higher-order contract verification system for OCaml by inlining all contract monitors and relying on a system of simplifications further enhanced by an SMT solver to optimize away dynamic checks.
%
\citet{dvanhorn:TobinHochstadt2012Higherorder} use AAM on a module semantics with higher-order contracts and is the most related to this work; whereas they focus on a concrete semantics for handling unknown values and an external theorem prover to show contract containment, our work focuses on an orthogonal issue of temporal contract monitoring and uses model-checking techniques.
%
Our techniques should smoothly integrate with theirs when considering partial programs, and is left to future work.
%%

%%
\section{Overview of temporal higher-order contracts}
%%

\begin{figure}
  \begin{align*}
    \mscon \in \SContract &::= \sflat(\mexp) \alt \sarr{\mtoplevelname}{\mscon}{\mscon} \alt \sconsc{\mscon}{\mscon}
  \end{align*}
  \caption{Syntax of structural contracts with labels}
  \label{fig:scontract-syntax}
\end{figure}

\begin{figure}
  \begin{align*}
 \mtcon \in \TContract &::=
      \mevent \alt \snonevent{\mevent}
 \alt \stseq{\mtcon}{\mtcon}
 \alt \stnot{\mtcon}
 \alt \stOr{\mtcon}{\mtcon}
 \alt \stmany{\mtcon}
 \alt \sddd \\
&\alt \stcall{\mname}{\mname}{\mtcon}
 \alt \stret{\mname}{\mname}{\mtcon} \\
\mevent \in \Event &::= \scallev{\mvar}{\mvpat} \alt \sretev{\mvar}{\mvpat} \\
\mvpat \in \VPat &::= \mconstant \alt \mvar \alt \swc \\
\mname \in \Name &\text{ an infinite set} \\
\mtoplevelname \in \Label&\text{ an infinite set} \\
\mvar &::= \mname \alt \mtoplevelname
  \end{align*}
  \caption{Syntax of temporal contracts}
  \label{fig:tcontract-syntax}
\end{figure}

Temporal contracts provide a declarative language for monitoring the temporal ordering of events that pass through module boundaries.
%
We analyze a slightly different presentation than ~\citep{ianjohnson:dfm:icfp2011}'s temporal contracts that allows more precise specification of value use.
%
The syntax is presented in \autoref{fig:tcontract-syntax}.
%%

%%
Temporal contracts ($\mtcon$) include events ($\mevent$) (for $\mevent$ction), negated events ($\snonevent{\mevent}$), concatenation ($\stseq{\mtcon}{\mtcon}$) (often represented using juxtaposition), negated contracts ($\stnot{\mtcon}$), Kleene closure of events ($\stmany{\mtcon}$), union ($\stOr{\mtcon}{\mtcon}$), the universal temporal contract ($\sddd$), and higher-order binding events ($\stcall{\mname}{\mname}$ and $\stret{\mname}{\mname}$).
%
The difference between $\snonevent{\mevent}$ and $\stnot{\mtcon}$ is that the first must be an event and force time to step forward once, whereas the second may match arbitrarily many events.
%%

%%
Events themselves are expressed as patterns denoting calls ($\scallev{\mvar}{\mvpat}$) or returns ($\sretev{\mvar}{\mvpat}$), with respect to a particular function $\mvar$ and with its argument or result matching a pattern $\mvpat$.
%
If $\mvar$ is a label, we simply check that the monitor wrapping the function has the same label (attached via the structural contract).
%
However, if $\mvar$ is a name, then we consult a binding environment that the monitoring system builds as we pass binding events to determine if the function is exactly equal to the value bound.
%
The distinction between names (bound by temporal contract) and labels (bound by structural contract) is what separates our semantics from \citeauthor{ianjohnson:dfm:icfp2011}'s.
%
Patterns can match constants ($\mconstant$), bound names ($\mname$), labeled functions ($\mtoplevelname$), or simply anything ($\swc$).
%%

%%
\citeauthor{ianjohnson:dfm:icfp2011}'s semantics for referring to functions is problematic; we give a slightly different account that captures the spirit of their prose describing their system.
%
One of their motivating examples (recalled in \autoref{fig:sort} and addressed in \autoref{sec:sort}) was to protect the comparator passed to a sort function from escaping the scope of the call.
%
What this should mean is the particular binding introduced by a call to $sort$ cannot be called after $sort$ returns, \ie, each constructed monitor around given comparators should not be called after $sort$ returns.
%
However, the flat use of \emph{labels} instead of bindings causes a second call to an in-spirit-correct $sort$ to fail, since it internally calls the comparator of the same label, but different monitor construction.
%
We maintain the semantics of labels in order to discuss top-level bindings of a module, but encourage the use of binding for contracting the use of first-class functions.
%%

%%
\subsection{Sort example} \label{sec:sort}

\renewcommand{\arraystretch}{1.2}
\newcommand{\call}[1]{\scallev{#1}{\_}}
\newcommand{\ret}[1]{\sretev{#1}{\_}}
\begin{figure}
 \small
 $SortContract = $ \\
 $\begin{array}{ @{\quad~}l@{\ } c @{\ }l }
 sort &:   &(cmp\ :\ Pos\ \to Pos\ \to\ Bool) \\
      &    &(List\ Pos) \\
      &\to &(List\ Pos) \\
 \end{array}$
 $\begin{array}{ @{\quad~}r@{~} l @{}l }
  \text{where}\quad
  &\stnot{(&\sddd~ \call{sort}~ \stmany{\snonevent{\ret{sort}}}~ \call{sort})} \\
  \text{and}\quad
  &\stnot{(&\sddd~ \scallev{sort}{?cmp}~ \sddd~ \ret{sort} \sddd~ \call{cmp})}
 \end{array}$
 \caption{Sort example}
 \label{fig:sort}
\end{figure}

%%
In \autoref{fig:sort} we show the contract for a hypothetical $sort$ function which takes two arguments: a comparator and a list (of positive numbers).
%
The notation ``$name\ :\ Domain\ \to\ Range$'' describes a function contract where the argument satisfies the $Domain$ contract and the result satisfies the $Range$ contract.
%
The ``$name\ :$'' prefix denotes the name of the function, for use in the temporal aspect of the contract.
%%

%%
$SortContract$ is also has a temporal component, given by the ``where'' clauses following its structural (function) contract.
%
The first of these clauses states that a second call to $sort$ may not occur (hence the negation of the trace) if there is no intervening return from $sort$ ($\stmany{\snonevent{\ret{sort}}}$).
%
This is specifying a particular safety property (as evidenced by the negation of the trace): $sort$ is supposed to be \emph{non-reentrant}.
%
The second temporal clause specifies a higher-order property; it states that, given a call to $sort$, its associated $cmp$ argument cannot be called after $sort$ returns.
%%

\subsection{File example}

\begin{figure}
 \small
 $FileSystemContract\, =\, open\, :\, String\, \to\, FileContract$ \\
 $FileContract =~ Record$ \\
 $\begin{array}{ @{\quad~}l@{\ :} @{~}l@{\ \to\ } l }
  read & Unit & String \\
  write & String & Unit \\
  close & Unit & Unit
 \end{array}$
 \begin{flalign*}
  \text{where}\quad
  \stnot{(&\sddd~ \ret{close}~ \sddd~ \\
  &(\stOr{\call{close}}{\stOr{\call{read}}{\call{write}}}))}
 \end{flalign*}
 \caption{File example}
 \label{fig:file}
\end{figure}

%%
In \autoref{fig:file} we show the contract for a hypothetical file system, which can be used to open files by giving the $open$ function a filename (a $String$); we are then given a file handle contracted by $FileContract$.
%
A file handle, in turn, is a record of functions which interact with the file: $read$, $write$, and $close$, all which perform the expected behaviors.
%%

%%
The temporal contract states that a user of the file is forbidden from making use of the file handle (through the use of its component functions) after the user has $close$d the file.
%%

\subsection{TCP example}

\newcommand{\tcpstyle}[1]{\texttt{#1}}
\begin{figure}
 \newcommand{\send}[1]{\scallev{send}{#1}}
 \newcommand{\rcv}[1]{\sretev{recv}{#1}}
 \newcommand{\notclose}{\snonevent{\call{close}}}
 \newcommand{\tcpsyn}{\tcpstyle{SYN}}
 \newcommand{\tcpack}{\tcpstyle{ACK}}
 \newcommand{\tcpsynack}{\tcpstyle{SYN\&ACK}}
 \newcommand{\tcpfin}{\tcpstyle{FIN}}
 %\newcommand{\tcpfinack}{\tcpstyle{FIN\&ACK}}
 \small
 $TCPConnectionContract\, =~ Record$ \\
 $\begin{array}{ @{\quad~}l@{\ :} @{~}l @{\ \to\ }l }
  open & TCPSocket & TCPSendContract \\
  listen & TCPSocket & TCPRecvContract
 \end{array}$ \\
 $TCPData =$
 $~ \tcpsyn \mid \tcpack \mid \tcpsynack \mid \tcpfin \mid \tcpstyle{Data}(\_)$
 
 $TCPConnection =~ Record$ \\
 $\begin{array}{ @{\quad~}l@{\ :} @{~}l@{\ \to\ } l }
  send & TCPData & Unit \\
  recv & Unit & TCPData \\
  timeout & Duration & Unit \\
  close & Unit & Unit
 \end{array}$ \\
 
 $TCPSendContract =~ TCPConnection$ \\
 $\begin{array}{ @{\quad~}r@{~} l @{}l }
  \text{where}
  &&\sddd~ \send{\tcpsyn}~ \notclose \\
  &&\rcv{\tcpsynack}~ \notclose \\
  &&\send{\tcpack}~ \stmany{\notclose} \\

  &&\cup
  \begin{aligned}
   &\left(
    \begin{aligned}
     &\rcv{\tcpfin}~ \send{\tcpack} \\
     &\send{\tcpfin}~ \rcv{\tcpack}
    \end{aligned}
   \right) \\
   &\left(
    \begin{aligned}
     &\call{close}~ \send{\tcpfin} \\
     &\rcv{\tcpack}~ \rcv{\tcpfin}~ \send{\tcpack}
    \end{aligned}
   \right)
  \end{aligned} \\
  &&\ret{timeout}~ \ret{close} \\
  
  \text{and}
  &\stnot{(&\sddd~ \ret{close}~ \sddd~ \\
  &&(\stOr{\call{send}}{\stOr{\call{recv}}{\call{close}}}))}
 \end{array}$
 
 $TCPRecvContract =~ TCPConnection$ \\
 $\begin{array}{ @{\quad~}r@{~} l @{}l @{}l }
  \text{where}
  &&\sddd~ \rcv{\tcpsyn}~ \notclose \\
  &&\send{\tcpsynack}~ \notclose \\
  &&\rcv{\tcpack}~ \stmany{\notclose} \\
  
  &&\cup
  \begin{aligned}
   &\left(
    \begin{aligned}
     &\call{close}~ \send{\tcpfin} \\
     &\rcv{\tcpack}~ \rcv{\tcpfin}~ \send{\tcpack}
    \end{aligned}
   \right) \\
   &\left(
    \begin{aligned}
     &\rcv{\tcpfin}~ \send{\tcpack} \\
     &\call{close}~ \send{\tcpfin}~ \rcv{\tcpack}
    \end{aligned}
   \right)
  \end{aligned} \\
  &&\ret{timeout}~ \ret{close} \\
  
  \text{and}
  &\stnot{(&\sddd~ \ret{close}~ \sddd~ \\
  &&(\stOr{\call{send}}{\stOr{\call{recv}}{\call{close}}}))}
 \end{array}$
 
 \caption{TCP example}
 \label{fig:tcp}
\end{figure}

% TODO: Source this from WP
\begin{figure}
 \centering
 \fontsize{4}{5} \selectfont
 \def \svgwidth{\columnwidth}
 \input{tcp-fsm.pdf_tex}
 \caption{Simplified TCP FSM for \autoref{fig:tcp}}
 \label{fig:tcp-fsm}
\end{figure}

%%
In \autoref{fig:tcp} we show the contract for a hypothetical TCP connection module.
%
A client of this module may $open$ a $TCPSocket$ for initiating a connection or may $listen$ to a $TCPSocket$ for passively connecting.
%
A $TCPConnection$ is defined similarly to our file system example: it is a record of functions which interact with the connection: $send$, $recv$, $timeout$, and $close$.
%
Notably, $send$ and $recv$ interact with data in the form of $TCPData$, which can be one of the special packets used in the TCP protocol or can simply be some amount of user data ($\tcpstyle{Data}(\_)$).
%
%TODO: maybe express timing out in a better manner?
The $timeout$ function is simply internally used by the module to set timeouts for interactions with the other end of the TCP connection; clients do not directly use it and it is included solely for the ability to reason over timeouts in the temporal contract.
%%

%%
A socket on the ``sending'' end of the TCP connection (having used $open$) is obligated to use the connection according to the temporal component of $TCPSendContract$.
%
Likewise, a socket on the ``receiving'' end of the TCP connection (having used $listen$) is constrained by $TCPRecvContract$.
%
The contracts are very involved, but they implement a simplified version of the TCP connection lifecycle given in \autoref{fig:tcp-fsm}.
%
Note that the first temporal clause in each contract is \emph{not} negated; this indicates that it specifies a \emph{liveness property}: that the client uses the socket in a manner consistent with the TCP protocol and can expect the other end to as well.
%%

%%
\section{Semantics of Temporal Contracts}
%%

%%
Now that we have a clear view of the behavior of temporal contracts, we nail down a formal semantics that we use to prove the soundness of our later model-checking approach to verification.
%
The semantics we present is in the style of Felleisen's reduction semantics~\citep{ianjohnson:Felleisen:2009:SEP:1795772}, which can be systematically transformed into an abstract machine in the form presented in~\citet{dvanhorn:VanHorn2010Abstracting}.
%
{\bf TODO (Alex):} Reduction semantics that stores calling function in context.
%
See \autoref{sec:technical} for now.
%%

%%
As noted in \autoref{sec:sort}, temporal contracts are associated with structural contracts that name function components within them.
%
For simple exposition, we will consider tuples as the main organizational tool for contracting the interactions between multiple functions.
%
Since we consider monitor constructions as a more basic notion of equality, we also see each temporal monitor construction as starting its own ``timeline,'' which sees its own filtered view of events in the system.
%
Thus, as values flow through contract boundaries, they are considered on different timelines.
%
Disney et. al formalized their semantics in terms of a nondeterministic machine that defined its interactions on all event streams, and thus their machine was on a single ``timeline.''
%
The semantics of temporal contracts that we propose uses pointer-equality of monitors for comparisons of non-primitive data, which is why we consider our account to be more operational.
%
Our semantics that makes interaction between temporal contract monitors explicit, so we can verify whole programs.
%%

%%
We denote temporal contracts as sets of event traces that satisfy the contract, all parameterized by which timeline the on which the events occur.
%
The semantics is close to \citeauthor{ianjohnson:dfm:icfp2011}'s definition, and given in \autoref{fig:tcontract-denotation}.
%
\begin{figure}
  \begin{align*}
   \denotetcon{\mevent}{\mtimeline}{\menv} &=
   \denoteevent{\mevent}{\menv}{\mtimeline}
\\
   \denotetcon{\stseq{\mtcon_0}{\mtcon_1}}{\mtimeline}{\menv} &=
   \setbuild{\mtrace_0 \cdot \mtrace_1}{\mtrace_0 \in \denotetcon{\mtcon_0}{\mtimeline}{\menv}, \mtrace_1 \in \denotetcon{\mtcon_1}{\mtimeline}{\menv}}
\\   
   \denotetcon{\stnot{\mtcon}}{\mtimeline}{\menv} &=
   \Traces^\mtimeline \setminus \denotetcon{\mtcon}{\mtimeline}{\menv}
\\
   \denotetcon{\stOr{\mtcon_0}{\mtcon_1}}{\mtimeline}{\menv} &=
   \denotetcon{\mtcon_0}{\mtimeline}{\menv} \cup \denotetcon{\mtcon_1}{\mtimeline}{\menv}
\\
   \denotetcon{\stmany{\mtcon}}{\mtimeline}{\menv} &=
   \setbuild{\mtrace^i}{i \le \omega, \mtrace \in \denotetcon{\mtcon}{\mtimeline}{\menv}}
\\
   \denotetcon{\sddd}{\mtimeline}{\menv} &=
   \Traces^\mtimeline
\\
   \denotetcon{\stcall{\mname}{\mname'}{\mtcon}}{\mtimeline}{\menv} &=
   \setbuild{\apvcall{\menv(\mname)}{\mval}{\mtimeline}\cdot \mtrace}{\mtrace \in \denotetcon{\mtcon}{\mtimeline}{\menv[\mname' \mapsto \mval]}}
\\
   \denotetcon{\stcall{\mtoplevelname}{\mname'}{\mtcon}}{\mtimeline}{\menv} &=
   \setbuild{\aptopcall{\mtoplevelname}{\mval}{\mtimeline}\cdot \mtrace}{\mtrace \in \denotetcon{\mtcon}{\mtimeline}{\menv[\mname' \mapsto \mval]}}
\\
\\
   \denotetcon{\stret{\mname}{\mname'}{\mtcon}}{\mtimeline}{\menv} &=
   \setbuild{\apvret{\menv(\mname)}{\mval}{\mtimeline}\cdot \mtrace}{\mtrace \in \denotetcon{\mtcon}{\mtimeline}{\menv[\mname' \mapsto \mval]}}
\\
   \denotetcon{\stret{\mtoplevelname}{\mname'}{\mtcon}}{\mtimeline}{\menv} &=
   \setbuild{\aptopret{\mtoplevelname}{\mval}{\mtimeline}\cdot \mtrace}{\mtrace \in \denotetcon{\mtcon}{\mtimeline}{\menv[\mname' \mapsto \mval]}}
  \end{align*}
  \caption{Denotation of Temporal Contracts}
  \label{fig:tcontract-denotation}
\end{figure}
\section{Approximation of Temporal Contracts into LTL}
%%

%%
We choose linear temporal logic as our target due to linear behavior of temporal contract monitoring.
%
The syntax of core LTL is in \autoref{fig:ltl-syntax}, but we use some definable constructs for brevity.
%
\begin{figure}
  \begin{align*}
    \ltlprop \in \LTLProp &::= \ltlTrue \alt \ltlatom \alt \ltlor{\ltlprop}{\ltlprop} \alt \ltlnot{\ltlprop} \alt \ltlnext{\ltlprop} \alt \ltluntil{\ltlprop}{\ltlprop}
\\
    \ltlatom \in \ltlAP & \text{ a finite set of atomic propositions}
  \end{align*}
  \caption{Syntax of LTL}
  \label{fig:ltl-syntax}
\end{figure}
LTL only has a finite set of atomic proposisitions for states, so there is no hope for a fully precise account for the binding across states.
%
We instead have to enumerate the concrete propositions on instantiations of the bindings.
%
Binding implicitly requires equality, so we must treat (possible) references conservatively.
%
We can use our control-flow analysis to limit how many instantiations we need to do.
%
The temporal concatenation operator cannot be translated structurally since bindings in the left contract can have references in the right contract.
%
Thus, our translation function takes the contract to translate, the result of the flow analysis, an accumulator for temporal contracts that ``happen next,'' and an environment of bindings.
%%

%%
The atomic propositions we use for checking the temporal contracts are much like the events defined in the temporal contract grammar, except we have additional information about which timeline they appear on.
%%

\begin{align*}
  \denoteevent{\scallev{\mtoplevelname}{\mvpat}}{\menv}{\mtimeline} &=
    % XXX: names are shared across module boundaries
    \setbuild{\aptopcall{\mtoplevelname}{\mval}{\mtimeline'}}
             {\mval \in \denotevpat{\mvpat}{\menv}}
    \\ &\cup
    \setbuild{\apvcall{\blclos{\mtoplevelname}{\mmlab_u}{\mmlab_c}{\mlab}{\mscon_D}{\mscon_R}{\menv'}{\mtimeline}{\maddr}}{\mval'}{\mtimeline'}}
             {\mval' \in \denotevpat{\mvpat}{\menv}}
\\
  \denoteevent{\scallev{\mname}{\mvpat}}{\menv}{\mtimeline} &=
    \setbuild{\apvcall{\menv(\mname)}{\mval'}{\mtimeline'}}
            {\mval' \in \denotevpat{\mvpat}{\menv}}
\\
  \denoteevent{\sretev{\mtoplevelname}{\mvpat}}{\menv}{\mtimeline} &=
    % XXX: names are shared across module boundaries
    \setbuild{\aptopret{\mtoplevelname}{\mval}{\mtimeline'}}
             {\mval \in \denotevpat{\mvpat}{\menv}}
    \\ &\cup
    \setbuild{\apvret{\blclos{\mtoplevelname}{\mmlab_u}{\mmlab_c}{\mlab}{\mscon_D}{\mscon_R}{\menv'}{\mtimeline}{\maddr}}{\mval'}{\mtimeline'}}
             {\mval' \in \denotevpat{\mvpat}{\menv}}
\\
  \denoteevent{\sretev{\mname}{\mvpat}}{\menv}{\mtimeline} &=
    \setbuild{\apvret{\menv(\mname)}{\mval'}{\mtimeline'}}
            {\mval' \in \denotevpat{\mvpat}{\menv}}
%%
\\[2pt]
%%
  \denotevpat{\mname}{\menv} &= \setof{\menv(\mname)}
\\
  \denotevpat{\mconstant}{\menv} &= \setof{\mconstant}
\\
  \denotevpat{\swc}{\menv} &= \Value
\end{align*}

All states that match the atomic propositions are appropriately labeled: \\
$
\begin{array}{l}
 \labelof(\co{\spush{\kmcall{\mmlab_u}{\mmlab_c}{\mlab}{\mscon_R, \mtimeline, \menv, \mtoplevelname, \maddr}}{\mkaddr}, \mval, \msto}{\msmlab}{\mstimeline})
  =\\
 \quad \mtcon \cup \setbuild{\apneg{\mevent}}{\mevent \in (\ltlactions \setminus \mtcon)}
 \\ \text{where } \mtcon = \setbuild{\aptopcall{\mtoplevelname}{\mval'}{\mtimeline},\\
                                     \phantom{\text{where } \mtcon = \{}\apvcall{\blclos{\mtoplevelname}{\mmlab_?}{\mmlab_c}{\mlab}{\mscon_?}{\mscon_R}{\menv}{\mtimeline}{\maddr}}{\mval'}{\mtimeline}}
                                       {\mval' \sqsupseteq \mval}
\\
 \labelof(\co{\spush{\krt{\mmlab',\mtimeline'}}{\mkaddr}, \mval, \msto}{\mtoplevelname}{\mstimeline}) =\\
 \quad \mtcon \cup \setbuild{\apneg{\mevent}}{\mevent \in (\ltlactions \setminus \mtcon)}
 \\ \text{where } \mtcon = \setbuild{\aptopret{?}{\mval'}{\mstimeline},
                                        \apvret{?}{\mval'}{\mstimeline}}
                                       {\mval' \sqsupseteq \mval}
\end{array}$
\\
This familiar definition matches the semantics of temporal contracts closely, allowing a smooth and easy proof of soundness.

The translation of temporal constracts to LTL propositions is in figure \autoref{fig:translation} with type
\begin{align*}
{\scriptsize \toltl{\_}{\_}{\_}{\_}{\_}} &{\scriptsize : \Timeline \times \TContract \times \Graph \times \Env \times \TConEnvStack}\\ & {\scriptsize \to \LTLProp}
\end{align*}
%
where $\TConEnvStack$ is a stack of temporal contract, environment pairs that keep track of which temporal contracts must follow the current temporal contract:
%
\begin{equation*}
  \TConEnvStack = (\TContract \times \Env)^*
\end{equation*}
%
Because LTL lacks a modality for ``a trace matching $\psi$ follows a trace matching $\phi$,'' and is instead more closely tied to individual states, we have to carry a stack of contracts that must follow one after another.
%
This lack of expressivity led to our restriction of the Kleene star operator to single events rather than general temporal contracts.
%
The graph we use is a finite abstraction of the programming language semantics for the program in question.
%
It is implicitly rooted at the entry-point of the program.
%%

%%
\begin{figure}
  \begin{align*}
   \toltl{\mtimeline}{\mevent}{\mgraph}{\menv}{\mtestack} &=
     \ltland{\denoteevent{\mevent}{\menv}{\mtimeline}}
            {\ltlnext{\stacktoltl{\mtimeline}{\mtestack}{\mgraph}}}
    \\
    \toltl{\mtimeline}{\snonevent{\mevent}}{\mgraph}{\menv}{\mtestack} &=
      \ltland{\apneg{\denoteevent{\snonevent{\mevent}}{\menv}{\mtimeline}}}
             {\ltlnext{\stacktoltl{\mtimeline}{\mtestack}{\mgraph}}}
    \\
    \toltl{\mtimeline}{\stnot{\mtcon}}{\mgraph}{\menv}{\mtestack} &=
      \ltlnot{\toltl{\mtimeline}{\mtcon}{\mgraph}{\menv}{\mtestack}}
    \\
    \toltl{\mtimeline}{\stOr{\mtcon_0}{\mtcon_1}}{\mgraph}{\menv}{\mtestack} &=
      \ltlor{\toltl{\mtimeline}{\mtcon_0}{\mgraph}{\menv}{\mtestack}}
            {\toltl{\mtimeline}{\mtcon_1}{\mgraph}{\menv}{\mtestack}}
    \\
    \toltl{\mtimeline}{\stseq{\mtcon_0}{\mtcon_1}}{\mgraph}{\menv}{\mtestack} &=
      \toltl{\mtimeline}{\mtcon_0}{\mgraph}{\menv}{\cons{(\mtcon_1,\menv)}{\mtestack}}
    \\
    \toltl{\mtimeline}{\stmany{\mtconNoB}}{\mgraph}{\menv}{\mtestack} &=
      \ltlW{\toltl{\mtimeline}{\mtconNoB}{\mgraph}{\menv}{\emptytestack}}{\stacktoltl{\mtimeline}{\mtestack}{\mgraph}}
    \\
    \toltl{\mtimeline}{\stcall{\mname}{\mname'}{\mtcon}}{\mgraph}{\menv}{\mtestack} &=
      \bigwedge\limits_{(\ltlprop,\menv') \in \matchcall(\mname,\mname',\menv,\mgraph)}{
        \mkern-60mu\ltland{\ltlprop}{\ltlnext{\stacktoltl{\mtimeline}{\cons{(\mtcon,\menv')}{\mtestack}}{\mgraph}}}}
    \\
    \toltl{\mtimeline}{\stret{\mname}{\mname'}{\mtcon}}{\mgraph}{\menv}{\mtestack} &=
      \bigwedge\limits_{(\ltlprop,\menv') \in \matchret(\mname,\mname',\menv,\mgraph)}{
        \mkern-60mu\ltland{\ltlprop}{\ltlnext{\stacktoltl{\mtimeline}{\cons{(\mtcon,\menv')}{\mtestack}}{\mgraph}}}}
    \\
      \toltl{\mtimeline}{\sddd}{\mgraph}{\menv}{\mtestack} &= \stacktoltl{\mtimeline}{\mtestack}{\mgraph}
%%
\\[2pt]
%%
    {\scriptsize \stacktoltl{\_}{\_}{\_} : \Timeline \times \TConEnvStack \times \Graph \to \LTLProp} \span\omit
\\
    \stacktoltl{\mtimeline}{\emptytestack}{\mgraph} &= \ltlTrue
\\
    \stacktoltl{\mtimeline}{\cons{(\mtcon,\menv)}{\mtestack}}{\mgraph} &=
      \toltl{\mtimeline}{\mtcon}{\mgraph}{\menv}{\mtestack}
  \end{align*}
  
  \caption{Translation of temporal contracts to LTL}
\label{fig:translation}
\end{figure}
%%

%%
All points in the abstract state space that match the binding call/return forms will contribute their bindings to the environment for interpreting the rest of the contract.
%
Since CFA abstracts bindings, we can't always be certain we have exact equality when looking up bindings, too.
%%

\begin{align*}
  \matchcall_\mtimeline(\mtoplevelname, \mname', \mgraph, \menv) &=
    \setbuild{(\ltlprop, \menv[\mname' \mapsto \mval])}
             {\mnode \in \mgraph\\
               &\wedge \ltlprop:=\aptopcall{\mtoplevelname}{\mval}{\mtimeline} \in \labelof(\mnode)}
\\
  \matchcall_\mtimeline(\mname, \mname', \mgraph, \menv) &=
    \setbuild{(\ltlprop, \menv[\mname' \mapsto \mval])}
             {\mnode \in \mgraph\\
               &\wedge \ltlprop:=\apvcall{\menv(\mname)}{\mval}{\mtimeline} \in \labelof(\mnode)}
%
\\[2pt]
  \matchret_\mtimeline(\mtoplevelname, \mname', \mgraph, \menv) &=
    \setbuild{(\ltlprop, \menv[\mname' \mapsto \mval])}
             {\mnode \in \mgraph\\
               &\wedge \ltlprop:=\aptopret{\mtoplevelname}{\mval}{\mtimeline} \in \labelof(\mnode)}
\\
  \matchret_\mtimeline(\mname, \mname', \mgraph, \menv) &=
    \setbuild{(\ltlprop, \menv[\mname' \mapsto \mval])}
             {\mnode \in \mgraph\\
               &\wedge \ltlprop:=\apvret{\menv(\mname)}{\mval}{\mtimeline} \in \labelof(\mnode)}
\end{align*}

Denotations of program actions restricted to a particular timeline:
\begin{align*}
  \denote{\mexp}_\mtimeline &= \filter(\mathit{AP}_\mtimeline, \traces(\mexp)) \\
  \mathit{AP}_\mtimeline(\mstate) &= \setbuild{\ltlprop}{\ltlprop \in \labelof(\mstate), \ltlprop \text{ matches }\\
                               &\qquad\aptopcall{\_}{\_}{\mtimeline} \vee \apvcall{\_}{\_}{\mtimeline} \vee \aptopret{\_}{\_}{\mtimeline} \vee \apvret{\_}{\_}{\mtimeline}} \\
  \traces(\mexp) &= \gfp{{\mathcal F}} \\
  \text{where } {\mathcal F}(S) &= S \cup \setof{\inject(\mexp)} \cup \setbuild{\mtrace \mstate \mstate'}{\mtrace \mstate \in S, \mstate \machstep \mstate'}
\end{align*}

Paths through a graph are defined as the greatest fixed point of these two rules:
\begin{mathpar}
  \inferrule{ }{\inject(e) \in \paths(\mgraph)}\quad
  \inferrule{\mtrace\mstate \in \paths(\mgraph) \\
             (\mstate, \mstate') \in \mgraph.E}
            {\mtrace\mstate\mstate' \in \paths(\mgraph)}
\end{mathpar}

\begin{theorem}
  If $\alpha(\denote{\mexp}_\mtimeline) \sqsubseteq \filter(\mathit{AP}_{\matimeline}, \paths(\mgraph))$,
     $\alpha(\menv) \sqsubseteq \maenv$,
     $\alpha(\mtimeline) \sqsubseteq \matimeline$, and
     $\alpha(\overline{(\mtcon_\mtestack, \menv_\mtestack)}) \sqsubseteq \mtestack$
  then
  $\alpha(\denote{\mexp}_\mtimeline \cap \denotetcon{\mtcon}{\mtimeline}{\bot}) \sqsubseteq \denote{\toltl{\matimeline}{\mtcon}{\mgraph}{\maenv}{\mtestack}}$
\end{theorem}

\section{Design for a reflective model checker}
%%

%%
Ya... if we actually do this.
%%

%%
\section{Evaluation}
%%

%%
Our examples didn't take hours to check!
%
Our model is available online \footnote{\url{http://github.com/ianj/temporal-aam}}.
%%

%%
\section{Conclusion}
%%

%%
Shit works.
%%

%%
\section{Everything Technical}\label{sec:technical}

%%
Syntax:
\begin{align*}
\mexp \in \Expr &::=
      \svar[^\mlab]{\mvar}
 \alt \sapp[^\mlab]{\mexp}{\mexp}
 \alt \slam[^\mlab]{\mvar}{\mexp} \\
&\alt \sif[^\mlab]{\mexp}{\mexp}{\mexp} 
 \alt \sSMon{\mmlab}{\mmlab}{\mlab}{\mcontract, \mexp}
 \alt \sTMon{\mmlab}{\mmlab}{\mlab}{\mscon, \mexp}
 \alt \slit{\mconstant} \\
\mconstant \in \Constant &= -1 \alt 0 \alt 1 \alt \ldots \alt \strue \alt \sfalse \alt \scons \alt \scar \alt \ldots \\
\mvar \in \Var &\quad\text{ an infinite set} \\
\mlab \in \Label &\quad\text{ an infinite set} \\
\mmlab,\mname \in \ModuleLabel &\text{ an infinite set} \\
\msmlab \in \ModuleLabel^{\toplevel} &::= \mmlab \alt \toplevel \\
\mcontract \in \Contract &= \SContract \times \TContract \\
\mscon \in \SContract &::= \sflat{\mexp} \alt \sarr{\mname}{\mscon}{\mscon} \alt \sconsc{\mscon}{\mscon} \\
\end{align*}
%%

%%
Wrapping monitors around values associates entirely fresh NFA states.
%
The names given to bindings are really associated with the bindings.
%
We have to give up some precision for decidability --- we use a monovariant allocation scheme for monitor allocation.
%
This scheme allows us to lift all textual temporal contracts to the top level and check individually.
%
A polyvariant scheme would require either knowing how many abstract bindings are allocated during execution, or an exhaustive enumeration of possible bindings as propositions to check.
%
Since we run CFA before appealing to the model checker, the former is feasible, but it distracts from the overall exposition.
%%

%%
Value space:
\begin{align*}
  \mval \in \Value &=
    \clos{\mvar, \mexp, \menv}
   \alt \blclos{\mname}{\mmlab}{\mmlab}{\mlab}{\mscon}{\mscon}{\menv}{\mtimeline}{\maddr}
   \alt \mconstant \\
%   \alt \blackhole \\
&  \alt \vconsf{\maddr}{\mstimeline}
   \alt \vcons{\maddr}{\maddr}
   \alt \vconst{\maddr}{\maddr}{\mstimeline}
   \alt \sunit \\
  \menv \in \Env &= \Var \parto (\Addr \times \Timeline^{\toplevel}) \\
  \maddr \in \Addr &\text{ an infinite set} \\
  \mstimeline \in \Timeline^{\toplevel} &::= \maddr \alt \toplevel \\
  \mnames &\in \wp(\Var) \\
\end{align*}
%%

%%
State space:
\begin{align*}
  \mstate \in \State &::=
      \ev[^\mlab]{\mexp, \menv, \msto, \mkont}{\msmlab}{\mstimeline}
 \alt \co{\mkont, \mval, \msto}{\msmlab}{\mstimeline} \\
&\alt \ap[^\mlab]{\mval, \mval, \msto, \mkont}{\msmlab}{\mstimeline}
 \alt \ck{\mmlab}{\mmlab}{\mlab}{\pm}{\mscon, \maddr, \menv, \mval, \msto, \mkont}{\msmlab}{\mstimeline}
 \alt \sblame{\mmlab} \\
\msto \in \Store &= \Addr \parto \wp(\Storeable) \\
\Storeable &= \Value + \Kont + \TContract \\
\mframe \in \Frame &::=
      \kar[^\mlab]{\mexp,\menv}
 \alt \kfn[^\mlab]{\mval}
 \alt \kif{\mexp, \mexp, \menv} \\
&\alt \krt{\mmlab, \mtimeline}
 \alt \kmon{\mmlab}{\mmlab}{\mlab}{\mscon, \mtimeline, \menv}
 \alt \kflat[^\mlab]{\mmlab, \mval} \\
&\alt \kchkA[^\mlab]{\mmlab, \mmlab, \mscon, \maddr, \maddr, \maddr}
 \alt \kchkD[^\mlab]{\mmlab, \mmlab, \maddr, \maddr, \maddr, \maddr}
 \alt \kcheck[^\mlab]{\mmlab, \mval} \\
&\alt \kpost[^\mlab]{\mscon, \mtimeline, \menv}
 \alt \kmcall{\mmlab}{\mmlab}{\mlab}{\mscon, \mtimeline, \menv, \mname, \maddr} \\
\mkont \in \Kont &::= \kmt \alt \spush{\mframe}{\mkaddr}
\end{align*}

% \begin{align*}
%     \accept &: \ModuleLabel \times \ModuleLabel \times \Label \times \SContract \times \Value \\
%             &\to (\Value \times \Store) + \Expr + \bot
% \end{align*}
% \begin{align*}
%   \accept(\mmlab_u, \mmlab_c, \mlab, \sarr{\mname}{\mscon_D}{\mscon_R}, \mval) &=
%           \blclos{\mname}{\mmlab_u}{\mmlab_c}{\mlab}{\mscon_D}{\mscon_R}{\menv}{\maddr}, \\
% \phantom{\accept(\mmlab_u, \mmlab_c, \mlab, \sarr{\mname}{\mscon_D}{\mscon_R}, \mval)} &\phantom{= }
%           \ext{\msto}{\maddr}{\setof{\mval}} \\
%   \text{if } \mval \equiv \clos{\mvar, \mexp, \menv'} \text{ or }&
%              \mval \equiv \blclos{\mname'}{\mmlab_u'}{\mmlab_c'}{\mlab'}{\mscon_D'}{\mscon_R'}{\menv'}{\maddr'}
%   \\
%   \accept(\mmlab_u, \mmlab_c, \mlab, \sflat(\mexp), \mval) &= \mexp \\
%   \accept(\mmlab_u, \mmlab_c, \mlab, \sarr{\mname}{\mscon_D}{\mscon_R}, \mval) &= \bot \text{ otherwise}
% \end{align*}

\begin{figure*}
  \begin{gather*}
    \begin{array}{@{}r@{\ }c@{\ }l@{}}
      \mstate & \machstep &\mstate' \text{ defined to be the following} \\
      %% EVAL
      \ev{\svar\mvar, \menv, \msto, \mkont}{\msmlab}{\mstimeline} &\machstep&
      \co{\mkont, \mval, \msto}{\msmlab}{\mstimeline}
      \text{ if } (\maddr, \mstimeline') = \menv(\mvar), \mval \in \msto(\maddr)
      \\
    %%
      \ev{\sapp[^\mlab]{\mexpi0}{\mexpi1}, \menv, \msto, \mkont}{\msmlab}{\mstimeline} &\machstep&
      \ev{\mexpi0, \menv, \msto', \spush{\kar[^\mlab]{\mexpi1, \menv}}{\mkaddr}}{\msmlab}{\mstimeline}
      \\
      &&\text{where } \mkaddr = \alloc(\mstate) \\
      &&\phantom{\text{where }} \msto' = \ext{\msto}{\mkaddr}{\setof{\mkont}} \\
      %%
      \ev{\sif{\mexpi0}{\mexpi1}{\mexpi2}, \menv, \msto, \mkont}{\msmlab}{\mstimeline} &\machstep&
      \ev{\mexpi0, \menv, \msto', \spush{\kif{\mexpi1, \mexpi2, \menv}}{\mkaddr}}{\msmlab}{\mstimeline} \\
      &&\text{where } \mkaddr = \alloc(\mstate) \\
      &&\phantom{\text{where }} \msto' = \ext{\msto}{\mkaddr}{\setof{\mkont}} \\
     %%
      \ev{\slam{\mvar}{\mexp}, \menv, \msto, \mkont}{\msmlab}{\mstimeline} &\machstep&
      \co{\mkont, \clos{\mvar, \mexp, \menv}, \msto}{\msmlab}{\mstimeline}
      \\
      %%
      \ev{\slit{\mconstant}, \menv, \msto, \mkont}{\msmlab}{\mstimeline} &\machstep&
      \co{\mkont, \mconstant, \msto}{\msmlab}{\mstimeline}
      \\
      %%
      %% CONTINUE
      \co{\spush{\kif{\mexpi0, \mexpi1, \menv}}{\mkaddr}, \strue, \menv, \msto}{\msmlab}{\mstimeline} &\machstep&
      \ev{\mexpi0, \menv, \msto, \mkont}{\msmlab}{\mstimeline} \text{ if } \mkont \in \msto(\mkaddr)
      \\
      %%
      \co{\spush{\kif{\mexpi0, \mexpi1, \menv}}{\mkaddr}, \sfalse, \menv, \msto}{\msmlab}{\mstimeline} &\machstep&
      \ev{\mexpi1, \menv, \msto, \mkont}{\msmlab}{\mstimeline} \text{ if } \mkont \in \msto(\mkaddr)
      \\
      %%
      \co{\spush{\kar[^\mlab]{\mexp, \menv}}{\mkaddr}, \mval, \msto}{\msmlab}{\mstimeline} &\machstep&
      \ev[^\mlab]{\mexpi, \menv, \msto', \spush{\kfn[^\mlab]{\mval}}{\mkaddr}}{\msmlab}{\mstimeline}
      \\
      && \text{where } \maddr' = \alloc(\mstate) \\
      &&\phantom{\text{where }} \msto' = \ext{\msto}{\maddr'}{\setof{\mval}} \\
      %%
      \co{\spush{\kfn[^\mlab]{\mval_f}}{\mkaddr}, \mval, \msto}{\msmlab}{\mstimeline} &\machstep&
      \ap{\mval_f, \mval, \msto, \mkont}{\msmlab}{\mstimeline} \text{ if } \mkont \in \msto(\mkaddr)
      \\
      %%
      %% APPLY
      \ap{\clos{\mvar, \mexp, \menv}, \mval, \msto, \mkont}{\msmlab}{\mstimeline} &\machstep&
      \ev{\mexp, \menv', \msto', \mkont}{\msmlab}{\mstimeline} \\
      &&\text{where } \maddr = \alloc(\mstate) \\
      &&\phantom{\text{where }} \menv' = \menv[\mvar \mapsto (\maddr, \mstimeline)] \\
      &&\phantom{\text{where }} \msto' = \ext{\msto}{\maddr}{\setof{\mval}}
    \end{array}    
  \end{gather*}
  \caption{Standard reduction rules}
  \label{fig:standard}
\end{figure*}

\begin{figure*}
  \begin{gather*}
    \begin{array}{@{}r@{\ }c@{\ }l@{}}
      \mstate & \machstep &\mstate' \text{ defined to be the following} \\
      %% EVAL
      \ev{\sTMon{\mmlab_u}{\mmlab_c}{\mlab}{(\mscon, \mtcon), \mexp}, \menv, \msto, \mkont}
         {\msmlab}{\mstimeline} &\machstep&
      \ev[^\mlab]{\mexp, \menv, \msto', \spush{\kmon{\mmlab_u}{\mmlab_c}{\mlab}{\mscon, \mtimeline, \menv}}{\mkaddr}}
         {\msmlab}{\mstimeline} \\
      &&\text{where } (\mkaddr, \mtimeline) = \alloc(\mstate) \\
      &&\phantom{\text{where }}
         \msto' = \msto \sqcup [\mkaddr \mapsto \setof{\mkont},
                                \mtimeline \mapsto \setof{\mtcon}]
      \\
      %%
      %% CONTINUE
      \co{\spush{\krt{\mmlab',\mtimeline'}}{\mkaddr}, \mval, \msto}
         {\msmlab}{\mstimeline}
        &\machstep&
      \co{\mkont, \mval, \msto}
         {\mmlab'}{\mtimeline'} \text{ if } \mkont \in \msto(\mkaddr)
      \\
      %%
      \co{\spush{\kmon{\mmlab_u}{\mmlab_c}{\mlab}{\mscon, \mtimeline, \menv}}{\mkaddr}, \mval, \msto}
         {\msmlab}{\mstimeline} &\machstep&
      \ck{\mmlab_u}{\mmlab_c}{\mlab}{+}
         {\mscon, \mtimeline, \menv, \mval, \msto, \mkont}
         {\msmlab}{\mstimeline} \text{ if } \mkont \in \msto(\mkaddr)
      \\
      %%
      %% Administrative contract checking
      %% Flat
      \ck{\mmlab_u}{\mmlab_c}{\mlab}{\mvariance}
         {\sflat{\mexp}, \mtimeline, \menv, \mval, \msto, \mkont}
         {\msmlab}{\mstimeline} &\machstep&
      \ev{\mexp, \menv, \msto', \spush{\kflat[^\mlab]{\mmlab_p, \mval}}{\mkaddr}}
         {\msmlab}{\mstimeline} \\
      &&\text{where } \mkaddr = \alloc(\mstate) \\
      &&\phantom{\text{where }} \msto' = \ext{\msto}{\mkaddr}{\setof{\mkont}} \\
      &&\phantom{\text{where }} \mmlab_p = \varianceite{\mvariance}{\mmlab_u}{\mmlab_c}
      \\
      % %% Higher-order
      \ck{\mmlab_u}{\mmlab_c}{\mlab}{\mvariance}
         {\sarr{\mname}{\mscon_D}{\mscon_R}, \mtimeline, \menv, \mval, \msto, \mkont}
         {\msmlab}{\mstimeline} &\machstep&
      \co{\mkont, \blclos{\mname}{\mmlab_u}{\mmlab_c}{\mlab}{\mscon_D}{\mscon_R}{\menv}{\mtimeline}{\maddr}, \msto'}
         {\msmlab}{\mstimeline} \\
      &\text{ if }& \mval \equiv \clos{\mvar, \mexp, \menv'}
       \text{ or }  \mval \equiv \blclos{\mname'}{\mmlab_u'}{\mmlab_c'}{\mlab'}{\mscon_D'}{\mscon_R'}{\menv'}{\mtimeline'}{\maddr'} \\
      &&\text{where } \maddr = \alloc(\mstate) \\
      &&\phantom{\text{where }} \msto' = \ext{\msto}{\maddr}{\setof{\mval}}
      \\
      %%
      \ck{\mmlab_u}{\mmlab_c}{\mlab}{\mvariance}
         {\sarr{\mname}{\mscon_D}{\mscon_R}, \mtimeline, \menv, \mval, \msto, \mkont}
         {\msmlab}{\mstimeline} &\machstep&
      \sblame{\mmlab_p} \\
      &\text{ if }& \mval \nequiv \clos{\mvar, \mexp, \menv'}
       \text{ and } \mval \nequiv \blclos{\mname'}{\mmlab_u'}{\mmlab_c'}{\mlab'}{\mscon_D'}{\mscon_R'}{\menv'}{\mtimeline'}{\maddr'} \\
      &&\text{where } \mmlab_p = \varianceite{\mvariance}{\mmlab_u}{\mmlab_c}
      \\
      %% CONS CONTRACT
      % Start checking car
      \co{\spush{\kmon{\mmlab_u}{\mmlab_c}{\mlab}{\sconsc{\mscon_A}{\mscon_D}, \mtimeline, \menv}}{\mkaddr},
          \mval,
          \msto}
         {\msmlab}{\mstimeline} &\machstep&
      \ck{\mmlab_u}{\mmlab_c}{\mlab}{+}
         {\mscon_A,
          \mtimeline,
          \menv,
          \mval_A,
          \msto,
          \spush{\kchkA[^{\mmlab_u, \mmlab_c}_\mlab]{\mscon_D, \mtimeline, \menv, \maddr'_A, \maddr'_D, \maddr_D}}
                {\mkaddr}}
         {\msmlab}{\mstimeline} \\
      &\text{ if }& \mval \equiv \vcons{\maddr_A}{\maddr_D} \text{ or }
                    \mval \equiv \vconst{\maddr_A}{\maddr_D}{\mstimeline'} \text{ and } \mval_A \in \msto(\maddr_A) \\
      &&\text{where } (\maddr'_A, \maddr'_D) = \alloc(\mstate)
      \\
      % Start checking cdr
      \co{\spush{\kchkA[^{\mmlab_u, \mmlab_c}_\mlab]{\mscon_D, \mtimeline, \menv, \maddr'_A, \maddr'_D, \maddr_D}}{\mkaddr},
          \mval, \msto}
         {\msmlab}{\mstimeline} &\machstep&
      \ck{\mmlab_u}{\mmlab_c}{\mlab}{+}
         {\mscon_D, \mtimeline, \menv, \mval_D, \msto',
                                \spush{\kchkD{\maddr'_A, \maddr'_D, \mtimeline}}{\mkaddr}}
         {\msmlab}{\mstimeline}
      \text{ if } \mval_D \in \msto(\maddr_D) \\
      &&\text{where } \msto' = \ext{\msto}{\maddr'_A}{\setof{\mval}}
      \\
      %%
      % End checking cdr
      \co{\spush{\kchkD{\maddr_A, \maddr_D, \mtimeline}}{\mkaddr}, \mval, \msto}
         {\msmlab}{\mstimeline}
       &\machstep&
      \co{\mkont, \vconst{\maddr_A}{\maddr_D}{\mtimeline}, \ext{\msto}{\maddr_D}{\setof{\mval}}}
         {\msmlab}{\mstimeline}
        \text{ if } \mkont \in \msto(\mkaddr)
      \\
      %% END CONS CONTRACT
      %%
      \co{\spush{\kflat[^\mlab]{\mmlab_u, \mval'}}{\mkaddr}, \mval, \msto}{\msmlab}{\mstimeline} &\machstep&
      \ap[^\mlab]{\mval, \mval', \msto, \spush{\kcheck{\mmlab_u, \mval'}}{\mkaddr}}{\msmlab}{\mstimeline}
      \\
      %%
      \co{\spush{\kcheck{\mmlab_u, \mval}}{\mkaddr}, \strue, \msto}{\msmlab}{\mstimeline} &\machstep&
      \co{\mkont, \mval, \msto}{\msmlab}{\mstimeline} \text{ if } \mkont \in \msto(\mkaddr)
      %% \attach{\mval_C}{\mval}
      \\
      %%
      \co{\spush{\kcheck{\mmlab_u, \mval}}{\mkaddr}, \sfalse, \msto}{\msmlab}{\mstimeline} &\machstep&
      \sblame{\mmlab_u}
      \\
      %%
      \co{\spush{\kmcall{\mmlab_u}{\mmlab_c}{\mlab}{\mscon_R, \mtimeline, \menv, \mname, \maddr}}{\mkaddr},
          \mval,
          \msto}{\msmlab}{\mstimeline} &\machstep&
      \ap{\mval_f,
          \mval,
          \msto,
          \spush{\kpost[^{\mmlab_u, \mmlab_c}_\mlab]{\mscon_R, \mtimeline, \menv, \msmlab}}{\mkaddr}}
         {\mname}{\mtimeline}
        \text{ if } \mval_f \in \msto(\maddr)
      \\
      %%
      % Start checking the post-condition before returning
      \co{\spush{\kpost[^{\mmlab_u, \mmlab_c}_\mlab]{\mscon_R, \mtimeline, \menv, \mname}}{\mkaddr}, \mval, \msto}
         {\msmlab}{\mstimeline}
       &\machstep&
      \ck{\mmlab_u}{\mmlab_c}{\mlab}{+}
         {\mscon_R, \menv, \mval, \msto, \spush{\krt{\mname, \mtimeline}}{\mkaddr}}
         {\msmlab}{\mstimeline}
      \\
      %%
      %% APPLY
      \ap[^\mlab]{\blclos{\mname}{\mmlab_u}{\mmlab_c}{\mlab'}{\mscon_D}{\mscon_R}{\menv}{\mtimeline}{\maddr},
                  \mval,
                  \msto,
                  \mkont}
                 {\msmlab}{\mstimeline} &\machstep&
      \ck{\mmlab_u}{\mmlab_c}{\mlab'}{-}
         {\mscon_D, \menv, \mval, \msto',
          \spush{\kmcall{\mmlab_u}{\mmlab_c}{\mlab}{\mscon_R, \mtimeline, \menv, \mname, \maddr}}{\mkaddr}}
         {\msmlab}{\mstimeline} \\
      &&\text{where } \mkaddr = \alloc(\mstate) \\
      &&\phantom{\text{where }} \msto' = \ext{\msto}{\mkaddr}{\setof{\mkont}}
      %%
    \end{array}
  \end{gather*}
  \caption{Non-standard rules}
\label{fig:concrete}
\end{figure*}
\balance
\bibliographystyle{plainnat}
%\input{paper.bbl}
\bibliography{bibliography}

% \include{appendix}
\end{document}