\section{Introduction}

Software systems are typically large, consist of many modules, and have invariants that are typically inexpressible or too costly to express (and prove) in the language's static type system, if it has one.
%
When this is the case, one might hope to rely on software contracts~\cite{dvanhorn:Findler2002Contracts} to give dynamic guarantees about the behavior of one's system, blaming the correct party responsible for any violation of these invariants.
%
A proposed system of \emph{temporal contracts}~\citep{ianjohnson:dfm:icfp2011} provide a linguistic mechanism to describe temporal properties that usually are checked extra-linguistically via model-checking an abstraction of the program.
%
Example temporal properties are, ``a file can only be closed if it has been opened'' and, ``if function A is given a function B, then B may not be called once A returns.''
%
Such invariants are important for interfaces that have set-up and tear-down protocols to follow.
%%

%%
There are downsides to software contracts, however.
%
If a contract is violated, a blame exception is thrown or the program simply terminates with the error.
%
Contracts do not ensure correctness --- they help the process of constructing correct programs.
%
In addition, contracts can introduce considerable overhead to the program.
%
Just wrapping a function in a contract monitor can disable compiler optimizations, and depending on the level of checking a contract does, the entry and exit of contract boundaries can also take a long time (indeed, we run arbitary programs as such checks!).
%
These are important costs to pay at the beginning of development, but as programs mature, we need a way to safely remove contract checking and have a performance and correctness return on the initial investment.
%%

%%
Temporal contracts pose an additional challenge over higher-order function contracts to statically verify, as they monitor extended interactions with a module, and not just localized pieces.
%
We propose a framework that is composable with techniques to verify functional contracts, that has low technical overhead (no translation to a model-checker's language necessary).
%
The technique uses the Abstracting Abstract Machines (AAM) approach~\citet{dvanhorn:VanHorn2010Abstracting} to check for reachability of a temporal contract blame.
%
The language for temporal contracts closely mimics linear temporal logic (LTL), but distinguishes itself in a way that makes LTL model-checking prohibitive on top of the initial cost of constructing a model to feed an LTL model-checker.
%
Temporal contracts can talk about value flow and use over time via binding in the specification --- this is not something that LTL can locally express.
%
The semantics of temporal contracts also is geared towards checking safety properties, since dynamic liveness checking is undecidable.
%
AAM was originally targeted towards describing flow analyses, but is robust enough to apply to model-checking safety properties of higher-order programs.
%
It is well-known that control-flow analysis can be stated in terms of model-checking, but this observation is misleading; one must use quadratically many model-checking queries to discover what a monovariant flow analysis can discover in one run.
%
The realm of temporal contract verification is similar: to use a model-checker, we would have to run a data-flow analysis up front in order to collect values that might be used as bindings, enumerate all possible binding/reference insantiations of the temporal contract, and then translate those contracts into LTL queries --- much more work than just running the program abstractly and reporting reachable blame states.
%

%%
Our contributions in this paper are as follows:
\begin{itemize}
 \item{an extension to \citeauthor{ianjohnson:dfm:icfp2011}'s temporal contract semantics;}
 \item{a new automaton model that we use to implement the monitor for this new semantics; and}
 \item{a sound abstraction to computably verify temporal contract satisfaction}
\end{itemize}
%%

%%
\section{Related Work}
%%

%%
Model-checking and contract verification (proving functional correctness) are huge fields and it is important to view our work in the greater context of these worlds of research.
%
The main separating factor between this work and related work is that all model-checking literature so far has treated the specification of temporal properties as \emph{extra-linguistic}, meaning there is no mechanism in the object language that could monitor for the properties.
%
Contracts are defined by their behavior of witnessing program execution, and thus do not have the same guarantees that a static type system has, such as, ``this function \emph{always} returns an integer when given an integer.''
%
In that vein, temporal contracts can never guarantee liveness properties of a program.
%
\citet{ianjohnson:dthf:complete} show that contracts that simulate types will never violate the guarantee that well-typed programs will never be blamed in a gradually-typed system.
%
Likewise, if we interpret temporal contracts in a stricter fashion --- sequenced events \emph{must} happen --- then in the abstract we can verify liveness properties.
%%

%%
\paragraph{First-order model-checking:}
The SLAM project~\citep{ianjohnson:Ball:2002:SLP:503272.503274} for model-checking C assumes that all function pointers of the same type alias.
%
For C programs that use callbacks heavily, this overapproximation leads to longer checking times due to more (spurious) paths to follow, and the imprecision inherent in any program approximation gets exacerbated by the additional pressure on abstract resources.

\paragraph{Higher-order model-checking:}
Java and C++ both have several high-quality model-checking tools \citep{ianjohnson:bandera, ianjohnson:java-pathfinder, ianjohnson:LLBMC}, some of which are bounded model-checkers, meaning they cannot fully verify temporal properties - only present counter-examples (that may not be true counter-examples).
%
Bandera~\citep{ianjohnson:bandera} is a sophisticated tool-chain that uses several static analysis techniques to extract a finite model from a Java program to feed to various back-end model-checkers.
%
Similar to our approach, Bandera employs control-flow analysis in order to produce compact models, but unsimilarly, the checking mechanisms are not in the control-flow analysis itself.
%%

%%
A technique that specifically targets higher-order languages, higher-order recursion schemes (HORS)~\citep{ianjohnson:Knapik:2002:HPT:646794.704852}, assumes a call-by-name semantics for the language it checks.
%
The current techniques for the initial abstraction of a program to HORS is not generally applicable to untyped or impure languages, since it creates the recursion schemes from the simple types of a given program.
%
HORS can be applied for call-by-value order if the program is first transformed into CPS, since then the intended evaluation order is encoded into call-by-name.
%
This still does not address the need for simple types, and does not apply for languages that cannot be expressed in CPS.

\paragraph{Static contract verification:}
In the world of statically verifying software contracts, there is much more work.
%
There have been many successful efforts in the realm of first-order contract verification~\citep{ianjohnson:fahndrich:contracts:2011,ianjohnson:vcc:2009}, but the techniques employed are inherently first-order: the only values are booleans.
%
\citet{ianjohnson:Flanagan:2006:HTC:1111037.1111059}'s notion of hybrid type checking is one way to state the problem: dynamic types are essentially flat contracts, and are treated as subtypes of anything during static checking.
%
If an external theorem prover can prove that the flat contracts always hold, the dynamic checks can be safely removed.
%
\citet{dvanhorn:Xu2012Hybrid} describe a higher-order contract verification system for OCaml by inlining all contract monitors and relying on a system of simplifications further enhanced by an SMT solver to optimize away dynamic checks.
%
\citet{dvanhorn:TobinHochstadt2012Higherorder} use AAM on a module semantics with higher-order contracts and is the most related to this work; whereas they focus on a concrete semantics for handling unknown values and an external theorem prover to show contract containment, our work focuses on an orthogonal issue of temporal contract monitoring and uses model-checking techniques.
%
Our techniques should smoothly integrate with theirs when considering partial programs, and is left to future work.
%%

%%
\section{Overview of temporal higher-order contracts}
%%

\FloatBarrier
\begin{figure}
  \begin{align*}
    \mscon \in \SContract &::= \sflat{\mexp} \alt \sarr{\mmlab}{\mscon}{\mscon} \alt \sconsc{\mscon}{\mscon}
\\
    \mexp \in \Expr &::= \sTMon{\mmlab_u}{\mmlab_c}{\mmlab_o}{\mscon}{\mtcon}{\mexp}
                    \alt \sSMon{\mmlab_u}{\mmlab_c}{\mmlab_o}{\mtimeline}{\mscon}{\mexp}
                    \alt \ldots
\\
\mmlab \in \Label&\text{ an infinite set}
  \end{align*}
  \caption{Syntax of structural contracts with labels}
  \label{fig:scontract-syntax}
\end{figure}

\begin{figure}
  \begin{align*}
 \mtcon \in \TContract &::=
      \mevent \alt \snonevent{\mevent}
 \alt \stseq{\mtcon}{\mtcon}
 \alt \stnot{\mtcon}
 \alt \stOr{\mtcon}{\mtcon}
 \alt \stAnd{\mtcon}{\mtcon}
 \alt \stmany{\mtcon} \\
&\alt \sddd \alt \stfail
 \alt \stcall{\mname}{\mvar}{\mtcon}
 \alt \stret{\mname}{\mvar}{\mtcon}
\\
\mevent \in \Event &::= \scallev{\mname}{\mvpat} \alt \sretev{\mname}{\mvpat} \\
\mvpat \in \VPat &::= \mconstant \alt \mname \alt \swc \\
\mvar \in \Var &\quad\text{an infinite set} \\
\mname \in \Name &::= \mvar \alt \mtoplevelname
  \end{align*}
  \caption{Syntax of temporal contracts}
  \label{fig:tcontract-syntax}
\end{figure}

Temporal contracts provide a declarative language for monitoring the temporal ordering of events that pass through module boundaries.
%
We analyze a slightly different presentation than ~\citeauthor{ianjohnson:dfm:icfp2011}'s temporal contracts that allows more precise specification of value use.
%
The syntax is presented in \autoref{fig:tcontract-syntax}.
%%

%%
Temporal contracts ($\mtcon$) include events ($\mevent$) (for $\mevent$ction), negated events ($\snonevent{\mevent}$), concatenation ($\stseq{\mtcon}{\mtcon}$) (often represented using juxtaposition), negated contracts ($\stnot{\mtcon}$), Kleene closure of events ($\stmany{\mtcon}$), union ($\stOr{\mtcon}{\mtcon}$), intersection ($\stAnd{\mtcon}{\mtcon}$), the universal temporal contract ($\sddd$), the empty temporal contract ($\stfail$), and higher-order binding events ($\stcall{\mname}{\mvar}$ and $\stret{\mname}{\mvar}$).
%
The difference between $\snonevent{\mevent}$ and $\stnot{\mtcon}$ is that the first must be an event and force time to step forward once, whereas the second may match arbitrarily many events.
%%

%%
Events themselves are expressed as patterns denoting calls ($\scallev{\mname}{\mvpat}$) or returns ($\sretev{\mname}{\mvpat}$), with respect to a particular function $\mname$ and with its argument or result matching a pattern $\mvpat$.
%
If $\mname$ is a label ($\mtoplevelname$), we simply check that the monitor wrapping the function has the same label (attached via the structural contract).
%
However, if $\mname$ is a variable ($\mvar$), then we consult a binding environment that the monitoring system builds as we pass binding events to determine if the function is exactly equal to the value bound.
%
Our distinction between variables (bound by temporal contract) and labels (bound by structural contract) is one aspect of what separates our semantics from \citeauthor{ianjohnson:dfm:icfp2011}'s.
%
Patterns can match constants ($\mconstant$), bound variables ($\mvar$), labeled functions ($\mtoplevelname$), or simply anything ($\swc$).
%%

%%
\citeauthor{ianjohnson:dfm:icfp2011}'s semantics for referring to functions is problematic; we give a slightly different account that captures the spirit of their prose describing their system, and indeed mirrors their actual implementation.
%
Consider one of their motivating examples (recalled---using our syntax and semantics---and discussed in \autoref{sec:sort}), which was to protect the comparator passed to a sort function from escaping the scope of the call.
%
What this should mean is the particular binding introduced by a call to $sort$ cannot be called after $sort$ returns, \ie, each constructed monitor around given comparators should not be called after $sort$ returns.
%
However, the flat use of \emph{labels} instead of \emph{bindings} would cause a second call to a supposedly-correct $sort$ to fail, since it internally calls the comparator of the same label, but of a different monitor construction.
%
\citeauthor{ianjohnson:dfm:icfp2011}'s implementation also includes call/return matching via a different binding at the call site to eventually use in the matching return.
%
We leave call/return matching to future work, as it is not necessary to verify the motivating examples.
%%

%%
\subsection{Sort example} \label{sec:sort}

\renewcommand*{\arraystretch}{1.2}
\newcommand*{\call}[1]{\scallev{#1}{\_}}
\newcommand*{\ret}[1]{\sretev{#1}{\_}}
\begin{align*}
 &\begin{array}{ l @{\quad}l@{\ } c @{\ }l }
 SortContract =
 &sort &:   &(cmp\ :\ Pos\ \to Pos\ \to\ Bool) \\
 &     &    &(List\ Pos) \\
 &     &\to &(List\ Pos) \\
 \end{array}
 \\
 &~\begin{array}{ @{~}r@{} l @{}l }
  \text{where}\quad
  &\stnot{(&\sddd~ \call{sort}~ \stmany{\snonevent{\ret{sort}}}~ \call{sort}~ \sddd)} \\
  \cap\quad
  &\stnot{(&\sddd~ \scallev{sort}{?cmp}~ \sddd~ \\
  &&\ret{sort} \sddd~ \call{cmp}~ \sddd)}
 \end{array}
 %\caption{Sort example}
 %\label{fig:sort}
\end{align*}

%%
This example gives contract for a hypothetical $sort$ function which takes two arguments: a comparator and a list (of positive numbers).
%
The notation ``$\mathit{name}\ :\ Domain\ \to\ Range$'' describes a function contract where the argument satisfies the $Domain$ contract and the result satisfies the $Range$ contract.
%
The ``$\mathit{name}\ :$'' prefix denotes the name of the function, for use in the temporal aspect of the contract.
%%

%%
$SortContract$ is also has a temporal component, given by the ``where'' clauses following its structural (function) contract.
%
The first of these clauses states that a second call to $sort$ may not occur (hence the negation of the trace) if there is no intervening return from $sort$ ($\stmany{\snonevent{\ret{sort}}}$).
%
This is specifying a particular safety property (as evidenced by the negation of the trace): $sort$ is supposed to be \emph{non-reentrant}.
%
The second temporal clause specifies a higher-order property; it states that, given a call to $sort$, its associated $cmp$ argument cannot be called after $sort$ returns.
%%

%%
Note also that the negated clauses of the temporal contract are prefixed and suffixed by ``$\sddd$''.
%TODO: Provide decent and intuitive explanation that doesn't require any forward-reference
%%

%%
\subsection{File example} \label{sec:file}

\begin{align*}
 &FileSystemContract\, =\, open\, :\, String\, \to\, FileContract \\
 &FileContract =~ Record \\
 &\begin{array}{ @{\quad~}l@{\ :} @{~}l@{\ \to\ } l }
  read & Unit & String \\
  write & String & Unit \\
  close & Unit & Unit
 \end{array} \\
 &\text{where}\quad \sddd~ \ret{close}
 %\caption{File example}
 %\label{fig:file}
\end{align*}

%%
This example gives the contract for a hypothetical file system, which can be used to open files by giving the $open$ function a filename (a $String$); the client is then given a file handle contracted by $FileContract$.
%
A file handle, in turn, is a record of functions which interact with the file: $read$, $write$, and $close$, all which perform the expected behaviors.
%%

%%
The temporal contract is interesting: it is not phrased in terms of a negation, but rather an affirmation.
%
Its goal is to state that a user of the file is forbidden from making use of the file handle (through the use of its component functions) after the user has $close$d the file.
%
It is phrased such that there is no ``$\sddd$'' at the end of its trace; thus this means that the last reference one can make to such a monitored record is returning from $close$; after that, it cannot be used.
%
%TODO: Do we need to define prefix-closure?
Note that this is not a \emph{liveness property}; this does not mean that a return from $close$ \emph{must} happen, as traces are \emph{prefix-closed}.
%
Instead, the property is a \emph{safety property}, though expressed in the affirmative.
%%

%%
\subsection{TCP example} \label{sec:tcp}

\newcommand*{\tcpc}{\mathit{TCPConnection}}
\newcommand*{\tcpcc}{\mathit{TCPConnectionContract}}
\newcommand*{\tcpsock}{\mathit{TCPSocket}}
\newcommand*{\tcpsendc}{\mathit{TCPSendContract}}
\newcommand*{\tcprecvc}{\mathit{TCPRecvContract}}
\newcommand*{\tcpdata}{\mathit{TCPData}}
\newcommand*{\tcpstyle}[1]{\texttt{#1}}
\FloatBarrier
\begin{figure}
 \newcommand*{\send}[1]{\scallev{send}{#1}}
 \newcommand*{\rcv}[1]{\sretev{recv}{#1}}
 \newcommand*{\notclose}{\snonevent{\call{close}}}
 \newcommand*{\tcpsyn}{\tcpstyle{SYN}}
 \newcommand*{\tcpack}{\tcpstyle{ACK}}
 \newcommand*{\tcpsynack}{\tcpstyle{SYN\&ACK}}
 \newcommand*{\tcpfin}{\tcpstyle{FIN}}
 %\newcommand*{\tcpfinack}{\tcpstyle{FIN\&ACK}}
 $\tcpcc\, =~ Record$ \\
 $\begin{array}{ @{\quad~}l@{\ :} @{~}l @{\ \to\ }l }
  open & \tcpsock & \tcpsendc \\
  listen & \tcpsock & \tcprecvc
 \end{array}$ \\
 $\tcpdata =$
 $~ \tcpsyn \mid \tcpack \mid \tcpsynack \mid \tcpfin \mid \tcpstyle{Data}(\_)$

 $\tcpc =~ Record$ \\
 $\begin{array}{ @{\quad~}l@{\ :} @{~}l@{\ \to\ } l }
  send & \tcpdata & Unit \\
  recv & Unit & \tcpdata \\
  timeout & Duration & Unit \\
  close & Unit & Unit
 \end{array}$ \\

 $\tcpsendc =~ \tcpc$ \\
 $\begin{array}{ @{~}r@{\quad} l @{}l }
  \text{where}
  &&\send{\tcpsyn}~ \notclose \\
  &&\rcv{\tcpsynack}~ \notclose \\
  &&\send{\tcpack}~ \stmany{\notclose} \\

  &&\cup
  \begin{aligned}
   &\left(
    \begin{aligned}
     &\rcv{\tcpfin}~ \send{\tcpack} \\
     &\send{\tcpfin}~ \rcv{\tcpack}
    \end{aligned}
   \right) \\
   &\left(
    \begin{aligned}
     &\call{close}~ \send{\tcpfin} \\
     &\rcv{\tcpack}~ \rcv{\tcpfin}~ \send{\tcpack}
    \end{aligned}
   \right)
  \end{aligned} \\
  &&\ret{timeout}~ \ret{close}
 \end{array}$

 $\tcprecvc =~ \tcpc$ \\
 $\begin{array}{ @{~}r@{\quad} l @{}l @{}l }
  \text{where}
  &&\rcv{\tcpsyn}~ \notclose \\
  &&\send{\tcpsynack}~ \notclose \\
  &&\rcv{\tcpack}~ \stmany{\notclose} \\

  &&\cup
  \begin{aligned}
   &\left(
    \begin{aligned}
     &\call{close}~ \send{\tcpfin} \\
     &\rcv{\tcpack}~ \rcv{\tcpfin}~ \send{\tcpack}
    \end{aligned}
   \right) \\
   &\left(
    \begin{aligned}
     &\rcv{\tcpfin}~ \send{\tcpack} \\
     &\call{close}~ \send{\tcpfin}~ \rcv{\tcpack}
    \end{aligned}
   \right)
  \end{aligned} \\
  &&\ret{timeout}~ \ret{close}
 \end{array}$

 \caption{TCP example}
 \label{fig:tcp}
\end{figure}

% TODO: Source this from WP
\begin{figure}
 \centering
 \fontsize{4}{5} \selectfont
 \def \svgwidth{\columnwidth}
 \input{tcp-fsm.pdf_tex}
 \caption{Simplified TCP FSM for \autoref{fig:tcp}}
 \label{fig:tcp-fsm}
\end{figure}

%%
In \autoref{fig:tcp} we show the contract for a hypothetical TCP connection module.
%
A client of this module may $open$ a $\tcpsock$ for initiating a connection or may $listen$ to a $\tcpsock$ for passively connecting.
%
A $\tcpc$ is defined similarly to our file system example: it is a record of functions which interact with the connection: $send$, $recv$, $timeout$, and $close$.
%
Notably, $send$ and $recv$ interact with data in the form of $\tcpdata$, which can be one of the special packets used in the TCP protocol or can simply be some amount of user data ($\tcpstyle{Data}(\_)$).
%
%TODO: maybe express timing out in a better manner?
The $timeout$ function is simply internally used by the module to set timeouts for interactions with the other end of the TCP connection; clients do not directly use it and it is included solely for the ability to reason over timeouts in the temporal contract.
%%

%%
A socket on the ``sending'' end of the TCP connection (having used $open$) is obligated to use the connection according to the temporal component of $\tcpsendc$.
%
Likewise, a socket on the ``receiving'' end of the TCP connection (having used $listen$) is constrained by $\tcprecvc$.
%
The contracts are very involved, but they implement a simplified version of the TCP connection lifecycle given in \autoref{fig:tcp-fsm}.
%
Note that the temporal clause in each contract is phrased in the affirmative, as in \autoref{sec:file}; however, unlike that example, this property is indeed a (restricted) kind of \emph{liveness property}.
%
It states that the client uses the socket in a manner consistent with the TCP protocol and can expect the other end to as well.
%
The key difference between this property and a traditional liveness property is that it speaks of a liveness property with respect to \emph{a particular contract-monitoring} of a $\tcpc$; prefix-closure is still present at the top level (cf. \autoref{fig:tcontract-denotation}) and thus the protocol noted in the temporal contract may not occur if no $\tcpc$ is used.
%%

%%
\section{Semantics of Temporal Contracts} \label{sec:temporal-semantics}

As noted in \autoref{sec:sort}, temporal contracts are associated with structural contracts that label function components within them.
%
For simple exposition, we will consider tuples as the main organizational tool for contracting the interactions between multiple functions.
%
Since we consider monitor constructions as a more basic notion of equality, we also see each temporal monitor construction as starting its own \emph{timeline}, which sees its own filtered view of events in the system.
%
Thus, as values flow through contract boundaries, they are considered on different timelines.
%
\citeauthor{ianjohnson:dfm:icfp2011} formalized their semantics in terms of a nondeterministic machine that defined its interactions on all event streams, and thus their machine was on a single timeline.
%
The semantics of temporal contracts that we propose uses pointer-equality of monitors for comparisons of non-primitive data.
%
Our semantics makes interaction between temporal contract monitors explicit, allowing us to verify whole programs.
%%

%%
We denote temporal contracts as sets of event traces that satisfy the contract, all parameterized by which timeline the events affect.
%
The semantics is close to \citeauthor{ianjohnson:dfm:icfp2011}'s definition, and given in \autoref{fig:tcontract-denotation}.
%
We made the design choice to require a function contract monitor wrapping for named values to consider their calls or returns as events --- this choice is reflected in the denotation of events in \autoref{fig:event-denotation}.
%
The reason for this is that control should flow back to the timeline considered in order for an event to affect that timeline.
%
It is easy enough to amend the structural contracts to reflect the fact that a binding is considered a function in the temporal contract.

\FloatBarrier
\begin{figure}
  \begin{align*}
   \denotetcon{\mevent}{\mtimeline}{\menv} &=
   \denoteevent{\mevent}{\menv}{\mtimeline}
\\
   \denotetcon{\stseq{\mtcon_0}{\mtcon_1}}{\mtimeline}{\menv} &=
%   \prefixes(\denotetcon{\mtcon_0}{\mtimeline}{\menv}) \cup
   \setbuild{\mtrace_0 \cdot \mtrace_1}{\mtrace_0 \in \denotetcon{\mtcon_0}{\mtimeline}{\menv}, \mtrace_1 \in \denotetcon{\mtcon_1}{\mtimeline}{\menv}}
\\
   \denotetcon{\stnot{\mtcon}}{\mtimeline}{\menv} &=
  %  \setbuild{\mtrace}{\mtrace \in \Traces^\mtimeline, \\
  %                    &\phantom{= \{ \mtrace : } \forall \mtrace' \in \denotetcon{\mtcon}{\mtimeline}{\menv}. \mtrace' \text{ is not a prefix of } \mtrace}
   \Traces^\mtimeline \setminus \denotetcon{\mtcon}{\mtimeline}{\menv} % DISCONTINUOUS!
\\
   \denotetcon{\stOr{\mtcon_0}{\mtcon_1}}{\mtimeline}{\menv} &=
   \denotetcon{\mtcon_0}{\mtimeline}{\menv} \cup \denotetcon{\mtcon_1}{\mtimeline}{\menv}
\\
   \denotetcon{\stAnd{\mtcon_0}{\mtcon_1}}{\mtimeline}{\menv} &=
   \denotetcon{\mtcon_0}{\mtimeline}{\menv} \cap \denotetcon{\mtcon_1}{\mtimeline}{\menv}
\\
   \denotetcon{\stmany{\mtcon}}{\mtimeline}{\menv} &=
   \setbuild{\mtrace^i}{i \le \omega, \mtrace \in \denotetcon{\mtcon}{\mtimeline}{\menv}}
\\
   \denotetcon{\sddd}{\mtimeline}{\menv} &=
   \Traces^\mtimeline
\\
   \denotetcon{\stfail}{\mtimeline}{\menv} &= \emptyset
\\
   \denotetcon{\stcall{\mname}{\mvar}{\mtcon}}{\mtimeline}{\menv} &=
   \setbuild{\mtrace \cdot \mtrace'}
            {\mtrace \in \denoteevent{\scallev{\mname}{\mval}}{\mtimeline}{\menv},
             \mtrace' \in \denotetcon{\mtcon}{\mtimeline}{\menv[\mvar \mapsto \mval]}}
\\
   \denotetcon{\stret{\mname}{\mvar}{\mtcon}}{\mtimeline}{\menv} &=
   \setbuild{\mtrace\cdot \mtrace'}
            {\mtrace \in \denoteevent{\sretev{\mname}{\mval}}{\mtimeline}{\menv},
             \mtrace' \in \denotetcon{\mtcon}{\mtimeline}{\menv[\mvar' \mapsto \mval]}}
  \end{align*}
  We use prefix closure to allow the progression of execution, but also cut out discontinuities.
  \begin{align*}
    \prefixes(\Pi) &= \setbuild{\mtrace}{\exists \mtrace' \in \Pi. \mtrace \text{ is a prefix of } \mtrace'}
  \end{align*}
  \caption{Denotation of Temporal Contracts}
  \label{fig:tcontract-denotation}
\end{figure}

\begin{figure}
  \begin{align*}
    \denoteevent{\scallev{\mvar}{\mvpat}}{\mtimeline}{\menv} &= \\
    &\left\{\begin{array}{ll}
           \setbuild{\apvcall{\menv(\mvar)}{\mval}}{\mval \in \vpatToData(\mvpat, \menv)} &\text{ if } \timelineis{\menv(\mvar)}{\mtimeline} \\
           \emptyset & \text{ otherwise}
           \end{array}\right.
\\
    \denoteevent{\scallev{\mtoplevelname}{\mvpat}}{\mtimeline}{\menv} &=
      \setbuild{\apvcall{\mval}{\mval'}}{
        \begin{array}{l}
\mval' \in \vpatToData(\mvpat, \menv),\\
 \labelis{\mval}{\mtoplevelname} \text{ and } \timelineis{\mval}{\mtimeline}
\end{array}
}
\\
   \vpatToData(\swc, \menv) &= \Value
\\
   \vpatToData(\mvar, \menv) &= \setof{\menv(\mvar)}
\\
   \vpatToData(\mtoplevelname, \menv) &= \setbuild{\mval}{\mval \equiv \bclos{\mtoplevelname}{\swc}{\swc}{\swc}{\swc}{\swc}{\swc}{\swc}}
\\
   \vpatToData(\mconstant, \menv) &= \setof{\mconstant}
  \end{align*}
  where $\timelineis{\bclos{\swc}{\swc}{\swc}{\swc}{\mtimeline}{\swc}{\swc}{\swc}}{\mtimeline}$ \\
  and $\labelis{\bclos{\mtoplevelname}{\swc}{\swc}{\swc}{\swc}{\swc}{\swc}{\swc}}{\mtoplevelname}$ \\
  (Return events are similar to calls)
  \caption{Denotation of events}
  \label{fig:event-denotation}
\end{figure}

Negation differs from what one might expect due to the prefix closure at the top level.
%
Say we defined negation to be
\begin{equation*}
  \denotetcon{\stnot{\mtcon}}{\mtimeline}{\menv} = \Traces^\mtimeline \setminus \denotetcon{\mtcon}{\mtimeline}{\menv}\text.
\end{equation*}
In this case, $\mevent\mevent' \in \prefixes(\denotetcon{\stnot{\mevent}}{\mtimeline}{\menv})$, and because of prefix closure, $\mevent \in \prefixes(\denotetcon{\stnot{\mevent}}{\mtimeline}{\menv})$!
%
Temporal contract monitors should blame the faulty party as soon as the contract has been violated, and thus any trace with a faulty prefix should be rejected.
%%

%%
Each temporal contract monitor redex evaluation creates a new timeline --- a new slice of program events that must adhere to permissible events that the denotation of the temporal contract defines.
%
Say $\mtimeline$ is the timeline for a contract $\mtcon$ on an expression $\mexp$.
%
We say $\mexp$ satisfies its temporal contract if its event trace filtered by the timeline ($\denote{\mexp}_\mtimeline$) is in the denotation of the temporal contract for that timeline ($\prefixes(\denotetcon{\mtcon}{\mtimeline}{\bot})$, where $\bot$ is an empty environment of temporal bindings).
%
For this to be a contract system and not just a notion of correctness, however, we need some machinery to monitor the progression of the event trace and check to see that it meets our specification.
%
The contracts could be interpreted with some simple combinators, but there is no guarantee that the space of combinators is finite, which is important for our analysis.
%
We introduce a simple generalization of finite state machines (FSMs) that is not necessarily finite-state in order to match against events and bind values for later equality checking: \emph{pattern-matching state machines} (\emph{PMSM}s).

%%
\section{Semantics}\label{sec:technical}

Now that we have a clear view of the behavior of temporal contracts, we nail down a formal semantics that we use to prove the correctness of our monitoring system.
%
The semantics we present is in the style of Felleisen's reduction semantics~\citep{ianjohnson:Felleisen:2009:SEP:1795772}, which can be systematically transformed into an abstract machine in the form presented in~\citet{dvanhorn:VanHorn2010Abstracting}.
%%

%FIXME: This is from the LTL days...
%%
Wrapping monitors around values associates entirely fresh NFA states.
%
The names given to bindings are really associated with the bindings.
%
We have to give up some precision for decidability --- we use a monovariant allocation scheme for monitor allocation.
%
This scheme allows us to lift all textual temporal contracts to the top level and check individually.
%
A polyvariant scheme would require either knowing how many abstract bindings are allocated during execution, or an exhaustive enumeration of possible bindings as propositions to check.

%%
\subsection{Syntax}
\FloatBarrier

\begin{figure}
\begin{align*}
\mexp \in \Expr &::=
      \slit{\mconstant}
 \alt \svar{\mvar}
 \alt \sapp{\mexp}{\mexp}
 \alt \slam{\mvar}{\mexp}
 \alt \sif{\mexp}{\mexp}{\mexp} \\
&\alt \sSMon{\mmlab}{\mmlab}{\mlab}{\mtimeline}{\mscon}{\mexp}
 \alt \sTMon{\mmlab}{\mmlab}{\mlab}{\mscon}{\mtcon}{\mexp} \\
\mconstant \in \Constant &=
 -1 \alt 0 \alt 1 \alt \ldots \alt + \alt - \alt \ldots \\
&\alt \strue \alt \sfalse \alt \vee \alt \wedge \alt \ldots \\
&\alt \sunit \alt \scons \alt \scar \alt \scdr \alt \ldots \\
\mvar \in \Var &\quad\text{ an infinite set} \\
\mmlab \in \Label \alt \toplevel &\quad\text{ an infinite set, where $\toplevel$ is the top-level}
\end{align*}
\caption{Syntax}
\label{fig:syntax}
\end{figure}

%
\autoref{fig:syntax} presents the core, desugared syntax of our language model.
%
Note that the surface syntax is better represented by the pseudocode examples given in \cref{sec:sort,sec:file,sec:tcp}; for example, a user would not be able to use $\mathtt{smon}$ or $\mathtt{tmon}$ in expressions.
%
While the syntax is largely conventional, the nature of monitoring and labelling are worth discussion.

%
A structural monitor $\sSMon{k}{\ell}{j}{\mtimeline}{\mscon}{\mexp}$ is like a traditional monitor \cite{ianjohnson:dthf:complete}: the structural contract is given by $\mscon$ and the contract parties are given by labels: $k$ is the server, $l$ is the client, and $j$ is the contract itself.
%
However, our structural monitors additionally feature a timeline ($\mtimeline$), used to temporally reason over values as they flow through contract boundaries (cf. \autoref{sec:temporal-semantics}).
%

%
A temporal monitor $\sTMon{k}{\ell}{j}{\mscon}{\mtcon}{\mexp}$ has a structural component as well ($\mscon$), but importantly it also considers a temporal contract given by $\mtcon$.
%
These kinds of monitors are only introduced at the top level, and thus need not be qualified over a timeline, as it is effectively $\toplevel$.
%
At this point we would like to note that our usage of labels differs slightly from existing literature \cite{ianjohnson:dthf:complete}: we have a notion of the ``top level label'', denoted by $\toplevel$; this is similar to \citeauthor{ianjohnson:dthf:complete}'s use of $\ell_0$.
%%

%%
\subsection{Value Space and Evaluation Contexts}

\begin{figure}
\begin{align*}
\mexp &::= \ldots
 \alt \sblame{\mmlab}{\mmlab}
 \alt \schk*{\mmlab}{\mmlab}{\mtimeline}{\mexp}{\mval}
 \alt \sown{\mexp}{\mmlab} \\
&\alt \sret{\mmlab}{\mtimeline}{\mexp}
\\
\mval \in \Value &::=
      \mconstant
 \alt \vcons{\mval}{\mval}
 \alt \sown{\mval}{\mmlab}
 \alt \maddr \\
&\alt \bclos{\mmlab}{\mscon}{\mmlab}{\mmlab}{\mtimeline}{\mscon}{\mmlab}{\maddr}
\\
\maddr \in \Addr &\quad\text{an infinite set} \\
\mstimeline \in \Timeline &::= \maddr \alt \toplevel
\\
\mscon &::= \ldots
\alt \sown*{\sflat{\mexp}}{\mmlab}
\\
\sOwn{\mexp}{\mmlab} = \sown{ \ldots \sown{\mexp}{\mmlab} \ldots }{\mmlab}
&\quad\text{where $\forall$ labels $k$ and terms $\mexp^\prime$, $\mexp \neq \sown{\mexp^\prime}{k}$}
\\
\sown*{\sflat{\mexp}}{\mmlab} &\quad\text{denotes the set of responsible parties $\overline{\mmlab}$}
\end{align*}
\caption{Value space}
\label{fig:values}
\end{figure}
%%

%
\autoref{fig:values} presents the value space for our language model.
%
For evaluation purposes, we extend our definition of expressions ($\mexp$) to include intermediate terms for contract checking.
%
Expressions of the form $\sret{\mmlab}{\mtimeline}{\mexp}$ denote the production of an return event $\sretev{\mmlab}{\mexp}$, which may be rejected by the temporal monitors in place.
%
The $\sblame{\ell}{j}$ expression denotes a contract failure (of the contract $j$), which is a fatal error which blames $\ell$.
%
An $\schk*{\ell}{j}{\mtimeline}{\mexp}{\mval}$ expression denotes an obligation to check the contract of $j$ given by $\mexp$ against the value $\mval$, blaming $\ell$ if the contract is violated.
%
The timeline component of this expression ($\mtimeline$) is used to pass along the timeline to any monitors inside of $\mexp$ which might need to reason over it; given complete monitoring \cite{ianjohnson:dthf:complete}, the contract itself is still subject and a party to the program's contracts.
%
The expression $\sown{\mexp}{\mmlab}$ denotes that the $\mexp$ is \emph{owned} \cite{ianjohnson:dthf:complete} by $\mmlab$; this is used to keep track of value migration for the purposes of ensuring \emph{complete monitoring}, using the concept of \emph{single ownership}.
%
We also extend our definition of structural contracts to include ownership of flat contracts ($\sown*{\sflat{\mexp}}{\mmlab}$).

%
\NB We provide a brief explanation of some notation at the bottom of the figure.
%
Of particular note, we use $\sOwn{\mexp}{\mmlab}$ to denote that $\mexp$ may have no ownership annotations, but if it has one then it is $\ell$ for all such annotations.
%
Our concept and usage of ownership is identical to that of \citet{ianjohnson:dthf:complete}, which we recommend reading to fully understand this topic; as it is orthogonal to our work, we do not delve into it in much detail in this paper.
%

%
Values ($\mval$) are conventional except for ownership ($\sown{\mval}{\mmlab}$) and blessed closures ($\bclos{\mmlab}{\mscon}{\mmlab}{\mmlab}{\mtimeline}{\mscon}{\mmlab}{\maddr}$).
%
Though we've discussed timelines ($\mtimeline$) (cf. \autoref{sec:temporal-semantics}), we show here that our representation for them is either as an address ($\maddr$) or the top level ($\toplevel$).
%

%
Our evaluation contexts in \autoref{fig:ctx} follow straightforwardly and are ownership-sensitive \cite{ianjohnson:dthf:complete}.
%
A machine state ($\mstate$) is composed of the evaluation context ($\mctx{\mmlab}$), store ($\msto$), and store of PMSM states ($\mTMons$).
%
The former maps addresses to sets of values and the latter maps timelines to PMSMs.
%

%%
\begin{figure}
\begin{align*}
\mctx{\mmlab} \in \ECtx &::=
      \sapp{\mctx{\mmlab}}{\mexp}
 \alt \sapp{\mval}{\mctx{\mmlab}}
 \alt \sif{\mctx{\mmlab}}{\mexp}{\mexp} \\
&\alt \vcons{\mctx{\mmlab}}{\mexp}
 \alt \vcons{\mval}{\mctx{\mmlab}} \\
&\alt \sSMon{\ell}{k}{j}{\mtimeline}{\mscon}{\mctx*}
 \alt \sSMon{\ell^\prime}{k}{j}{\mtimeline}{\mscon}{\mctx{\ell}} \\
&\alt \sTMon{\ell}{k}{j}{\mscon}{\mtcon}{\mctx*}
 \alt \sTMon{\ell^\prime}{k}{j}{\mscon}{\mtcon}{\mctx{\ell}} \\
&\alt \schk*{k}{\ell}{\mtimeline}{\mctx*}{\mval}
 \alt \schk*{k}{\ell^\prime}{\mtimeline}{\mctx{\ell}}{\mval} \\
&\alt \sret{\ell}{\mtimeline}{\mctx*}
 \alt \sret{\ell^\prime}{\mtimeline}{\mctx{\ell}} \\
&\alt \sown{\mctx*}{\ell}
 \alt \sOwn{\mctx{\ell}}{\ell^\prime}
\\
\mctx* \in \ECtx* &::=
      \hole
 \alt \sapp{\mctx*}{\mexp}
 \alt \sapp{\mval}{\mctx*}
 \alt \sif{\mctx*}{\mexp}{\mexp} \\
&\alt \vcons{\mctx*}{\mexp}
 \alt \vcons{\mval}{\mctx*} \\
&\alt \scall{\mmlab}{\mtimeline}{\mctx*}
 \alt \sret{\mmlab}{\mtimeline}{\mctx*} \\
\ECtx* &\subset \ECtx^\mmlab
\\
\mstate \in \State &= \chevron{\mctx{\mmlab}, \msto, \mTMons} \quad\text{machine state}
\\
\msto \in \Store &= \Addr \parto \wp(\Value)
\\
\mTMons \in \TMons &= \Timeline \parto \wp(\PMSM)
\end{align*}
\caption{Evaluation contexts}
\label{fig:ctx}
\end{figure}
%%

%%
\subsection{Reduction} \label{sec:reduction}

% TODO:
% * Should addresses be owned? Does this imply stores need to be owned...?
% * Should conses be owned?
\newcommand*{\namefmt}[1]{\textit{\textsc{#1}}}
\begin{figure*}
\newcommand*{\update}[3]{#1^\prime = #1[#2 \mapsto #1(#2)\sqcup#3]}
\newcommand*{\name}[1]{&\text{[\namefmt{#1}]}}
\newcommand*{\where}{\text{where }}
\newcommand*{\cwhere}{\phantom{\where}}
\centering
$\begin{array}{@{}l @{\ }c@{\ } l@{} r}
\mstate \chevron{\mctx{\mmlab}[\ldots], \msto, \mTMons}
&\machstep&
%TODO: Can mmlab change? For now, yup.
\mstate^\prime \chevron{\mctx{\mmlab^\prime}[\ldots], \msto^\prime, \mTMons^\prime}
\name{rule-name}

\\ \hline % If true
\sif{ \sOwn{\strue}{\mmlab} }{\mexp_1}{\mexp_2}
&\machstep&
\mexp_1
\name{if-true}

\\ % If false
\sif{ \sOwn{\sfalse}{\mmlab} }{\mexp_1}{\mexp_2}
&\machstep&
\mexp_2
\name{if-false}

\\ % Apply
\sapp{ \sOwn{\slam{\mvar}{\mexp}}{\mmlab} }{ \sOwn{\mval}{\mmlab} }
&\machstep&
\sown{ \sapp{\{ \sown{\mval}{\mmlab}/\mvar \}}{\mexp} }{\mmlab}
\name{apply}

\\ % Temporal monitor
\sTMon{k}{\mmlab}{j}{\mscon}{\mtcon}{\mval}
&\machstep&
\sSMon{k}{\mmlab}{j}{\mtimeline}{\mscon}{\mval}
\name{tmon} \\
&&\where \update{\mTMons}{\mtimeline}{\smachine} \\
&&\cwhere \smachine = \compile{\mtcon}{\mtimeline} \ne \bot \\
&&\cwhere \mtimeline = \salloc{\mstate} \\
&&\text{given } \mmlab = \toplevel

\\ % Temporal monitor compilation fail
\ditto
&\machstep&
\sblame{j}{j}
\name{tmon-fail} \\
&&\where \bot = \compile{\mtcon}{\mtimeline} \\
&&\cwhere \mtimeline = \salloc{\mstate} \\
&&\text{given } \mmlab = \toplevel 

\\ % Flat monitor
\sSMon{k}{\mmlab}{j}{\mtimeline}{ \sown*{\sflat{\mexp}}{\mmlab^{\prime\prime}} }{ \sOwn{\mconstant}{\mmlab^{\prime\prime}} }
&\machstep&
\schk*{k}{j}{\mtimeline}{ \sapp{\mexp}{\mconstant} }{\mconstant}
\name{smon-flat}

\\ % Cons monitor
\sSMon{k}{\mmlab}{j}{\mtimeline}{ \sconsc{\mscon_A}{\mscon_D} }{ \sOwn{\vcons{\mval_A}{\mval_D}}{\mmlab} }
&\machstep&
\sown{\vcons{ \sSMon{k}{\mmlab}{j}{\mtimeline}{\mscon_A}{\mval_A} }{ \sSMon{k}{\mmlab}{j}{\mtimeline}{\mscon_D}{\mval_D} }}{\mmlab}
\name{smon-cons}

\\ % Arrow monitor
\sSMon{k}{\mmlab}{j}{\mtimeline}{ \sarr{\mmlab_\lambda}{\mscon_D}{\mscon_R} }{\mval}
&\machstep&
\sown{\bclos{\mmlab_\lambda}{\mscon_D}{k}{j}{\mtimeline}{\mscon_R}{\mmlab}{\maddr}}{\mmlab}
\name{smon-arrow} \\
&&\where \maddr = \salloc{\mstate} \\
&&\cwhere \update{\msto}{\maddr}{\mval} \\
&&\text{given } \mval = \slam{\mvar}{\mexp}

\\ % Arrow monitor fail
\ditto
&\machstep&
\sblame{k}{j} \qquad\text{given } \mval \neq \slam{\mvar}{\mexp}
\name{smon-arrow-fail}

\\ % Check true
\schk{k}{j}{ \sOwn{\strue}{j} }{\mval}
&\machstep&
\mval
\name{chk-true}

\\ % Check false
\schk{k}{j}{ \sOwn{\sfalse}{j} }{\mval}
&\machstep&
\sblame{k}{j}
\name{chk-false}

\\ % Blessed application (call)
\sapp{ \sOwn{\bclos{\mmlab_\lambda}{\mscon_D}{k}{j}{\mtimeline}{\mscon_R}{\mmlab^{\prime\prime}}{\maddr}}{\mmlab} }{ \sOwn{\mval}{\mmlab} }
&\machstep&
%TODO: Should the timeline be different?
\mexp_{ret}
\name{call} \\
&&\where \mexp_{ret} =
\sret{\mmlab_\lambda}{\mtimeline}{ \sSMon{k}{\mmlab^{\prime\prime}}{j}{\mtimeline}{\mscon_R}{\mexp_{call}} } \\
&&\cwhere \mexp_{call} = \sapp{\mval_\lambda}{\sSMon{\mmlab^{\prime\prime}}{k}{j}{\mtimeline}{\mscon_D}{\mval}} \\
&&\cwhere \mval_\lambda = \slam{\mvar}{\mexp} \in \msto(\maddr) \\
&&\cwhere \mTMons^\prime \in \sstep{\mTMons}{\mtimeline}{\scallev{\mmlab_\lambda}{\mval}} \\
&&\cwhere \mmlab^\prime = \mmlab_\lambda

\\ % Call fail
\ditto
&\machstep&
\sblame{\mmlab}{j}
\qquad\text{given } \bot \in \sstep{\mTMons}{\mtimeline}{\scallev{\mmlab_\lambda}{\mval}}
\name{call-fail}

\\ % Return
\sret{\mmlab_{ret}}{\mtimeline}{ \sOwn{\mval}{\mmlab} }
&\machstep&
\sown{\mval}{\mmlab_{ret}}
\name{return} \\
&&\where \mTMons^\prime \in \sstep{\mTMons}{\mtimeline}{\sretev{\mmlab}{\mval}} \\
&&\cwhere \mmlab^\prime = \mmlab_{ret}

\\ % Return fail
\ditto
&\machstep&
\sblame{\mmlab}{\j}
\qquad\text{given } \bot \in \sstep{\mTMons}{\mtimeline}{\sretev{\mmlab}{\mval}}
\name{return-fail}

\\ \hline % Blame
\mctx{\mmlab}[\sblame{k}{j}]
&\machstep&
\sblame{k}{j}
\name{blame}
\end{array}$
\caption{Reduction rules}
\label{fig:reduction}
\end{figure*}

%
Our reduction relation given in \autoref{fig:reduction} makes use of the the single owner policy by reducing redexes only if the label of the hole matches the owner of the pieces of the redex.
%
We elide the rules for the primitive functions as they are standard and straightforward.
%
Note, however, that all of our primitives (save for $\scons$) take only addresses as arguments and each rule dereferences the addresses in the store.
%

%
The \namefmt{tmon} rule compiles the temporal contract inside of the $\mathtt{tmon}$ ($\mtcon$) and stores it inside the PMSM store ($\mTMons$), associated with the a fresh timeline ($\mtimeline$) and joined with any extant PMSMs associated with the timeline ($\mTMons(\mtimeline)$).
%
The structural component of the contract ($\mscon$) is then used to rewrap the monitored value ($\mval$) inside of a structural monitor ($\mathtt{smon}$) associated with the timeline.
%
Temporal monitors only exist at the top level, and so the context's ownership label \emph{must} be $\toplevel$.
%
Should the compilation of the temporal contract fail --- which would happen \eg if the PMSM is initially not accepting --- then the reduction would instead blame the contract in \namefmt{tmon-fail}.
%

%
The \namefmt{smon} rules handle the reduction of structural monitors.
%
Flat contracts (in \namefmt{smon-flat}) on constants are easily translated into a check on the contract.
%
Cons-list contracts (in \namefmt{smon-cons}) are also simple given our evaluation contexts: they are translated into an owned $\mathtt{cons}$, with each component appropriately wrapped by its respective structural contract: $\mscon_A$ for the \texttt{car} and $\mscon_D$ for the \texttt{cdr}.
%
%
Arrow contracts (in \namefmt{smon-arrow}), however, are more nuanced.
%
As we our temporal contracts reason over the calls and returns of functions, we cannot simply translate this into \eg\ $\slam{\mvar}{ \sSMon{k}{\mmlab}{j}{\mtimeline}{\mscon_R}{ \sapp{\mval}{\sSMon{\mmlab}{k}{j}{\mtimeline}{\mscon_D}{\mvar} }}}$.
%
Instead, we construct a blessed closure with all of the relevant information, and store the monitored value in the store at a fresh address (\maddr) and joined with any extant values at that same address ($\msto(\maddr)$).
%
We will perform the relevant checking upon application of the blessed closure (in \namefmt{call}).
%
Nevertheless, if the monitored value is not a function, then we fail and blame in a straightforward manner (in \namefmt{smon-arrow-fail}).
%

%
Blessed application (in \namefmt{call}) is quite involved.
%
As we discussed regarding arrow contracts, we cannot simply check the structural domain and range.
%
Instead, we must first check with any relevant PMSMs (through the $\delta{}step$ function) whether the call event which represents this application is permissible; if not, then the relevant rule is instead \namefmt{call-fail}, which blames the caller.
%
Assuming that the call is temporally permissible, then we construct an application expression ($\mexp_{call}$) which wraps the argument in a structural domain monitor.
%
In turn, we wrap \emph{that} expression in a structural range monitor, which itself is wrapped in a return event production (which will be handled in \namefmt{return}/\namefmt{return-fail}).
%
This formulation guarantees that a call event is produced \emph{before} the call actually occurs, which is obviously critical to the correctness of these temporal contracts.
%
Finally, note that the evaluation context's owner becomes the callee after this step (in line with the call).
%

%
To complete our modeling of temporal monitors, we must also represent return events; we do so in \namefmt{return}.
%
Once we have reduced an application to a value, we must note that the function which was called will now return.
%
Again, we check with any relevant PMSMs---using the $\delta{}step$ function---whether the return event is permissible; if not, then the relevant rule is instead \namefmt{return-fail}, which blames the callee.
%
Otherwise, we reduce to the return value.
%
This formulation guarantees that a return event is produced \emph{before} the return actually completes, again critical for correctness.
%
After this reduction step, the evaluation context's owner becomes that of the original caller again (in line with the return).
%
Note also that the returning context takes ownership of the returned value as well.
%

%%
\section{Pattern-matching state machines}
\FloatBarrier

%%
An important aspect of contract systems is that we don't have full knowledge of the program's future.
%
We don't have a full list of values that will be constructed, nor is it necessary to have this full list.
%
Thus, we separate out the control states---governing the progression through satisfying a temporal contract---from the bindings of names to values we encounter along the way.
%
Values will come from event constructors, and are allowed to be unbounded.
%
Unlike a conventional FSM, instead of transitioning by matching against atomic symbols, we allow for pattern matching against constructed data; this allows for the binding of subdata to variables for later equality checking.
%
We also scope bindings by simply $\alpha$-converting contracts to always use unique binders.
%

To do this, we consider a machine state to be a tuple of a control state and a binding environment, where transitions may change/use the environment when pattern matching on input.
%
Additionally, since we plan to later abstract our semantics (and values), we need a weaker, tunable notion of equality (\eg, is 1 equal to $\mathbf{Int}$? We must be conservative and consider both valid).
%
The atomic symbols therefore come equipped with a may/must/never equality-checking function.
%
A PMSM $\pmsmMachine$ is thus a tuple $(q_0, \simeq, \ary, \delta)$ where:
\begin{align*}
  \Sigma &\text{ a set of atoms} \\
  \simeq : \Sigma \times \Sigma \to \setof{\top, \bot, ?} &\text{ weak equality function}\\
  Q &\text{ a finite set of control states} \\
  C &\text{ a finite set of constructors} \\
  q_0 \in Q &\text{ initial state} \\
  \ary : C \to \Nat&\text{ the arity of constructors} \\
  \delta \subseteq Q \times \Pattern \times Q & \text{ transition relation}\\[2pt]
\end{align*}

\begin{property}
  For all $\matom, \matom' \in \Sigma$. $a \simeq a' = \top$ implies $a = a'$ and $a \simeq a' = \bot$ implies $a \neq a'$.
\end{property}
%
We consider all reachable states as accepting, except for the $\stfail$ state.
%
The pattern language consists of binding patterns, equality with reference patterns, wildcard and equality with a constant atom.
%
The syntax and semantics of matching patterns is in \autoref{fig:pattern-syntax}; notice that we do not change the binding environment for anti-matching ($!$) patterns.
%
Crucially, since we will need to form intersections between machines, we need a way to state that different variables will be bound to the same value, so each position in a constructor is allowed a \emph{set} of patterns to match.
%
Additionally, $\combinefalone$ on $\mbindenv$s is a right-biased finite function combination; we don't allow non-linear patterns (though it would be an easy extension) so the bias doesn't matter.
%
We lift $\simeq$ over constructors ($\simeq^\mconstructor$) by folding $\wedge$ over the data to compare atoms in the leaves.
%
\begin{figure}
  \begin{align*}
    \mpat \in \Pattern &::= \mconstructor(\mpat, \ldots_{\ary(\mconstructor)}) \alt \snonevent{\mconstructor(\mpat, \ldots_{\ary(\mconstructor)})} \\
     & \alt \swc \alt \sref{\mvar} \alt \sbind{\mvar} \alt \matom \alt \mpatset
      \quad\text{ where } \matom \in \Sigma
\\
    \mpatset \in \wp(\Pattern)
\\
    \mdata \in \Qualified &::= \mconstructor(\mdata, \ldots_{\ary(\mconstructor)}) \alt \matom
\\
    \mbindenv \in \BindEnv &= \Var \to \Qualified
\\
    t \in \Valuation &::= \top \alt\ ?
\\
    \MatchResult &::= \mfail \alt \smatch{\mbindenv}{t}
\\
    \match &: \Pattern \times \Qualified \times \BindEnv \to \MatchResult
\\
    \match(\swc, \mdata, \mbindenv) &= \smust{\mbindenv}
\\
    \match(\mpatset, \mdata, \mbindenv) &= \bigsqcup\limits_{\mpat \in \mpatset}{\match(\mpat, \mdata, \mbindenv)}
\\
    \match(\mconstructor(\mpat \ldots), \mconstructor(\mdata \ldots), \mbindenv) &=
      \bigsqcup\limits_i{\match(\mpat_i, \mdata_i, \mbindenv)}
\\
    \match(\snonevent{\mconstructor(\mpat \ldots)}, \mdata, \mbindenv) &=
      \left\{\begin{array}{ll}
               \smatch{\mbindenv}{\top} & \text{if } \mfail = \mres \\
               \smatch{\mbindenv}{?} & \text{if } \smatch{\mbindenv'}{?} = \mres \\
               \mfail & \text{if } \smatch{\mbindenv'}{\top} = \mres \\
             \end{array}\right.
    \\ \text{where }& \mres = \match(\mconstructor(\mpatset \ldots), \mdata, \mbindenv)
\\
    \match(\swc, \mdata, \mbindenv) &= \smatch{\mbindenv}{\top}
\\
    \match(\sref{\mvar}, \mdata, \mbindenv) &= \weakif(\mbindenv, \mdata \simeq^\mconstructor \mbindenv(\mvar))
\\
    \match(\sbind{\mvar}, \mdata, \mbindenv) &= \smatch{\mbindenv[\mvar \mapsto \mdata]}{\top}
\\
    \match(\matom, \matom', \mbindenv) &= \weakif(\mbindenv, \matom \simeq \matom')
\\
    \match(\mpat, \mdata, \mbindenv) &= \mfail \text{ otherwise}
\\[2pt]
    \weakif(\mbindenv, \bot) &= \mfail
\\
    \weakif(\mbindenv, t) &= \smatch{\mbindenv}{t} \text{ otherwise}
\\[2pt]
    \mfail \sqcup \mbindenv &= \mbindenv \sqcup \mfail = \mfail
\\
    \smatch{\mbindenv}{t} \sqcup \smatch{\mbindenv'}{t'} &= \smatch{\combinef{\mbindenv}{\mbindenv'}}{t \vee t'}
  \end{align*}
  \caption{Pattern syntax and semantics}
  \label{fig:pattern-syntax}
\end{figure}

%TODO: Do we need to define input-driven?
The machine is \emph{input-driven}, and a path through the machine is defined in \autoref{fig:pmsm-semantics}.
%
We will associate each temporal contract monitor with a state machine we generate from the temporal contract, where the data fed to the machine are call and return events that pass through the structural monitors associated with the timeline.
%
\begin{figure}
  \begin{align*}
    \mstate \in \State &::= \pmsmstate{\pmsmq, \mbindenv, t} \alt \stfail
  \end{align*}
  \begin{mathpar}
    \infer{(\pmsmq, \mpat, \pmsmq') \in \delta \\
             \smatch{\mbindenv'}{t'} = \match(\mpat, \mdata, \mbindenv)}
          {\pmsmstate{\pmsmq, \mbindenv, t} \pmsmstepd{\mdata}{\delta} \pmsmstate{\pmsmq', \mbindenv', t'}}
\\
    \infer{(\pmsmq, \mpat, \pmsmq') \in \delta \\
             \mfail = \match(\mpat, \mdata, \mbindenv)}
          {\pmsmstate{\pmsmq, \mbindenv, t} \pmsmstepd{\mdata}{\delta} \stfail}
\\
  \inferrule{ }{\mstate \multistepd{\epsilon}{\delta} \mstate}
\qquad
  \inferrule{\mstate \multistepd{\mtrace}{\delta} \mstate' \\
             \mstate' \pmsmstepd{\mdata}{\delta} \mstate''}
            {\mstate \multistepd{\mtrace\mdata}{\delta} \mstate''}
  \end{mathpar}
  \caption{PMSM semantics}
  \label{fig:pmsm-semantics}
\end{figure}

\subsection{Compiling temporal contracts to PMSMs}
%
The compilation process of a temporal contract to a PMSM is very similar to that of a regular expression to a NFA.
%
Negation is still cumbersome to deal with, so we cope with them by converting temporal contracts into a negative normal form before we start the translation.
%
\begin{figure}
  \begin{align*}
    \nnf(\stnot{(\stseq{\mtcon_0}{\mtcon_1})}) &=
      \stOr{\nnf(\stnot{\mtcon_0})}{\stseq{\nnf(\mtcon_0)}{\nnf(\stnot{\mtcon_1})}}
% XXX Is this the right def?
%      \stOr{(\stseq{\nnf(\stnot{\mtcon_0})}{\sddd})}{\stseq{\nnf(\mtcon_0)}{\nnf(\stnot{\mtcon_1})}}
\\
    \nnf(\stnot{\stnot{\mtcon}}) &= \stseq{\nnf(\mtcon)}{\sddd}
\\
    \nnf(\stnot{(\stOr{\mtcon_0}{\mtcon_1})}) &= \stAnd{\nnf(\stnot{\mtcon_0})}{\nnf(\stnot{\mtcon_1})}
\\
    \nnf(\stnot{(\stAnd{\mtcon_0}{\mtcon_1})}) &= \stOr{\nnf(\stnot{\mtcon_0})}{\nnf(\stnot{\mtcon_1})}
\\
    \nnf(\stnot{\mevent}) &= \stseq{\snonevent{\mevent}}{\sddd}
\\
    \nnf(\stnot{\snonevent{\mevent}}) &= \stseq{\mevent}{\sddd}
\\
    \nnf(\stnot{\stmany{\mtcon}}) &= \nnf(\stnot{\mtcon})
\\
    \nnf(\stnot{\stcall{\mname}{\mvar}{\mtcon}}) &= \stOr{(\stseq{\snonevent{\scallev{\mname}{\swc}}}{\sddd})}
                                                         {\stcall{\mname}{\mvar}{\nnf(\stnot{\mtcon})}}
\\
    \nnf(\stnot{\stret{\mname}{\mvar}{\mtcon}}) &= \stOr{(\stseq{\snonevent{\sretev{\mname}{\swc}}}{\sddd})}
                                                        {\stret{\mname}{\mvar}{\nnf(\stnot{\mtcon})}}
\\
    \nnf(\stnot{\sddd}) &= \stfail
\\
    \nnf(\stnot{\stfail}) &= \sddd
  \end{align*}
  Otherwise structurally distribute $\nnf$
  \caption{Temporal contract NNF translation}
  \label{fig:nnf}
\end{figure}
%%
\begin{theorem}
  $\denotetcon{\mtcon}{\mtimeline}{\menv} = \denotetcon{\nnf(\mtcon)}{\mtimeline}{\menv}$
\end{theorem}
\ifproof{
\begin{proof}
  By induction on the $\nnf$'s recursion scheme.
  \begin{byCases}
    \case{\stnot{(\stseq{\mtcon_0}{\mtcon_1})}}{
      By IH, it suffices to show
$\forall \mtcon_0 \mtcon_1 \mtimeline \menv. \denotetcon{\stnot{(\stseq{\mtcon_0}{\mtcon_1})}}{\mtimeline}{\menv} = \denotetcon{\stOr{\stnot{\mtcon_0}}{\stseq{\mtcon_0}{\stnot{\mtcon_1}}}}{\mtimeline}{\menv}$
($\Rightarrow$) Let $\mtrace \in \denotetcon{\stnot{(\stseq{\mtcon_0}{\mtcon_1})}}{\mtimeline}{\menv}$ be arbitrary.
By cases on $\mtrace$ prefixed by some $\mtrace_p \in \denotetcon{\mtcon_0}{\mtimeline}{\menv}$:
\begin{byCases}
  \case{\exists \mtrace_r. \mtrace = \mtrace_p \cdot \mtrace_r}{
   By cases on $\mtrace_r$ prefixed by a trace in $\denotetcon{\mtcon_1}{\mtimeline}{\menv}$:
   \begin{byCases}
     \case{\exists \mtrace' \in \denotetcon{\mtcon_1}{\mtimeline}{\menv}, \mtrace''. \mtrace_r = \mtrace'\cdot\mtrace''}{
       Contradiction, since $\mtrace_p\cdot\mtrace' \in \denotetcon{\stseq{\mtcon_0}{\mtcon_1}}{\mtimeline}{\menv}$ is a prefix of $\mtrace$}
     \case{\forall \mtrace' \in \denotetcon{\mtcon_1}{\mtimeline}{\menv}, \mtrace''. \mtrace_r \neq \mtrace'\cdot\mtrace''}{
       It follows that $\mtrace_r \in \denotetcon{\stnot{\mtcon_1}}{\mtimeline}{\menv}$ and thus $\mtrace \in \denotetcon{\stseq{\mtcon_0}{\stnot{\mtcon_1}}}{\mtimeline}{\menv}$.
     }\end{byCases}
   }
  \case{\forall \mtrace_p \in \denotetcon{\mtcon_0}{\mtimeline}{\menv}, \mtrace_r. \mtrace \neq \mtrace_p \cdot \mtrace_r}{This is another way to state $\mtrace \in \denotetcon{\stnot{\mtcon_0}}{\mtimeline}{\menv}$.}
\end{byCases}
($\Leftarrow$) Let $\mtrace \in \denotetcon{\stOr{\stnot{\mtcon_0}}{\stseq{\mtcon_0}{\stnot{\mtcon_1}}}}{\mtimeline}{\menv}$ be arbitrary.
    Let $\mtrace' \in \denotetcon{\stseq{\mtcon_0}{\mtcon_1}}{\mtimeline}{\menv}$ be arbitrary.
    If $\exists \mtrace_r. \mtrace = \mtrace' \cdot \mtrace_r$,
    then since $\exists \mtrace_p\in \denotetcon{\mtcon_0}{\mtimeline}{\menv}, \mtrace_q\in \denotetcon{\mtcon_1}{\mtimeline}{\menv} . \mtrace' = \mtrace_p \cdot \mtrace_q$,
    $\mtrace = \mtrace_p\cdot\mtrace_q\cdot\mtrace_r$, which is a contradiction.}
%
  \case{\stnot{\stnot{\mtcon}}}{
    By IH, it suffices to show $\forall \mtcon, \mtimeline,\menv. \denotetcon{\stnot{\stnot{\mtcon}}}{\mtimeline}{\menv} = \denotetcon{\mtcon}{\mtimeline}{\menv}$.
\\
($\Rightarrow$) Let $\mtrace \in \denotetcon{\stnot{\stnot{\mtcon}}}{\mtimeline}{\menv}$ be arbitrary.
We show $\exists \mtrace_p \in \denotetcon{\mtcon}{\mtimeline}{\menv}, \mtrace_r. \mtrace = \mtrace_p \cdot \mtrace_r$.
Suppose not for contradiction.
Thus $\forall \mtrace_p \in \denotetcon{\mtcon}{\mtimeline}{\menv}, \mtrace_r. \mtrace \neq \mtrace_p \cdot \mtrace_r$.
This means, by definition, $\mtrace \in \denotetcon{\stnot{\mtcon}}{\mtimeline}{\menv}$.
However, by case assumption $\forall \mtrace_p \in \denotetcon{\stnot{\mtcon}}{\mtimeline}{\menv}, \mtrace_r. \mtrace \neq \mtrace_p \cdot \mtrace_r$, so with $\mtrace_p = \mtrace, \mtrace_r = \epsilon$ we derive a contradiction.
Therefore $\mtrace \in \denotetcon{\stseq{\mtcon}{\sddd}}{\mtimeline}{\menv}$.
\\
($\Leftarrow$) Let $\mtrace \in \denotetcon{\stseq{\mtcon}{\sddd}}{\mtimeline}{\menv}$ be arbitrary.
By definition, $\exists \mtrace_p\in\denotetcon{\mtcon}{\mtimeline}{\menv},\mtrace_r.\mtrace = \mtrace_p \cdot \mtrace_r$.
Let $\mtrace_n \in \denotetcon{\stnot{\mtcon}}{\mtimeline}{\menv}$ be arbitrary.
We show $\mtrace_n$ is not a prefix of $\mtrace$.
Suppose it were, for contradiction.
Then, $\exists \mtrace_q. \mtrace = \mtrace_n \cdot\mtrace_q$.
Since $\forall \mtrace_u \in \denotetcon{\mtrace}{\mtimeline}{\menv}$, $\mtrace_u$ is not a prefix of $\mtrace_n$
    }
%
    \case{\stnot{(\stOr{\mtcon_0}{\mtcon_1})}}{...}
%
    \case{\stnot{(\stAnd{\mtcon_0}{\mtcon_1})}}{...}
%
    \case{\stnot{\mevent}}{...}
%
    \case{\stnot{\snonevent{\mevent}}}{...}
%
    \case{\stnot{\stmany{\mtcon}}}{...}
%
    \case{\stnot{\stcall{\mname}{\mvar}{\mtcon}}}{...}
%
    \case{\stnot{\stret{\mname}{\mvar}{\mtcon}}}{...}
%
    \case{\stnot{\sddd}}{...}
%
    \case{\stnot{\stfail}}{...}
%
    \otherwise{Structural cases follow by direct application of the induction hypothesis.}
  \end{byCases}
\end{proof}
}
The translation easily follows if we temporarily allow $\epsilon$ transitions that we later remove (that is, the $\Pattern$ component of $\delta$ may also be an $\epsilon$).
%
To remove $\epsilon$ transitions, we elaborate the transition relation in the following way:
\begin{align*}
  \epsclose(\delta) &= \setbuild{(\pmsmq, \mpat, \pmsmq')}{(\pmsmq_0, \mpat, \pmsmq_1) \in \delta, \pmsmq \in \pmsmq_0^\epsilon, \pmsmq' \in \pmsmq_1^\epsilon}
\end{align*}
where $\pmsmq_0 \in \pmsmq_1^\epsilon$ is defined as the least fixed point of the following rules:
\begin{mathpar}
  \inferrule{ }{\pmsmq \in \pmsmq^\epsilon} \qquad
  \inferrule{(\pmsmq, \epsilon, \pmsmq') \in \delta}{\pmsmq' \in \pmsmq^\epsilon} \qquad
  \inferrule{\pmsmq_0 \in \pmsmq^\epsilon \\ \pmsmq_1 \in \pmsmq_0^\epsilon}{\pmsmq_1 \in \pmsmq^\epsilon}
\end{mathpar}

\begin{lemma}
  $\matchstate \multistepd{\mtrace}{\delta} \matchstate'$ iff
  $\matchstate \multistepd{\mtrace}{\epsclose(\delta)} \matchstate'$
\end{lemma}
\begin{proof}
  By induction on $\mtrace$.
\end{proof}
%
\begin{align*}
 s \in \QState &::= q_i \alt \pmsmpair{s}{s} \text{ where } i \in \Nat
\\
 \translateeps &: \TContract \times \Timeline \to \PMSM
\\
 \translateeps(\mtcon, \mtimeline) &= (\pmsmq_0, \lambda x,y . x = y, \ary, \epsclose(\delta)) \\
 \text{where }
   (\delta, \pmsmqlast, k) &= \epshelp^\mtimeline(\mtcon, \pmsmq_0, 1, \emptyset, \setof{\pmsmq_0})
\\
   \ary(\apvcallalone) &= 2 \\
   \ary(\apvretalone) &= 2 \\
   \ary(\bclos{\swc}{\swc}{\swc}{\swc}{\swc}{\swc}{\swc}{\swc}) &= 8 \\
\\
\begin{array}{l}
    \epshelp :  \Timeline \times \TContract \times \QState \times \Nat \\ \phantom{\epshelp :}\to \mathit{Transition} \times \wp(\QState) \times \QState \times \Nat
\end{array}\span\omit
\end{align*}

%FIXME: Pretty terrible
and:

\begin{align*}
\begin{array}{l}
  \epshelp^\mtimeline(\scallev{\mvar}{\mvpat'}, \pmsmqcur, k, \delta) = \\
\quad           (\delta
            \cup \setof{(\pmsmqcur,
                         \apvcall{\sref{\mvar}}{\vpatToPattern(\mvpat)},
                         \pmsmq_k)}, \\
\quad            \ \pmsmq_k, k+1)
\\[2pt]
%
  \epshelp^\mtimeline(\scallev{\mtoplevelname}{\mvpat'}, \pmsmqcur, k) = \\
\quad           (\setof{(\pmsmqcur,
                         \apvcall{\bclos{\mtoplevelname}{\swc}{\swc}{\swc}{\mtimeline}{\swc}{\swc}{\swc}}{\vpatToPattern(\mvpat)},
                         \pmsmq_k)}, \\
\quad            \ \setof{\pmsmqcur, \pmsmq_k}, \pmsmq_k, k+1)
\\
\begin{array}{ll}
  \vpatToPattern(\swc, \mtimeline) &= \swc
\\
  \vpatToPattern(\mvar, \mtimeline) &= \sref{\mvar}
\\
  \vpatToPattern(\mtoplevelname, \mtimeline) &= \bclos{\mtoplevelname}{\swc}{\swc}{\swc}{\mtimeline}{\swc}{\swc}{\swc} \\
  \vpatToPattern(\mconstant, \mtimeline) &= \mconstant
\end{array}
\end{array}
\end{align*}
Return events are similarly translated, and binding events are similar to their non-binding counterparts, only the created final state becomes the initial state for constructing the machine for the following contract.

The translation for ``or'' is similar to constructing the union of NFAs.
%
We simply thread through a source of freshness for constructing new states.
%
\begin{align*}
  \begin{array}{l}
  \epshelp^\mtimeline(\stOr{\mtcon_0}{\mtcon_1}, \pmsmqcur, k) = \\
    (\delta\cup \delta' \cup
    \left\{\begin{array}{ll}
        (\pmsmqlast^0, \epsilon, \pmsmq_{k''}),&
        (\pmsmqcur, \epsilon, \pmsmq_k),\\
        (\pmsmqlast^1, \epsilon, \pmsmq_{k''}),&
        (\pmsmqcur, \epsilon, \pmsmq_{k+1})
      \end{array}\right\},
    \\
    \ \pmsmq_{k''}, k''+ 1)
    \\
  %
    \text{where } (\delta, \pmsmqlast^0, k') = \epshelp^\mtimeline(\mtcon_0, \pmsmq_k, k+2) \\
    \phantom{\text{where }} (\delta', \pmsmqlast^1, k'') = \epshelp^\mtimeline(\mtcon_1, \pmsmq_{k+1}, k')
  \end{array}
\end{align*}

Kleene star is a simple pair of epsilon transitions:
\begin{align*}
  \begin{array}{l}
  \epshelp^\mtimeline(\stmany{\mtcon}, \pmsmqcur, k) = \\
  (\delta \cup \left\{
    \begin{array}{l}
      (\pmsmqcur, \epsilon, \pmsmqlast), \\
      (\pmsmqlast, \epsilon, \pmsmqcur)
    \end{array}\right\},
  \pmsmqlast, k')
 \\ \text{where } (\delta, \pmsmqlast, k') = \epshelp^\mtimeline(\mtcon, \pmsmqcur, k)
\end{array}
\end{align*}

Concatenation uses the first contract's final state as the initial state for the following contract's machine:
\begin{align*}
  \begin{array}{l}
    \epshelp^\mtimeline(\stseq{\mtcon_0}{\mtcon_1}, \pmsmqcur, k) = 
     (\delta \cup \delta', \pmsmqlast^1, k'')
   \\ \text{where } (\delta, \pmsmqlast^0, k') = \epshelp^\mtimeline(\mtcon_0, \pmsmqcur, k)
   \\\phantom{\text{where }} (\delta', \pmsmqlast^1, k'') = \epshelp^\mtimeline(\mtcon_1, \pmsmqlast^0, k')
  \end{array}
\end{align*}
%

Intersection has the most complex construction, so we saved it for last.
%
In order to avoid an exponential explosion of states that we must construct \emph{up-front}, we neither determinize the machines nor then perform the standard DFA intersection construction.
%
Instead, we simply remove $\epsilon$ transitions and construct the product automaton from that, since we will then make the two machines sync up in terms of input consumed across transitions.
%
Unlike NFAs, we do not have a finite alphabet to enumerate, so instead we combine patterns to check dynamically, which is where the sets of patterns come into play.
%
The final state of the construction is just the pair of each machine's final states.
\begin{align*}
  \begin{array}{l}
  \epshelp^\mtimeline(\stAnd{\mtcon_0}{\mtcon_1}, \pmsmqcur, k) = \\
  (\left\{(\pmsmpair{\pmsmqq_0}{\pmsmqq_1}, \mpat'', \pmsmpair{\pmsmqq'_0}{\pmsmqq'_1}) :
          \begin{array}{l}
                (\pmsmqq_0, \mpat, \pmsmqq'_0) \in \epsclose(\delta),\\
                (\pmsmqq_1, \mpat', \pmsmqq'_1) \in \epsclose(\delta'), \text{ and}\\
                \mpat'' = \combinepat{\mpat}{\mpat'}
           \end{array} \right\},\\
  \ \pmsmpair{\pmsmqlast^0}{\pmsmqlast^1}, k'') \\
  \text{where } (\delta, \pmsmqlast^0, k') = \epshelp^\mtimeline(\mtcon_0, \pmsmqcur, k) \\
  \phantom{\text{where }} (\delta', \pmsmqlast^1, k'') = \epshelp^\mtimeline(\mtcon_1, \pmsmqcur, k')
\end{array}
\end{align*}
%
Pattern combination ($\combinepatalone$) could just throw both patterns into a set together and wait to fail if there is no overlap.
%
However, we're a bit more proactive than that and rule out patterns that outright don't match, such as disequal constants or patterns with separate constructors.
%
The definition is a bit tedious and obvious, so we leave it informally specified for space.

\begin{theorem}[Soundness]
  If $\mtrace \in \denotetcon{\mtcon}{\mtimeline}{\menv}$ then $\exists \pmsmqq, \menv', t$.
%
  $\pmsmstate{\pmsmqcur, \menv, \top} \multistepd{\mtrace}{\delta} \pmsmstate{\pmsmqq, \menv', t}$ is a well-formed trace (the function positions of matched events are all on $\mtimeline$)
%
  where $(\delta, \pmsmqlast, k') = \epshelp^\mtimeline(\mtcon, \pmsmqcur, k)$
\end{theorem}
\begin{proof}
  By induction on $\mtcon$ and then $\mtrace$.
\end{proof}
%
\begin{theorem}[Concrete completeness]
  If $\exists \pmsmqq, \menv'$.
%
  $\pmsmstate{\pmsmqcur, \menv, \top} \multistepd{\mtrace}{\delta} \pmsmstate{\pmsmqq, \menv', \top}$ is a well-formed trace,
  then $\mtrace \in \denotetcon{\mtcon}{\mtimeline}{\menv}$.
  If $\pmsmstate{\pmsmqcur, \menv, \top} \multistepd{\mtrace}{\delta} \stfail$ is a well-formed trace, then $\mtrace \notin \denotetcon{\mtcon}{\mtimeline}{\menv}$
%
  where $(\delta, \pmsmqlast, k') = \epshelp^\mtimeline(\mtcon, \pmsmqcur, k)$
\end{theorem}
\begin{proof}
  By induction on $\mtcon$ and then $\mtrace$.
\end{proof}
%
When $\simeq$ never has uncertainty, such as in the concrete semantics, this machine accepts only traces that are in the denotation of the contract it was compiled from.
%
This theorem ensures us our monitoring system is correct (provided the semantics only provides well-formed traces, which it does).

The reduction semantics (\autoref{sec:reduction}) uses this monitor construction via the following metafunctions:
\begin{align*}
  \compile{\mtcon}{\mtimeline} &= \npmsm{\setof{\pmsmstate{\pmsmq_0, \bot, \top}}}{\translateeps(\mtcon, \mtimeline)} \\
  \sstep{\mTMons}{\mtimeline}{\mevent} &= T \cup F \\
    \text{where } {\mathcal S} &= \left\{
\ensuremath{
      \begin{array}{ll}
        \npmsm{S'}{\pmsmMachine} : &
        \begin{array}{l}
\npmsm{S}{\pmsmMachine} \in     \mTMons(\mtimeline) \\
 S' = \setbuild{\mstate'}{\mstate \in S, \mstate \pmsmstepd{\mevent}{\delta_\pmsmMachine} \mstate'}
\end{array}
      \end{array}
}\right\}
\\\phantom{\text{where }} T &= \setbuild{\mTMons[\mtimeline \mapsto {\mathcal S}]}{\npmsm{S}{\pmsmMachine} \in {\mathcal S}, S \neq \setof{\stfail}}
\\\phantom{\text{where }} F &= \left\{\stfail : \npmsm{S}{\pmsmMachine} \in {\mathcal S},
  \begin{array}{l}
S = \setof{\stfail} \text{ or } \\
\forall \mstate\equiv\pmsmstate{\pmsmqq, \mbindenv, t}\in S. t \neq \top
\end{array}\right\}
\end{align*}
We store several machines in one timeline in anticipation of abstract aliasing --- that is, we cannot always create fresh timelines, and thus merge two together by saying the timeline is in one of a set of possible states.
%
The additional set comprehension is because these machines are non-deterministic, so we must step all states in which that machine \emph{might} be.
%
If the only possible state in which the machine can be is $\stfail$, or there are no sure ways to accept (no state with $\top$ valuation), there is a cause for blame.
%
Since there are several machines that could describe the timeline at one time, we return a set of possibilities: either there is a definitive failure $\setof{\bot}$, definitive success $\setof{\mTMons'}$, or a possible success $\setof{\mTMons', \bot}$.

\section{Abstract semantics}

We use the AAM approach to soundly approximate our concrete semantics.
%
This first requires a CESK-like machine to transform, but there are known ways to systematically transform Felleisen-style reduction semantics into corresponding CESK machines ~\citep{?}.
%
The important aspect of the abstraction process is not this transformation, but the fact that the space of values becomes \emph{finite}, meaning the space of PMSM machine configurations is finite.
%
Therefore, the only aspects of PMSMs that we need to tamper with are allowing binding to sets of values, and the notion of equality, to weaken it to be conservative with our abstractions.
%
In our semantics with just closures, conses, booleans and integers, we consider syntactically equal closures and conses to be \emph{maybe} equal, equal booleans and integers to be \emph{must} equal, integer comparisons with the abstract $\mathbf{Int}$ element to be \emph{maybe} equal (assuming a simple flat abstraction of the integers) and all other possibilities \emph{never} equal.
%
This notion of equality lifts over sets of values in the obvious way.
%
There are several different techniques that we could apply in order to improve the precision of the analysis:
\begin{itemize}
\item{use abstract counting ~\citep{dvanhorn:Might:2006:GammaCFA} to improve equality checking of allocated data;}
\item{use abstract garbage collection~\citep{dvanhorn:Might:2006:GammaCFA} to remove dead temporal monitors;}
\item{use abstract garbage collection to remove bindings to dead values in live temporal monitors, considering a monitor transition that dereferences a dangling pointer to represent an impossible state (and thus can be discarded);}
\item{separate continuation management to a pushdown abstraction~\citep{dvanhorn:Vardoulakis2011CFA2}; or}
\item{use a polyvariant allocation strategy such as $m$-CFA ~\citep{dvanhorn:Might2010Resolving} or polymorphic splitting~\citep{dvanhorn:wright-jagannathan-toplas98}.}
\end{itemize}
%
We leave this exploration and evaluation of possibilities to future work.
%%

\section{Evaluation}
%%

%%
Our examples didn't take hours to check!
%
Our model is available online \footnote{\url{http://github.com/ianj/temporal-aam}}.
%%

%%
\section{Conclusion}
%%

%%
Shit works.
%%
