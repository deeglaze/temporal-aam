\section{Introduction}

Software systems are large, consist of many modules, and have invariants that are either outright inexpressible or too costly to express (and prove) in the language's static type system --- if it has one.
%
When this is the case, one might hope to rely on software contracts~\cite{dvanhorn:meyer-eiffel} to give dynamic guarantees about the behavior of one's system.
%
In modern, higher-order languages, the question of ``who violated the contract?'' becomes non-trivial, and we graduate to higher-order contracts ~\citep{dvanhorn:Findler2002Contracts} to blame the correct party responsible for any violation of these invariants.
%
A proposed system of \emph{temporal higher-order contracts}~\citep{ianjohnson:dfm:icfp2011} (henceform DFM) provides a linguistic mechanism to describe temporal properties of behavioral values flowing through the program.
%
%when traditionally such properties are checked extra-linguistically by model-checking an abstracted form of the program.
%
Example temporal properties are, ``a file can only be closed if it has been opened'' and, in the higher-order setting, ``if function A is given a function B, then that B may not be called once A returns.''
%
Such invariants are important for interfaces that have set-up and tear-down protocols to follow, or even pure interfaces that have particular compositions of calls needed to construct some object.
%%

%%
There are downsides to software contracts, however.
%
Since contracts are strictly for runtime monitoring, they do not themselves ensure correctness --- they help the process of constructing correct programs.
%
In addition, contracts can introduce considerable overhead to the program.
%
These may be acceptable costs to pay at the beginning of development, but model-checking provides an additional level of confidence in correctness or pinpoints means for failure.
%
A sound model checker can justify safely removing contract checking and have a performance-and-correctness return on the initial investment.
%%

%%
Temporal contracts pose an additional challenge over higher-order function contracts to statically verify, as they monitor extended interactions with a module, and not just localized pieces.
%
We propose a framework that is composable with techniques to verify functional contracts, that has low technical overhead (\eg, no translation to a model-checker's language necessary).
%
The technique uses the Abstracting Abstract Machines (AAM) approach \citep{dvanhorn:VanHorn2010Abstracting} to check for reachability of a temporal contract blame.
%%

%%
AAM was originally targeted towards describing flow analyses, but is robust enough to apply to model-checking safety properties of higher-order programs.
%
It is well-known that control-flow analysis can be stated in terms of model-checking~\citep{ianjohnson:analysis-is-mc}, but this observation is misleading; one must use a quadratic number of model-checking queries to discover what a monovariant flow analysis can discover in one run.
%
In general, the queries are at least linear in the size of the abstract value space, which is exponential in some polyvariant analyses such as 1-CFA. % TODO: cite Van Horn, Mairson?
%
The value space tends to be sparse in practice, but an ahead-of-time query generator cannot discover it without a polyvariant analysis.
%
The realm of temporal contract verification is similar: to use a model-checker, we would have to run a data-flow analysis up front in order to collect values that might be used as bindings, enumerate all possible binding/reference insantiations of the temporal contract, and then translate those contracts into LTL queries --- much more work than just running the program abstractly and reporting reachable blame states.
%

%%
Our contributions in this paper are as follows:
\begin{itemize}
 \item{an alternative to \dfm's temporal contract semantics amenable to analysis yet faithful to their examples;}
 \item{a notion of derivative for regular expressions with back-references;}
 \item{a sound abstraction to computably verify temporal contract satisfaction.}
\end{itemize}
%%

%%
\section{Overview of temporal higher-order contracts}
%%

%\FloatBarrier
\input{overview}
%%
\section{Semantics of Temporal Contracts} \label{sec:temporal-semantics}

\input{tconsem}

%%
\section{Semantics}\label{sec:technical}

\input{langsem}
%%

\section{Abstract semantics}

We use the AAM approach to soundly approximate our concrete semantics.
%
This first requires a CESK-like machine to transform, but there are known ways to systematically transform Felleisen-style reduction semantics into corresponding CESK machines ~\citep{dvanhorn:Danvy-Nielsen:RS-04-26}.
%
The important aspect of the abstraction process is not this transformation, but the fact that the space of values becomes \emph{finite}, meaning the space of temporal contract derivatives is finite (proven via simple coinduction).
%
In our semantics with just closures, conses, booleans and integers, we consider:
\begin{itemize}
 \item syntactically equal closures and conses to be ``\emph{maybe}-equal'';
 \item equal booleans and integers to be ``\emph{must}-equal'';
 \item integer comparisons with the abstract $\mathbf{Int}$ element to be ``\emph{maybe}-equal'' (assuming a simple flat abstraction of the integers);
 \item and all other possibilities to be ``\emph{never}-equal''.
\end{itemize}
%
Any time a temporal contract is in a \emph{may} state, we blame conservatively.
%
Since timelines can be abstractly allocated more than once, each time we send an action to the monitor, we have to both step and not step the contract, which can kill precision and performance.
%
On top a basic abstraction from AAM, we evaluate the following techniques to improve the precision of the analysis:
\begin{itemize}
\item{($\mu$) use abstract counting ~\citep{dvanhorn:Might:2006:GammaCFA} to improve equality checking of allocated data and provide a non-trivial $\gamma_1?$;}
\item{($\Gamma$) use abstract garbage collection~\citep{dvanhorn:Might:2006:GammaCFA} to remove dead temporal monitors;}
\item{($\Gamma_\tau$) use abstract garbage collection to remove bindings to dead values in live temporal monitors.
%
This means we reduce $\mtcon,\menv$ to $\mtcon,\menv'$, where $\menv'$ restricts variables to the values in $\menv$ that touch only reachable addresses.
%
The concrete semantics would operate the same way regardless of GC, but this is akin to using weak boxes to maintain values in temporal contract environments;}
\item{($\Xi$) separate continuation management to a pushdown abstraction~\citep{dvanhorn:Vardoulakis2011CFA2}.}%; or}
%\item{use a polyvariant allocation strategy such as $m$-CFA ~\citep{dvanhorn:Might2010Resolving} or polymorphic splitting~\citep{dvanhorn:wright-jagannathan-toplas98}.}
\end{itemize}
%%

\section{Evaluation}
%%

\begin{figure}
  \input{bench-overview}
  \caption{Benchmark results. Numbers are run-time (sec) / $\frac{\text{spurious blames}}{\text{possible blames}}$}
  \label{fig:evaluation}
\end{figure}
%%
We built temporal higher-order contracts into our existing framework for analyzing a subset of Scheme \footnote{Model and benchmarks available online \url{http://github.com/dvanhorn/oaam/tree/thocon}}.
%
Our benchmarks are a collection of examples from \dfm's paper and implementation:
\paragraph{{\tt sort1}:}{\dfm's motivating example of a non-reentrant sort function where the given comparison function may not be called after sort returns\footnote{If sort stashes the comparator in a global and we call it afterwards, \dfm's implementation does not raise blame, whereas ours does.}.
%
The structural contract for {\tt sort1} is weak: {\tt (listof integer?) -> any/c}.
}
\paragraph{{\tt sort2}:}{like {\tt sort1}, but with a stronger structural contract that will confuse a regular analysis: {\tt (listof integer?) -> (listof integer?)}.}
\paragraph{{\tt sort3}:}{like {\tt sort2}, but call sort more than once (mapped over a list of lists), in order to confuse non-$\Gamma_\tau$ analyses.}
\paragraph{{\tt malloc}:}{A pair of two functions, malloc and free, where malloc returns an ever-growing counter and free does nothing. They are contracted so that free may not be called with addresses that were previously freed and not subsequently returned by malloc.}
\paragraph{{\tt file}:}{A function, {\tt open}, which given a file path, produces a list of read, write and close functions. They are contracted such that none of these functions may be called after close. Using this interface, we copy the contents of files in one list and write them to the files in the other.}
%\paragraph{{\tt FTP}:}{An FTP server built on TCP. \textbf{TODO: Alex}}
%%

%%
The analysis results and run times for our benchmark programs are in \autoref{fig:evaluation}, categorized by the additional machinery as labeled in the previous section ($m$ means used more than 2GiB limit).
%
Analyses without garbage collection used the global store widening to accelerate convergence.
%%

%%
The minor variations to the sort example motivated our additional analytical machinery.
%, \textbf{TO BE SEEN} and proved strong enough to verify the more complicated example of the FTP interaction.
%
No technique we employed could fully verify the {\tt malloc} example, since the protocol depends on being able to prove equality between values that are mutated and grown without bound; our abstraction for numbers is simple, so the mutated counter immediately jumps to \textbf{Int}$\top$, where comparisons conservatively both succeed and fail.
%
The {\tt file} example could be verified had we used a polyvariant allocation strategy, since it involved opening two files at the same time with the same handle allocation code.
%%

%%
Notice that without a pushdown abstraction, abstract garbage collection searched a state space orders of magnitude more than with.
%
The $\Gamma$ and $\Gamma_\tau$ implementations do not use a pushdown abstraction, but they still can verify {\tt sort2}, which was meant to confound non-pushdown analyses.
%
The reason for this is that in AAM, continuations are allocated on the heap, so GC can reclaim them for better return flow predicition; recursive calls do not get the same precision boost.
%
The topic of making abstract GC more performant and feasible is an active area of research, most recently extended to pushdown abstractions \citep{dvanhorn:Earl2012Introspective}.
%
Although greater precision can increase the possible state space, clever abstractions combined with typical program structure can actually reduce the explored state space, as is evident by the dearth of visited blame sites in our most precise implementation.

%%
\section{Related Work}
%%

\input{related}
%%
\section{Conclusion and future work} \label{sec:conclusion}
%%

%%
We demonstrated that a linguistic construction for monitoring temporal properties of higher-order programs (temporal higher-order contracts) can be transparently abstracted to provide a sound verification algorithm, almost for free, given the AAM approach.
%
Our preliminary evaluation provides evidence that this can be an effective approach to verifying programs with finite protocols, given the right combination of existing analysis machinery.
%
The way forward is clear: build a quality temporal monitoring library and contract a large project to find weaknesses in the language of temporal contracts, and finally evaluate the verification algorithm on this large example.
%
Potential weaknesses we can identify:
\begin{itemize}
\item{the blame story needs better understanding, with deotonic logic:
%
currently, the party that generates the action that causes a contract to fail gets blamed, and there is no way to express that some action must happen before the end of the monitor's lifetime.
%
The action-emitting party might be innocent, just working at the behest of a different party that is obliged not to violate the contract.
%
Instead of attaching a temporal contract to a single structural contract with the {\tt tmon} form, we instead allow structural contracts to \emph{emit} temporal contracts as obligations of a given party, and additionally blame for unfinished obligations at monitor collection time, end of execution, or after a specified amount of time;
}
%
\item{calls and returns don't match in the temporal contracts themselves:
%
the actions are currently interpreted without a notion of matching, which could turn out to be too flat and limiting for proper specifications --- the implementation from \dfm{} allows labeling calls so that return actions can refer to the matching call.
%
It is unclear whether an analysis can precisely match calls and returns in both the contracts and control-flow, due to the several stacks that apparently entails, but at least a ``good enough'' approximation should exist;
}
%
\item{some specifications are better suited to DLTL or state machines:
%
some examples in \dfm's test suite included using side effects in the temporal monitor's matching to encode state transitions.
To more adequately handle this idiom without sophisticated handling of side-effects, we may wish to mix and match ways in which we express properties.
%
For example, a contract in a different language is considered primitive, and only continues when the contract is accepting (much like sequence contracts work now).
}
%
\item{whole program analysis is intractible at scale:
%
we can verify on a per-module basis if we add temporal contracts to a semantics of partial programs, such as in \citet{dvanhorn:TobinHochstadt2012Higherorder}.
%
The primary difficulty there is a sound definition of {\tt havoc} in the presence of temporal contracts, which simulates all possible interactions with a module.
%
Additional concerns lie in adequately maintaining enough information about unknown values to prune search space, without also exploding the search space with all the distinguished unknown values, but there is existing work on this that we can leverage~\citep{ianjohnson:DBLP:journals/cacm/DilligDA10}.
}
\end{itemize}
%
%
