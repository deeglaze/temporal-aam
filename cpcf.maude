load full-maude26.maude . select FULL-MAUDE . loop init . load model-checker.maude .

***( Stupid boilerplate)
fmod ToDefine is
  pr STRING .
  pr INT .
  sorts VAR Name ΛTName Addr Label Timeline Toplevel ΛTimeline .
  op Λ : -> Toplevel [ctor] .
  op nΛ : Name -> ΛName [ctor] .
  op tΛ : Timeline -> ΛTimeline [ctor] .
  subsorts Toplevel < Timeline < ΛTimeline .
  subsorts Toplevel < ΛName < Name .
  subsorts Timeline < Addr < Name < VAR < String . *** Get around preregularity with arbitrary ordering .
  subsorts MLabel < Label < Int .
  subsorts Label < Addr .
  op vv_ : String -> VAR [ctor] .
  op aa_ : String -> Addr [ctor] .
  subsorts Toplevel < MLabel .
  sorts LCTerm Value Prim Binding Point State StateStamp Frame Reducts HeapDelta KHeapDelta Unit .
  sorts Contract SContract TContract .
  op nul : -> Unit [ctor] .
endfm

view String from TRIV to STRING is sort Elt to String . endv
view VAR from TRIV to ToDefine is sort Elt to VAR . endv
view Addr from TRIV to ToDefine is sort Elt to Addr . endv
view Timeline from TRIV to ToDefine is sort Elt to Timeline . endv
view Binding from TRIV to ToDefine is sort Elt to Binding . endv
view LCTerm from TRIV to ToDefine is sort Elt to LCTerm . endv
view Contract from TRIV to ToDefine is sort Elt to Contract . endv
view SContract from TRIV to ToDefine is sort Elt to SContract . endv
view TContract from TRIV to ToDefine is sort Elt to TContract . endv
view Value from TRIV to ToDefine is sort Elt to Value . endv
view Frame from TRIV to ToDefine is sort Elt to Frame . endv
view State from TRIV to ToDefine is sort Elt to State . endv
view Point from TRIV to ToDefine is sort Elt to Point . endv
view StateStamp from TRIV to ToDefine is sort Elt to StateStamp . endv

fmod AVal is pr SET{Value} * (sort Set{Value} to AVal) . endfm
fmod AKnt is pr SET{Kont} * (sort Set{Kont} to AKnt) . endfm
view AVal from TRIV to AVal is sort Elt to AVal . endv

fmod Env is
 pr ToDefine .
 pr MAP{VAR, Addr} * (sort Map{VAR, Addr} to Env) .
endfm

view List`{LCTerm`} from TRIV to LIST{LCTerm} is
  sort Elt to List{LCTerm} .
endv

fmod OPTION{X :: TRIV} is
 sort Option{X} .
 op Some : X$Elt -> Option{X} [ctor] .
 op None : -> Option{X} [ctor] .
endfm

fmod LCTerms is
  pr ToDefine .
  pr LIST{LCTerm} * (sort List{LCTerm} to LCTerms) .
endfm

fmod Bindings is
  pr ToDefine .
  pr LIST{Binding} * (sort List{Binding} to Bindings) .
endfm

mod Syntax is
  pr BOOL .
  pr INT .
  pr Env .
  pr LCTerms .
  pr LIST{VAR} * (sort List{VAR} to ListVar) .
  pr LIST{Addr} * (sort List{Addr} to ListAddr) .
  pr LIST{Contract} .
  pr Bindings .
  pr OPTION{VAR} * (sort Option{VAR} to VARop) .

  *** Terms ***
  op Var : Label VAR -> LCTerm [ctor] .
  op Lit : Label Int -> LCTerm [ctor] .
  op Lit : Label Bool -> LCTerm [ctor] .
  op Lit : Label Unit -> LCTerm [ctor] .
  op Lit : Label Prim -> LCTerm [ctor] .
  op Lam : Label ListVar LCTerm -> LCTerm [ctor] . *** name, binders, body
  op Let : Label Bindings LCTerm -> LCTerm [ctor] . 
  op If : Label LCTerm LCTerm LCTerm -> LCTerm [ctor] .
  op App : Label LCTerm LCTerms -> LCTerm [ctor] .
  *** MOAR ***
  op Mon : MLabel MLabel Label Contract LCTerm -> LCTerm [ctor] .

  *** Contracts ***
  op mkcon : SContract TContract -> Contract [ctor] .
  op ArrCon : Name List{SContract} SContract -> SContract [ctor] .
  op FlatCon : LCTerm -> SContract [ctor] .

  op add1 : -> Prim [ctor] .
  op sub1 : -> Prim [ctor] .
  op zero? : -> Prim [ctor] .
  op cons : -> Prim [ctor] .
  op null? : -> Prim [ctor] .
  op pair? : -> Prim [ctor] .
  op car : -> Prim [ctor] .
  op cdr : -> Prim [ctor] .

  *** Values ***
  op LitV_ : Int -> Value [ctor] .
  op LitV_ : Bool -> Value [ctor] .
  op LitV_ : Prim -> Value [ctor] .
  op LitV_ : Unit -> Value [ctor] .
  op IntTop : -> Value [ctor] .
  op CloV : ListVar LCTerm Env -> Value [ctor] .
  op blCloV : Name MLabel MLabel Label List{SContract} SContract Env Timeline Addr -> Value [ctor] .
  op vcons : Addr Addr ΛTimeline -> Value [ctor] .
endm

***( This would be a functional module to parameterize over allocation 
     and addreses, but alas, we can't write rewrite rules
     in a functional module)***
mod CESK is
  pr Syntax .
  pr AVal . 

  *** pr MAP{VAR, Addr} * (sort Map{VAR, Addr} to Env) .
  pr MAP{Addr, AVal} * (sort Map{Addr, AVal} to Heap ) .
  pr MAP{Addr, AKnt} * (sort Map{Addr, AKnt} to KHeap ) .
  ***pr LIST{Frame} * (sort List{Frame} to Kont) .
  pr LIST{Binding} * (sort List{Binding} to Bindings) .
  pr LIST{LCTerm} * (sort List{LCTerm} to LCTerms) .
  pr LIST{AVal} .
  pr BOOL-OPS .
  protecting META-LEVEL .

  op mtk : -> Kont [ctor] .
  op _k+_ : Frame Addr -> Kont [ctor] .

  op _vin_ : Value AVal -> Bool .
  op _abs-in_ : AVal AVal -> Bool .
  op _abs-has_ : AVal AVal -> Bool . *** like abs-in, only or instead of and.

  *** Primitive functions ***
  op zero? : -> Prim [ctor] .
  op add1 : -> Prim [ctor] .
  op sub1 : -> Prim [ctor] .

  *** Non-term syntax ***
  op _gets_ : VAR LCTerm -> Binding [ctor] .

  *** Continuations ***
  op ifk : LCTerm LCTerm Env -> Frame .
  op ev : LCTerms List{AVal} Env -> Frame .
  op ltk : VAR Bindings ListVar List{AVal} LCTerm Env -> Frame .
  op mnk : MLabel MLabel Label Contract Timeline Env -> Frame .
  op chkA : MLabel MLabel Label SContract Timeline Addr Addr -> Frame .
  op chkD : Addr Addr Timeline -> Frame .
  op chk : MLabel Value -> Frame .
  *** Expect a blclos (the called function), and name/timeline to return to.
  op postk : Value Name Timeline -> Frame .
  op rtk : Value Name Timeline -> Frame .
  

  op bind : ListAddr List{AVal} -> HeapDelta [ctor] .
  op same : -> HeapDelta [ctor] .

  op kbind : Addr AKnt -> KHeapDelta [ctor] .
  op ksame : -> KHeapDelta [ctor] .

  *** Machine states ***
  op wn : Point Heap KHeap -> State [ctor] .
    *** Only keep the heap so we can apply the delta as a standalone step.
  *** VAR is the inner-most named function we're in the context of.
  op wd : Point Heap HeapDelta KHeapDelta -> State [ctor] .
  op Eval : LCTerm Env Kont Name Timeline -> Point [ctor] .
  op Continue : Kont AVal Name Timeline -> Point [ctor] .
  op Apply : Value List{AVal} Kont Name Timeline -> Point [ctor] .
  op Fail : -> State [ctor] .

  *** Meta-functions ***
  op alloc : ListVar State -> ListVar .
  op allock : Label State -> Addr .
  op join : Heap Addr AVal -> Heap .
  op kjoin : KHeap Addr AKnt -> KHeap .
  op join-many : Heap ListAddr List{AVal} -> Heap .
  op bind-many : Env ListVar ListAddr -> Env .

  *** Metavariables for matching ***
  vars name x y : VAR .
  vars ℓ ℓ' : Label .
  vars β β' βu βc : MLabel .
  vars βΛ : ΛName .
  vars e e0 e1 e2 : LCTerm .
  vars ς ς' : State .
  vars a a' : Addr .
  var i : Int .
  var b : Bool .
  vars v v' : Value .
  vars ρ ρ0 ρ1 : Env .
  vars σ σ0 σ1 : Heap .
  vars kσ kσ0 kσ1 : KHeap .
  vars κ κ0 κ1 : Kont .
  vars es es0 es1 : LCTerms .
  vars as as' : ListVar . *** Addr
  vars vss vss' : List{AVal} .
  vars xs xs' : ListVar .
  var bs : Bindings .
  vars vs vs' : AVal .
  vars κs κs' : AKnt .
  var str : String .
  var δ : HeapDelta .
  var kδ : KHeapDelta .
  var ςh : Point .
  var βΛ : Name .
  var η : Timeline .
  var ηΛ : ΛTimeline .

  *** DEFINITIONS OF META-FUNCTIONS ***
  eq allock(ℓ, ς) = ℓ .
  eq alloc(nil, ς) = nil .
  eq alloc((vv str) xs, ς) = (aa str) alloc(xs, ς) .
  *** We can't overwrite bindings. Instead, we have to match to get the rest without the binding .
  eq join((σ, a |-> vs'), a, vs) = (σ,a |-> (vs' , vs)) .
  eq join(σ, a, vs) = (σ,a |-> vs) [owise] .

  eq kjoin((kσ, a |-> κs'), a, κs) = (kσ,a |-> (κs' , κs)) .
  eq kjoin(kσ, a, κs) = (kσ,a |-> κs) [owise] .

  op applyΔ : HeapDelta Heap -> Heap .
  eq applyΔ(same, σ) = σ .
  eq applyΔ(bind(as, vss), σ) = join-many(σ, as, vss) .

  op applykΔ : KHeapDelta KHeap -> KHeap .
  eq applykΔ(ksame, kσ) = kσ .
  eq applykΔ(kbind(a, κs), kσ) = kjoin(kσ, a, κs) .

  op bind-overwrite : Env VAR Addr -> Env .
  eq bind-overwrite((ρ, x |-> a), x, a') = ρ, x |-> a' .
  eq bind-overwrite(ρ, x, a) = ρ, x |-> a [owise] .

  *** abstractions ***
  eq LitV i vin (IntTop, vs) = true .
  eq v vin (v, vs) = true .
  eq v vin vs = false [owise] .

  eq empty abs-in vs = true .
  eq (v, vs) abs-in vs' = (v vin vs') and-then (vs abs-in vs') .

  eq empty abs-has vs = false .
  eq (v, vs) abs-has vs' = (v vin vs') or-else (vs abs-has vs') .

  op do-add1 : AVal -> AVal .
  op do-sub1 : AVal -> AVal .
  op do-zero? : AVal -> AVal .

  ceq do-add1(vs) = IntTop if vs abs-has IntTop .
  eq do-add1(vs) = empty [owise] .

  ceq do-sub1(vs) = IntTop if vs abs-has IntTop .
  eq do-sub1(vs) = empty [owise] .
***(
  eq do-zero?(empty) = empty .
  ceq do-zero?(v, vs) = (if (v == LitV 0) then
                            (LitV true)
                         else
                          if ((LitV 0) vin v) then
                             ((LitV true), (LitV false))
                          else
                             (LitV false)
                          fi
                        fi), do-zero?(vs) .
)
  *** Derived meta-functions ***
  eq bind-many(ρ, nil, nil) = ρ .
  eq bind-many(ρ, x xs, a as) = bind-many(bind-overwrite(ρ, x, a), xs, as) .

  eq join-many(σ, nil, nil) = σ .
  eq join-many(σ, a as, vs vss) = join-many(join(σ,a,vs), as, vss) .

  **********************************************************************
  ************************* The core semantics *************************
  **********************************************************************
  *** Eval rules ***
  crl [var-eval] : wn(Eval(Var(x), ρ, κ), σ, kσ, βΛ, ηΛ) => wd(Continue(κ, σ[ρ[x]], βΛ, ηΛ), σ, kσ, same, ksame)
                   if $hasMapping(ρ,x) .
  rl [litI-eval] : wn(Eval(Lit(i), ρ, κ, βΛ, ηΛ), σ, kσ) => wd(Continue(κ, LitV i, βΛ, ηΛ), σ, kσ, same, ksame) .
  rl [litB-eval] : wn(Eval(Lit(b), ρ, κ, βΛ, ηΛ), σ, kσ) => wd(Continue(κ, LitV b, βΛ, ηΛ), σ, kσ, same, ksame) .
  rl [Lam-eval] : wn(Eval(Lam(name, xs, e), ρ, κ, βΛ, ηΛ), σ, kσ) => wd(Continue(κ, CloV(name, xs, e, ρ), βΛ, ηΛ), σ, kσ, same, ksame) .
  crl [app-eval] : ς => wd(Eval(e0, ρ, ev(es, nil, ρ) k+ ak, βΛ, ηΛ), σ, kσ, same, kbind(ak, κ))
                   if wn(Eval(App(e0, es), ρ, κ, βΛ, ηΛ), σ, kσ) := ς
                   /\ ak := allock(ℓ, ς) .
  crl [if-eval] : ς => wd(Eval(e0, ρ, ifk(e1,e2,ρ) k+ ak, βΛ, ηΛ), σ, kσ, same, kbind(ak, κ))
                  if wn(Eval(If(e0,e1,e2), ρ, κ, βΛ, ηΛ), σ, kσ) := ς
                  /\ ak := allock(ℓ, ς) .
  rl [let0-eval] : wn(Eval(Let(nil, e), ρ, κ, βΛ, ηΛ), σ, kσ) => wd(Eval(e, ρ, κ, βΛ, ηΛ), σ, kσ, same, ksame) .
  crl [let-eval] : ς => wd(Eval(e0, ρ, ltk(x, bs, nil, nil, e1, ρ) k+ ak, βΛ, ηΛ), σ, kσ, same, kbind(ak, κ))
                   if wn(Eval(Let((x gets e0) bs, e1), ρ, κ, βΛ, ηΛ), σ, kσ) := ς
                   /\ ak := allock(ℓ, ς) .
  crl [let-bind] : ς => wd(Eval(e, ρ1, κ, βΛ, ηΛ), σ, kσ, bind(as, vs vss), kbind(ak, κ))
                   if wn(Continue(ltk(x, nil, xs, vss, e, ρ0) k+ ak, vs, βΛ, ηΛ), σ, kσ) := ς
                    /\ κ, κs := kσ[ak]
                    /\ xs' := (x xs)
                    /\ as := alloc(xs', ς)
                    /\ ak := allock(ℓ, ς) *** Distribute ℓ :(
                    /\ ρ1 := bind-many(ρ0, xs', as) .

  *** Continue rules ***
  rl [let-continue] : wn(Continue(ltk(x, (y gets e0) bs, xs, vss, e1, ρ) k+ ak, vs, βΛ, ηΛ), σ, kσ) =>
                      wd(Eval(e0, ρ, ltk(y, bs, x xs, vs vss, e1, ρ) k+ ak, βΛ, ηΛ), σ, kσ, same, ksame) .
  crl [ev0-continue] : wn(Continue(ev(nil, nil, ρ) k+ ak, vs, βΛ, ηΛ), σ, kσ) =>
                       wd(Apply(v, nil, κ, βΛ, ηΛ), σ, kσ, same, ksame)
                       if v:Value , vs' := vs 
                       /\ κ, κs := kσ[ak] .
  rl [ev-continue] : wn(Continue(ev(e es, vss, ρ) k+ ak, vs, βΛ, ηΛ), σ, kσ) =>
                     wd(Eval(e, ρ, ev(es, vs vss, ρ) k+ ak, βΛ, ηΛ), σ, kσ, same, ksame) .
  crl [ev-done] : wn(Continue(ev(nil, vss, ρ) k+ ak, vs, βΛ, ηΛ), σ, kσ) =>
                  wd(Apply(v, vss', κ), σ, kσ, same, ksame)
                  if ((v, vs') vss') := reverse(vs vss)
                  /\ κ, κs := kσ[ak] .
  crl [if-then] : wn(Continue(ifk(e0, e1, ρ) k+ ak, vs, βΛ, ηΛ), σ, kσ) =>
                  wd(Eval(e0, ρ, κ, βΛ, ηΛ), σ, kσ, same, ksame)
                  if LitV true in vs
                  /\ κ, κs := kσ[ak] .
  crl [if-else] : wn(Continue(ifk(e0, e1, ρ) k+ ak, vs, βΛ, ηΛ), σ, kσ) =>
                  wd(Eval(e1, ρ, κ, βΛ, ηΛ), σ, kσ, same, ksame)
                  if LitV false in vs
                  /\ κ, κs := kσ[ak] .

  *** Apply rules ***
  crl [Call] : ς => wd(Eval(e, ρ1, κ, βΛ, ηΛ), σ, kσ, bind(as, vss))
      if wn(Apply(CloV(name, xs, e, ρ0), vss, κ, βΛ, ηΛ), σ, kσ) := ς
      /\ as := alloc(xs, ς)
      /\ ρ1 := bind-many(ρ0, xs, as) .
  crl [Add1] : wn(Apply(LitV add1, vs, κ, βΛ, ηΛ), σ, kσ) => wd(Continue(κ, vs', βΛ, ηΛ), σ, kσ, same, ksame)
               if vs' := do-add1(vs)
               /\ vs' =/= empty .
  crl [Sub1] : wn(Apply(LitV sub1, vs, κ, βΛ, ηΛ), σ, kσ) => wd(Continue(κ, do-sub1(vs), βΛ, ηΛ), σ, kσ, same, ksame)
               if vs' := do-add1(vs)
               /\ vs' =/= empty .

*** INVARIANT: do-zero? can never introduce empty.
***  rl [Zero?] : wn(Apply(LitV zero?, vs, κ), σ, kσ) => wd(Continue(κ, do-zero?(vs)), σ, kσ, same, ksame) .

  *** Heap delta application (only for narrow evaluation) ***
  rl [Heap-change] : wd(ςh, σ, kσ, δ, kδ) => wn(ςh, applyΔ(δ, σ), applykΔ(kδ, kσ)) .

  *** Answers self-reduce in order to keep the Kripke structure infinite .
  rl [Answer] : wn(Continue(nil, vs, βΛ, ηΛ), σ, kσ) => wn(Continue(nil, vs, βΛ, ηΛ), σ, kσ) .

  **********************************************************************
  ******************* The monitor-specific semantics *******************
  **********************************************************************
  crl [Monitor-eval] : ς => wd(Eval(e, ρ, φ k+ ak, βΛ, ηΛ), σ, kσ, same, kbind(ak, κ))
                       if wn(Eval(Mon(βu, βc, ℓ, mkcon(S, T), e), ρ, κ, βΛ, ηΛ), σ, kσ) := ς
                       /\ ak := allock(ℓ, ς) .
endm
