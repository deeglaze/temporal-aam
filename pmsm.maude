
fmod WEAK-OPTION{X :: TRIV} is
 sort Weak-Option{X} .
 pr SET{X} .
 op Never : -> Weak-Option{X} [ctor] .
 op May_ : Set{X} -> Weak-Option{X} [ctor] .
 op Must_ : X$Elt -> Weak-Option{X} [ctor] .
endfm

mod BindEnv is
 pr ToDefine .
 pr Syntax .
 pr AVal .
 pr MAP{VAR, AVal} * (sort Map{VAR, AVal} to BindEnv) .
endm
view BindEnv from TRIV to BindEnv is sort Elt to BindEnv . endv

mod PMSM is
  pr Syntax .
  pr BindEnv .
  pr INT .
  pr WEAK-OPTION{BindEnv} .
  pr LIST{AllPat} .
  pr LIST{SContract} .
  pr Abstraction .

  op r$_ : VAR -> NamePat [ctor] .
  op rΛ_ : MLabel -> NamePat [ctor] .
  op cnst_ : Value -> ConstPat [ctor] .

  op b?_ : VAR -> BindPat [ctor] .
  op wc : -> RefPat [ctor] .

  vars x y : VAR .
  var v v' : Value .
  var a : Addr .
  var η : Timeline .
  vars δ δ' : BindEnv .
  var ρ : Env .
  vars n n' : NamePat .
  vars p p' : AllPat .
  vars vs vs' : AVal .
  vars ps ps' : List{AllPat} .
  vars pat pat' : Pattern .
  vars β β' βu βc : MLabel .
  vars ℓ : Label .
  vars S D R R' : SContract .
  vars Ds Ds' : List{SContract} .
  vars A A' : Event .
  var wδ : Weak-Option{BindEnv} .

  op matchpat : Pattern Pattern BindEnv -> Weak-Option{BindEnv} .
  op nonmatchpat : Pattern Pattern BindEnv -> Weak-Option{BindEnv} .
  op matchname : NamePat AllPat BindEnv -> Trit .
  op match : AllPat AllPat Weak-Option{BindEnv} -> Weak-Option{BindEnv} .
  op matches : List{AllPat} List{AllPat} Weak-Option{BindEnv} -> Weak-Option{BindEnv} .

  op weak-if : Trit Weak-Option{BindEnv} -> Weak-Option{BindEnv} [strat (1 0)] .
  eq weak-if(true, wδ) = wδ .
  eq weak-if(U, Must δ) = May δ .
  eq weak-if(U, May δ) = May δ .
  eq weak-if(U, Never) = Never .
  eq weak-if(false, wδ) = Never .

  eq matchpat(callev(n, ps), callev(n', ps'), δ) = weak-if(matchname(n,n',δ), matches(ps, ps', Must δ)) .
  eq matchpat(retev(n, p), retev(n', p'), δ) = weak-if(matchname(n, n', δ), match(p, p', Must δ)) .

  ceq nonmatchpat(pat, pat', δ) = May δ' if May δ' := matchpat(pat, pat', δ) .
  ceq nonmatchpat(pat, pat', δ) = Never if Must δ' := matchpat(pat, pat', δ) .
  ceq nonmatchpat(pat, pat', δ) = Must δ if Never := matchpat(pat, pat', δ) .

  eq matchname(r$ x, cnst v, (δ, x |-> vs)) = v vcouldeq vs .
  eq matchname(rΛ β, cnst blCloV(β, ℓ, βu, βc, Ds, R, ρ, η, a), δ) = true . *** Same β
  eq matchname(cnst v, cnst v', δ) = v veq v' .
  eq matchname(n, p, δ) = false [owise] .

  eq matches(nil, nil, wδ) = wδ .
  ceq matches(p ps, p' ps', wδ) = matches(ps, ps', Must δ') if Must δ' := match(p, p', wδ) .
  ceq matches(p ps, p' ps', wδ) = matches(ps, ps', May δ') if May δ' := match(p, p', wδ) .
  eq matches(ps, ps', wδ) = Never [owise] .

  eq match(b? x, cnst v, Must (δ, x |-> vs)) = Must (δ, x |-> v) .
  eq match(b? x, cnst v, May (δ, x |-> vs)) = May (δ, x |-> v) .
  eq match(b? x, cnst v, Must δ) = Must (δ, x |-> v) .
  eq match(b? x, cnst v, May δ) = Must (δ, x |-> v) .
  eq match(wc, cnst v, wδ) = wδ .
  eq match(r$ x, cnst v, Must (δ, x |-> vs)) = weak-if(v vcouldeq vs, Must (δ, x |-> vs)) .
  eq match(r$ x, cnst v, May (δ, x |-> vs)) = weak-if(v vcouldeq vs, May (δ, x |-> vs)) .
  eq match(cnst v, cnst v', wδ) = weak-if(v veq v', wδ) .
  eq match(p, p', wδ) = Never [owise] .
endm

mod TConPMSM is
  pr PMSM .
  pr INT .
  inc PMSM-Data .
  pr LIST{WCNamePat} .

  sorts MachineTop Machine MachineDo MakeMachine .
  vars m0 m1 m m' : Machine .
  var n : NamePat .
  vars pat pat' : Pattern .
  var E : Event .
  var mt mt0 mt1 : MachineTop .
  vars d d' d0 d1 : MachineDo .
  vars mkm1 mkm : MakeMachine .
  vars δ δ' δ0 δ1 : BindEnv .
  vars T T' : TContract .
  var wcns : List{WCNamePat} .

  op accepting : Machine -> MachineTop [ctor] .
  op nonaccepting : Machine -> MachineTop [ctor] .
  op bmachine : MachineDo BindEnv -> Machine [ctor] .
  op machine : MachineDo -> Machine [ctor] .

  *** Canonical machines
  op null-machine : -> MachineTop .
  op epsilon-machine : -> MachineTop .
  op sigma-star-machine : -> MachineTop .

  op machine-null : -> MachineDo [ctor] .
  op machine-sigma-star : -> MachineDo [ctor] .
  op machine-union : Machine Machine -> MachineDo [ctor] .
  op machine-seq : Machine MakeMachine -> MachineDo [ctor] .
  op machine-dseq : Pattern TContract -> MachineDo [ctor] .
  op machine-complement : Machine -> MachineDo [ctor] .
  op machine-match : Pattern -> MachineDo [ctor] .
  op machine-nonmatch : Pattern -> MachineDo [ctor] .

  op step : MachineTop Pattern -> MachineTop .

  op star-machine : MachineTop -> MachineTop .
  op seq-machine : MachineTop MakeMachine -> MachineTop .
  op complement-machine : MachineTop -> MachineTop .
  op union-machine : MachineTop MachineTop -> MachineTop .

  op mk-star : MachineTop -> MakeMachine [ctor] .
  op thunk : MachineTop -> MakeMachine [ctor] .
  op ext : TContract -> MakeMachine [ctor] .

  op event->pattern : Event -> Pattern .
  eq event->pattern(callact(n, wcns)) = callev(n, wcns) .
  eq event->pattern(retact(n, wcns)) = retev(n, wcns) .

  op TCon->Machine : TContract BindEnv -> MachineTop .
  eq TCon->Machine(tev(E), δ) = accepting(bmachine(machine-match(event->pattern(E)), δ)) .
  eq TCon->Machine(!ev(E), δ) = accepting(bmachine(machine-nonmatch(event->pattern(E)), δ)) .
  eq TCon->Machine(ddd, δ) = sigma-star-machine .
  eq TCon->Machine(T ∪ T', δ) = union-machine(TCon->Machine(T, δ), TCon->Machine(T', δ)) .
  eq TCon->Machine(T · T', δ) = seq-machine(TCon->Machine(T, δ), thunk(TCon->Machine(T', δ))) .
  eq TCon->Machine(¬ T, δ) = complement-machine(TCon->Machine(T, δ)) .
  eq TCon->Machine(kl T, δ) = star-machine(TCon->Machine(T, δ)) .
  eq TCon->Machine(dseq(pat, T), δ) = accepting(bmachine(machine-dseq(pat, T), δ)) .

  op machine->accepting : MachineTop -> MachineTop .
  op machine->nonaccepting : MachineTop -> MachineTop .
  eq machine->accepting(nonaccepting(m)) = accepting(m) .
  eq machine->accepting(mt) = mt [owise] .

  eq machine->nonaccepting(accepting(m)) = nonaccepting(m) .
  eq machine->nonaccepting(mt) = mt [owise] .

  op machine-accepting? : MachineTop -> Bool .
  eq machine-accepting?(nonaccepting(m)) = false .
  eq machine-accepting?(accepting(m)) = true .

  eq sigma-star-machine = accepting(machine(machine-sigma-star)) .
  eq null-machine = nonaccepting(machine(machine-null)) .
  eq epsilon-machine = accepting(machine(machine-null)) .

  op machine-do : Machine -> MachineDo .
  eq machine-do(bmachine(d, δ)) = d .
  eq machine-do(machine(d)) = d .

  op top->machine : MachineTop -> Machine .
  eq top->machine(accepting(m)) = m .
  eq top->machine(nonaccepting(m)) = m .

  eq union-machine(nonaccepting(machine(machine-null)), mt1) = mt1 . *** m0 is null machine
  eq union-machine(mt0, nonaccepting(machine(machine-null))) = mt0 . *** m1 is null machine
  eq union-machine(accepting(machine(machine-null)), mt1) = machine->accepting(mt1) . *** m0 ε machine
  eq union-machine(mt0, accepting(machine(machine-null))) = machine->accepting(mt0) . *** m1 ε machine
  eq union-machine(nonaccepting(m0), nonaccepting(m1)) = nonaccepting(machine(machine-union(m0, m1))) .
  eq union-machine(mt0, mt1) = accepting(machine(machine-union(top->machine(mt0), top->machine(mt1)))) [owise] .

  eq complement-machine(accepting(m)) = nonaccepting(machine(machine-complement(m))) .
  eq complement-machine(nonaccepting(m)) = accepting(machine(machine-complement(m))) .

  op make-machine : MakeMachine -> MachineTop .
  eq make-machine(mk-star(mt)) = star-machine(mt) .
  eq make-machine(thunk(mt)) = mt .

  eq seq-machine(accepting(machine(machine-null)), mkm1) = make-machine(mkm1) .
  eq seq-machine(nonaccepting(machine(machine-null)), mkm1) = null-machine .
  eq seq-machine(accepting(m), mkm1) =
     union-machine(nonaccepting(machine(machine-seq(m, mkm1))), make-machine(mkm1)) .
  eq seq-machine(nonaccepting(m), mkm1) = nonaccepting(machine(machine-seq(m, mkm1))) .

  eq star-machine(nonaccepting(machine(machine-null))) = null-machine .
  eq star-machine(mt) = machine->accepting(seq-machine(machine->nonaccepting(mt), mk-star(mt))) .

  op do-machine : Machine Pattern -> MachineTop .
  eq step(accepting(m), pat) = do-machine(m, pat) .
  eq step(nonaccepting(m), pat) = do-machine(m, pat) .

  eq do-machine(machine(machine-null), pat) = null-machine .
  eq do-machine(machine(machine-union(m0, m1)), pat) =
     union-machine(do-machine(m0, pat), do-machine(m1, pat)) .
  eq do-machine(machine(machine-seq(m, mkm)), pat) = seq-machine(do-machine(m, pat), mkm) .
  eq do-machine(machine(machine-complement(m)), pat) = complement-machine(do-machine(m, pat)) .
  eq do-machine(machine(machine-sigma-star), pat) = sigma-star-machine . *** Consume and continue

  *** A
  ceq do-machine(bmachine(machine-match(pat), δ), pat') = epsilon-machine
      if Must δ' := matchpat(pat, pat', δ) .
  ceq do-machine(bmachine(machine-match(pat), δ), pat') = null-machine
      if Never := matchpat(pat, pat', δ) .
  ceq do-machine(bmachine(machine-match(pat), δ), pat') = union-machine(null-machine, epsilon-machine)
      if May δ' := matchpat(pat, pat', δ) .

  *** ! A
  ceq do-machine(bmachine(machine-nonmatch(pat), δ), pat') = epsilon-machine
      if Must δ' := nonmatchpat(pat, pat', δ) .
  ceq do-machine(bmachine(machine-nonmatch(pat), δ), pat') = null-machine
      if Never := nonmatchpat(pat, pat', δ) .
  ceq do-machine(bmachine(machine-nonmatch(pat), δ), pat') = union-machine(null-machine, epsilon-machine)
      if May δ' := nonmatchpat(pat, pat', δ) .

  *** Dependent sequencing
  ceq do-machine(bmachine(machine-dseq(pat, T), δ), pat') = null-machine
      if Never := matchpat(pat, pat', δ) .
  ceq do-machine(bmachine(machine-dseq(pat, T), δ), pat') = TCon->Machine(T, δ')
      if Must δ' := matchpat(pat, pat', δ) .
  ceq do-machine(bmachine(machine-dseq(pat, T), δ), pat') = union-machine(TCon->Machine(T, δ'), null-machine)
      if May δ' := matchpat(pat, pat', δ) .
endm
